Hash,Message,Filename,Source Code (before),Source Code (current),Diff,LLM Inference (fix type),Rectified Message,MI_Before,MI_After,CC_Before,CC_After,LOC_Before,LOC_After,MI_Change,CC_Change,LOC_Change,Semantic_Similarity,Token_Similarity,Semantic_class,Token_class,Classes_Agree
3da6370a654b20cd90cd1bf492cd032c57e177b2,"use defaults better, improve/fix setup.py",bin/ansible,"#!/usr/bin/python

# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from optparse import OptionParser
import json
import os
import ansible

DEFAULT_HOST_LIST      = '~/.ansible_hosts'
DEFAULT_MODULE_PATH    = '~/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser()
        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
            help=""path to hosts list"", default=DEFAULT_HOST_LIST)
        parser.add_option(""-L"", ""--library"", dest=""module_path"",
            help=""path to module library"", default=DEFAULT_MODULE_PATH)
        parser.add_option(""-F"", ""--forks"", dest=""forks"",
            help=""level of parallelism"", default=DEFAULT_FORKS)
        parser.add_option(""-n"", ""--name"", dest=""module_name"",
            help=""module name to execute"", default=DEFAULT_MODULE_NAME)
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=DEFAULT_MODULE_ARGS)
        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
            help=""hostname pattern"", default=DEFAULT_PATTERN)

        options, args = parser.parse_args()
        host_list      = self._host_list(options.host_list)

        # TODO: more shell like splitting on module_args would
        # be a good idea

        return ansible.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=options.module_args.split(' '),
            host_list=host_list,
            forks=options.forks,
            pattern=options.pattern,
        )

    def _host_list(self, host_list):
        host_list = os.path.expanduser(host_list)
        return file(host_list).read().split(""\n"")

if __name__ == '__main__':

    result = Cli().runner().run()
    print json.dumps(result, sort_keys=True, indent=4)


","#!/usr/bin/python

# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from optparse import OptionParser
import json
import os
import ansible

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser()
        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
            help=""path to hosts list"", default=DEFAULT_HOST_LIST)
        parser.add_option(""-L"", ""--library"", dest=""module_path"",
            help=""path to module library"", default=DEFAULT_MODULE_PATH)
        parser.add_option(""-F"", ""--forks"", dest=""forks"",
            help=""level of parallelism"", default=DEFAULT_FORKS)
        parser.add_option(""-n"", ""--name"", dest=""module_name"",
            help=""module name to execute"", default=DEFAULT_MODULE_NAME)
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=DEFAULT_MODULE_ARGS)
        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
            help=""hostname pattern"", default=DEFAULT_PATTERN)

        options, args = parser.parse_args()

        # TODO: more shell like splitting on module_args would
        # be a good idea

        return ansible.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=options.module_args.split(' '),
            host_list=options.host_list,
            forks=options.forks,
            pattern=options.pattern,
            verbose=False,
        )

if __name__ == '__main__':

    result = Cli().runner().run()
    print json.dumps(result, sort_keys=True, indent=4)


","@@ -26,8 +26,8 @@ import json
 import os
 import ansible
 
-DEFAULT_HOST_LIST      = '~/.ansible_hosts'
-DEFAULT_MODULE_PATH    = '~/ansible'
+DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
+DEFAULT_MODULE_PATH    = '/usr/share/ansible'
 DEFAULT_MODULE_NAME    = 'ping'
 DEFAULT_PATTERN        = '*'
 DEFAULT_FORKS          = 3
@@ -54,7 +54,6 @@ class Cli(object):
             help=""hostname pattern"", default=DEFAULT_PATTERN)
 
         options, args = parser.parse_args()
-        host_list      = self._host_list(options.host_list)
 
         # TODO: more shell like splitting on module_args would
         # be a good idea
@@ -63,15 +62,12 @@ class Cli(object):
             module_name=options.module_name,
             module_path=options.module_path,
             module_args=options.module_args.split(' '),
-            host_list=host_list,
+            host_list=options.host_list,
             forks=options.forks,
             pattern=options.pattern,
+            verbose=False,
         )
 
-    def _host_list(self, host_list):
-        host_list = os.path.expanduser(host_list)
-        return file(host_list).read().split(""\n"")
-
 if __name__ == '__main__':
 
     result = Cli().runner().run()
",code-fix,code-fix: Modify ansible: +4/-8 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999116659164428,0.9311672729668272,Minor,Minor,YES
3da6370a654b20cd90cd1bf492cd032c57e177b2,"use defaults better, improve/fix setup.py",lib/ansible/__init__.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
from multiprocessing import Process, Pipe
from itertools import izip
import os
import json

# non-core 
import paramiko

# TODO -- library should have defaults, not just CLI
# update Runner constructor below to use

DEFAULT_HOST_LIST      = '~/.ansible_hosts'
DEFAULT_MODULE_PATH    = '~/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''

class Pooler(object):

    # credit: http://stackoverflow.com/questions/3288595/multiprocessing-using-pool-map-on-a-function-defined-in-a-class

    @classmethod
    def spawn(cls, f):
        def fun(pipe,x):
            pipe.send(f(x))
            pipe.close()
        return fun

    @classmethod
    def parmap(cls, f, X):
        pipe=[Pipe() for x in X]
        proc=[Process(target=cls.spawn(f),args=(c,x)) for x,(p,c) in izip(X,pipe)]
        [p.start() for p in proc]
        [p.join() for p in proc]
        return [p.recv() for (p,c) in pipe]

class Runner(object):

   def __init__(self, host_list=[], module_path=None,
       module_name=None, module_args=[], 
       forks=3, timeout=60, pattern='*'):

       self.host_list   = host_list
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
 

   def _matches(self, host_name):
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username='root',
              allow_agent=True, look_for_keys=True)
          return ssh
       except:
          return None

   def _executor(self, host):
       # TODO: try/catch returning none
       conn = self._connect(host)
       if not conn:
           return [ host, None ]
       if self.module_name != ""copy"":
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           result = json.loads(result)
       else:
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           return [ host, 1 ]
           
       return [ host, result ]

   def _command(self, outpath):
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = stdout.read()
       return results

   def _copy_module(self, conn):
       inpath = os.path.expanduser(os.path.join(self.module_path, self.module_name))
       outpath = os.path.join(""/var/spool/"", ""ansible_%s"" % self.module_name)
       ftp = conn.open_sftp()
       ftp.put(inpath, outpath)
       ftp.close()
       return outpath

   def run(self):
       hosts = [ h for h in self.host_list if self._matches(h) ]
       def executor(x):
           return self._executor(x)
       results = Pooler.parmap(executor, hosts)
       by_host = dict(results)
       return by_host


if __name__ == '__main__':


    # TODO: if host list is string load from file

    r = Runner(
       host_list = [ '127.0.0.1' ],
       module_path='~/ansible',
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
from multiprocessing import Process, Pipe
from itertools import izip
import os
import json
import traceback

# non-core 
import paramiko

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 60

class Pooler(object):

    # credit: http://stackoverflow.com/questions/3288595/multiprocessing-using-pool-map-on-a-function-defined-in-a-class

    @classmethod
    def spawn(cls, f):
        def fun(pipe,x):
            pipe.send(f(x))
            pipe.close()
        return fun

    @classmethod
    def parmap(cls, f, X):
        pipe=[Pipe() for x in X]
        proc=[Process(target=cls.spawn(f),args=(c,x)) for x,(p,c) in izip(X,pipe)]
        [p.start() for p in proc]
        [p.join() for p in proc]
        return [p.recv() for (p,c) in pipe]

class Runner(object):

   def __init__(self, 
       host_list=DEFAULT_HOST_LIST, 
       module_path=DEFAULT_MODULE_PATH,
       module_name=DEFAULT_MODULE_NAME, 
       module_args=DEFAULT_MODULE_ARGS, 
       forks=DEFAULT_FORKS, 
       timeout=DEFAULT_TIMEOUT, 
       pattern=DEFAULT_PATTERN,
       verbose=False):
      

       '''
       Constructor.
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ''' obtains a paramiko connection to the host '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username='root',
              allow_agent=True, look_for_keys=True)
          return ssh
       except:
          # TODO -- just convert traceback to string
          # and return a seperate hash of failed hosts
          if self.verbose:
             traceback.print_exc()
          return None

   def _executor(self, host):
       ''' callback executed in parallel for each host '''
       # TODO: try/catch returning none

       conn = self._connect(host)
       if not conn:
           return [ host, None ]

       if self.module_name != ""copy"":
           # transfer a module, set it executable, and run it
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           result = json.loads(result)
       else:
           # SFTP file copy module is not really a module
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           return [ host, 1 ]
           
       return [ host, result ]

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = stdout.read()
       return results

   def _copy_module(self, conn):
       ''' transfer a module over SFTP '''
       in_path = os.path.expanduser(
           os.path.join(self.module_path, self.module_name)
       )
       out_path = os.path.join(
           ""/var/spool/"", 
           ""ansible_%s"" % self.module_name
       )
       sftp = conn.open_sftp()
       sftp.put(in_path, out_path)
       sftp.close()
       return out_path

   def run(self):
       ''' xfer & run module on all matched hosts '''
       hosts = [ h for h in self.host_list if self._matches(h) ]
       def executor(x):
           return self._executor(x)
       results = Pooler.parmap(executor, hosts)
       by_host = dict(results)
       return by_host


if __name__ == '__main__':

    # test code...

    r = Runner(
       host_list = DEFAULT_HOST_LIST,
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","@@ -24,19 +24,18 @@ from multiprocessing import Process, Pipe
 from itertools import izip
 import os
 import json
+import traceback
 
 # non-core 
 import paramiko
 
-# TODO -- library should have defaults, not just CLI
-# update Runner constructor below to use
-
-DEFAULT_HOST_LIST      = '~/.ansible_hosts'
-DEFAULT_MODULE_PATH    = '~/ansible'
+DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
+DEFAULT_MODULE_PATH    = '/usr/share/ansible'
 DEFAULT_MODULE_NAME    = 'ping'
 DEFAULT_PATTERN        = '*'
 DEFAULT_FORKS          = 3
 DEFAULT_MODULE_ARGS    = ''
+DEFAULT_TIMEOUT        = 60
 
 class Pooler(object):
 
@@ -59,20 +58,40 @@ class Pooler(object):
 
 class Runner(object):
 
-   def __init__(self, host_list=[], module_path=None,
-       module_name=None, module_args=[], 
-       forks=3, timeout=60, pattern='*'):
-
-       self.host_list   = host_list
+   def __init__(self, 
+       host_list=DEFAULT_HOST_LIST, 
+       module_path=DEFAULT_MODULE_PATH,
+       module_name=DEFAULT_MODULE_NAME, 
+       module_args=DEFAULT_MODULE_ARGS, 
+       forks=DEFAULT_FORKS, 
+       timeout=DEFAULT_TIMEOUT, 
+       pattern=DEFAULT_PATTERN,
+       verbose=False):
+      
+
+       '''
+       Constructor.
+       '''
+
+       self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
- 
+       self.verbose     = verbose
+
+   def _parse_hosts(self, host_list):
+        ''' parse the host inventory file if not sent as an array '''
+        if type(host_list) != list:
+            host_list = os.path.expanduser(host_list)
+            return file(host_list).read().split(""\n"")
+        return host_list
+
 
    def _matches(self, host_name):
+       ''' returns if a hostname is matched by the pattern '''
        if host_name == '':
            return False
        if fnmatch.fnmatch(host_name, self.pattern):
@@ -80,6 +99,7 @@ class Runner(object):
        return False
 
    def _connect(self, host):
+       ''' obtains a paramiko connection to the host '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
@@ -87,20 +107,29 @@ class Runner(object):
               allow_agent=True, look_for_keys=True)
           return ssh
        except:
+          # TODO -- just convert traceback to string
+          # and return a seperate hash of failed hosts
+          if self.verbose:
+             traceback.print_exc()
           return None
 
    def _executor(self, host):
+       ''' callback executed in parallel for each host '''
        # TODO: try/catch returning none
+
        conn = self._connect(host)
        if not conn:
            return [ host, None ]
+
        if self.module_name != ""copy"":
+           # transfer a module, set it executable, and run it
            outpath = self._copy_module(conn)
            self._exec_command(conn, ""chmod +x %s"" % outpath)
            cmd = self._command(outpath)
            result = self._exec_command(conn, cmd)
            result = json.loads(result)
        else:
+           # SFTP file copy module is not really a module
            ftp = conn.open_sftp()
            ftp.put(self.module_args[0], self.module_args[1])
            ftp.close()
@@ -109,23 +138,32 @@ class Runner(object):
        return [ host, result ]
 
    def _command(self, outpath):
+       ''' form up a command string '''
        cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
        return cmd
 
    def _exec_command(self, conn, cmd):
+       ''' execute a command over SSH '''
        stdin, stdout, stderr = conn.exec_command(cmd)
        results = stdout.read()
        return results
 
    def _copy_module(self, conn):
-       inpath = os.path.expanduser(os.path.join(self.module_path, self.module_name))
-       outpath = os.path.join(""/var/spool/"", ""ansible_%s"" % self.module_name)
-       ftp = conn.open_sftp()
-       ftp.put(inpath, outpath)
-       ftp.close()
-       return outpath
+       ''' transfer a module over SFTP '''
+       in_path = os.path.expanduser(
+           os.path.join(self.module_path, self.module_name)
+       )
+       out_path = os.path.join(
+           ""/var/spool/"", 
+           ""ansible_%s"" % self.module_name
+       )
+       sftp = conn.open_sftp()
+       sftp.put(in_path, out_path)
+       sftp.close()
+       return out_path
 
    def run(self):
+       ''' xfer & run module on all matched hosts '''
        hosts = [ h for h in self.host_list if self._matches(h) ]
        def executor(x):
            return self._executor(x)
@@ -136,12 +174,10 @@ class Runner(object):
 
 if __name__ == '__main__':
 
-
-    # TODO: if host list is string load from file
+    # test code...
 
     r = Runner(
-       host_list = [ '127.0.0.1' ],
-       module_path='~/ansible',
+       host_list = DEFAULT_HOST_LIST,
        module_name='ping',
        module_args='',
        pattern='*',
",logic-fix,logic-fix: Modify __init__.py: +57/-21 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9997881650924684,0.6867305300206147,Minor,Major,NO
3da6370a654b20cd90cd1bf492cd032c57e177b2,"use defaults better, improve/fix setup.py",setup.py,"#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ancible', 'library/ping'),
         ('/usr/share/ancible', 'library/command'),
         ('/usr/share/ancible', 'library/facter'),
         ('/usr/share/ancible', 'library/copy'),
      ],
      scripts=[
         'bin/ansible',
      ]
)

","#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/copy',
         ])
      ],
      scripts=[
         'bin/ansible',
      ]
)

","@@ -14,10 +14,12 @@ setup(name='ansible',
          'ansible',
       ],
       data_files=[ 
-         ('/usr/share/ancible', 'library/ping'),
-         ('/usr/share/ancible', 'library/command'),
-         ('/usr/share/ancible', 'library/facter'),
-         ('/usr/share/ancible', 'library/copy'),
+         ('/usr/share/ansible', [ 
+             'library/ping',
+             'library/command',
+             'library/facter',
+             'library/copy',
+         ])
       ],
       scripts=[
          'bin/ansible',
",build-fix,build-fix: Modify setup.py: +6/-4 lines,100.0,100.0,0,0,26,28,0.0,0,2,0.9956399202346802,0.7642078317234667,Minor,Minor,YES
530e54b3e44becd9ad631a6500e4232ccadac1af,Fix multiprocessing pool usage and remove stackoverflow hack,README.md,"Ansible
=======

Ansible is a extra-simple Python API for doing 'remote things' over SSH.  

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

    * Dead simple setup
    * Super fast & parallel by default
    * No server or client daemons, uses existing SSHd
    * No additional software required on client boxes
    * Everything is self updating on the clients  
    * Encourages use of ssh-agent
    * Plugins can be written in ANY language
    * API usage is an equal citizen to CLI usage
    * Can be controlled/installed/used as non-root

Requirements
============

For the server the tool is running from, *only*:

    * python 2.6 -- or the 2.4/2.5 backport of the multiprocessing module
    * paramiko

Inventory file
==============

The inventory file is a required list of hostnames that can be 
potentially managed by ansible.  Eventually this file may be editable 
via the CLI, but for now, is edited with your favorite text editor.

The default inventory file (-H) is /etc/ansible/hosts and is a list
of all hostnames to target with ansible, one per line.  These
can be hostnames or IPs

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-P) to target
specific hosts.  This is covered below.

You can organize groups of systems by having multiple inventory
files (i.e. keeping webservers different from dbservers, etc)

Command line usage example
==========================

Run a module by name with arguments
 
   * ssh-agent bash
   * ssh-add ~/.ssh/id_rsa.pub
   * ansible -p ""*.example.com"" -n modName -a ""arg1 arg2""

API Example
===========

The API is simple and returns basic datastructures.

    import ansible
    runner = ansible.Runner(
        pattern='*',
        module_name='inventory',
        module_args='...' 
    )
    data = runner.run()

    {
        'xyz.example.com' : [ 'any kind of datastructure is returnable' ],
        'foo.example.com' : None, # failed to connect,
        ...
    }

Additional options to Runner include the number of forks, hostname
exclusion pattern, library path, arguments, and so on.  
Read the source, it's not complicated.

Patterns
========

To target only hosts starting with ""rtp"", for example:

   * ansible -p ""rtp*"" -n command -a ""yum update apache""

Parallelism
===========

Specify the number of forks to use, to run things in greater parallelism.

    * ansible -f 10 ""*.example.com"" -n command -a ""yum update apache""

10 forks.  The default is 3.  5 is right out.

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

   * ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Ansible Library (Bundled Modules)
=================================

See the example library for modules, they can be written in any language
and simply return JSON to stdout.  The path to your ansible library is
specified with the ""-L"" flag should you wish to use a different location
than ""/usr/share/ansible"".  This means anyone can use Ansible, even without
root permissions.

There is potential for a sizeable community to build 
up around the library scripts.

Modules include:

   * command -- runs commands, giving output, return codes, and run time info
   * ping - just returns if the system is up or not
   * facter - retrieves facts about the host OS
   * copy - add files to remote systems

Future plans
============

   * see TODO.md

License
=======

   * MIT

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","Ansible
=======

Ansible is a extra-simple Python API for doing 'remote things' over SSH.  

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

    * Dead simple setup
    * Super fast & parallel by default
    * No server or client daemons, uses existing SSHd
    * No additional software required on client boxes
    * Everything is self updating on the clients  
    * Encourages use of ssh-agent
    * Plugins can be written in ANY language
    * API usage is an equal citizen to CLI usage
    * Can be controlled/installed/used as non-root

Requirements
============

For the server the tool is running from, *only*:

    * python 2.6 -- or the 2.4/2.5 backport of the multiprocessing module
    * paramiko

Inventory file
==============

The inventory file is a required list of hostnames that can be 
potentially managed by ansible.  Eventually this file may be editable 
via the CLI, but for now, is edited with your favorite text editor.

The default inventory file (-H) is /etc/ansible/hosts and is a list
of all hostnames to target with ansible, one per line.  These
can be hostnames or IPs

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-P) to target
specific hosts.  This is covered below.

You can organize groups of systems by having multiple inventory
files (i.e. keeping webservers different from dbservers, etc)

Command line usage example
==========================

Run a module by name with arguments
 
   * ssh-agent bash
   * ssh-add ~/.ssh/id_rsa.pub
   * ansible -p ""*.example.com"" -n modName -a ""arg1 arg2""

API Example
===========

The API is simple and returns basic datastructures.

    import ansible
    runner = ansible.Runner(
        pattern='*',
        module_name='inventory',
        module_args='...' 
    )
    data = runner.run()

    { 
        'successful' : {
            'xyz.example.com' : [ 'any kind of datastructure is returnable' ],
            'foo.example.com' : [ '...' ]
        },
        'failed' : {
            'bar.example.com' : [ 'failure message' ]
        }
    }

Additional options to Runner include the number of forks, hostname
exclusion pattern, library path, arguments, and so on.  
Read the source, it's not complicated.

Patterns
========

To target only hosts starting with ""rtp"", for example:

   * ansible -p ""rtp*"" -n command -a ""yum update apache""

Parallelism
===========

Specify the number of forks to use, to run things in greater parallelism.

    * ansible -f 10 ""*.example.com"" -n command -a ""yum update apache""

10 forks.  The default is 3.  5 is right out.

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

   * ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Ansible Library (Bundled Modules)
=================================

See the example library for modules, they can be written in any language
and simply return JSON to stdout.  The path to your ansible library is
specified with the ""-L"" flag should you wish to use a different location
than ""/usr/share/ansible"".  This means anyone can use Ansible, even without
root permissions.

There is potential for a sizeable community to build 
up around the library scripts.

Modules include:

   * command -- runs commands, giving output, return codes, and run time info
   * ping - just returns if the system is up or not
   * facter - retrieves facts about the host OS
   * copy - add files to remote systems

Future plans
============

   * see TODO.md

License
=======

   * MIT

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","@@ -85,10 +85,14 @@ The API is simple and returns basic datastructures.
     )
     data = runner.run()
 
-    {
-        'xyz.example.com' : [ 'any kind of datastructure is returnable' ],
-        'foo.example.com' : None, # failed to connect,
-        ...
+    { 
+        'successful' : {
+            'xyz.example.com' : [ 'any kind of datastructure is returnable' ],
+            'foo.example.com' : [ '...' ]
+        },
+        'failed' : {
+            'bar.example.com' : [ 'failure message' ]
+        }
     }
 
 Additional options to Runner include the number of forks, hostname
",doc-fix,doc-fix: Modify README.md: +8/-4 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999997615814208,0.9713663442397086,Minor,Minor,YES
530e54b3e44becd9ad631a6500e4232ccadac1af,Fix multiprocessing pool usage and remove stackoverflow hack,bin/ansible-inventory,"#!/usr/bin/python

# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from optparse import OptionParser
import json
import os
import ansible

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_REMOTE_USER    = 'root'

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser()
        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
            help=""path to hosts list"", default=DEFAULT_HOST_LIST)
        parser.add_option(""-L"", ""--library"", dest=""module_path"",
            help=""path to module library"", default=DEFAULT_MODULE_PATH)
        parser.add_option(""-f"", ""--forks"", dest=""forks"",
            help=""level of parallelism"", default=DEFAULT_FORKS)
        parser.add_option(""-n"", ""--name"", dest=""module_name"",
            help=""module name to execute"", default=DEFAULT_MODULE_NAME)
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=DEFAULT_MODULE_ARGS)
        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
            help=""hostname pattern"", default=DEFAULT_PATTERN)
        parser.add_option(""-u"", ""--remote-user"", dest=""remote_user"",
            help=""remote username"", default=DEFAULT_REMOTE_USER)

        options, args = parser.parse_args()

        # TODO: more shell like splitting on module_args would
        # be a good idea

        return ansible.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=options.module_args.split(' '),
            remote_user=options.remote_user,
            host_list=options.host_list,
            forks=options.forks,
            pattern=options.pattern,
            verbose=False,
        )

if __name__ == '__main__':

    result = Cli().runner().run()
    print json.dumps(result, sort_keys=True, indent=4)


",,"@@ -1,80 +0,0 @@
-#!/usr/bin/python
-
-# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
-#
-# Permission is hereby granted, free of charge, to any person
-# obtaining a copy of this software and associated documentation
-# files (the ""Software""), to deal in the Software without restriction,
-# including without limitation the rights to use, copy, modify, merge,
-# publish, distribute, sublicense, and/or sell copies of the Software,
-# and to permit persons to whom the Software is furnished to do so,
-# subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be
-# included in all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
-# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
-# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-from optparse import OptionParser
-import json
-import os
-import ansible
-
-DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
-DEFAULT_MODULE_PATH    = '/usr/share/ansible'
-DEFAULT_MODULE_NAME    = 'ping'
-DEFAULT_PATTERN        = '*'
-DEFAULT_FORKS          = 3
-DEFAULT_MODULE_ARGS    = ''
-DEFAULT_REMOTE_USER    = 'root'
-
-class Cli(object):
-
-    def __init__(self):
-        pass
-
-    def runner(self):
-        parser = OptionParser()
-        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
-            help=""path to hosts list"", default=DEFAULT_HOST_LIST)
-        parser.add_option(""-L"", ""--library"", dest=""module_path"",
-            help=""path to module library"", default=DEFAULT_MODULE_PATH)
-        parser.add_option(""-f"", ""--forks"", dest=""forks"",
-            help=""level of parallelism"", default=DEFAULT_FORKS)
-        parser.add_option(""-n"", ""--name"", dest=""module_name"",
-            help=""module name to execute"", default=DEFAULT_MODULE_NAME)
-        parser.add_option(""-a"", ""--args"", dest=""module_args"",
-            help=""module arguments"", default=DEFAULT_MODULE_ARGS)
-        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
-            help=""hostname pattern"", default=DEFAULT_PATTERN)
-        parser.add_option(""-u"", ""--remote-user"", dest=""remote_user"",
-            help=""remote username"", default=DEFAULT_REMOTE_USER)
-
-        options, args = parser.parse_args()
-
-        # TODO: more shell like splitting on module_args would
-        # be a good idea
-
-        return ansible.Runner(
-            module_name=options.module_name,
-            module_path=options.module_path,
-            module_args=options.module_args.split(' '),
-            remote_user=options.remote_user,
-            host_list=options.host_list,
-            forks=options.forks,
-            pattern=options.pattern,
-            verbose=False,
-        )
-
-if __name__ == '__main__':
-
-    result = Cli().runner().run()
-    print json.dumps(result, sort_keys=True, indent=4)
-
-
",code-fix,code-fix: Modify ansible-inventory: +0/-80 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5590871572494507,0.0,Major,Major,YES
530e54b3e44becd9ad631a6500e4232ccadac1af,Fix multiprocessing pool usage and remove stackoverflow hack,lib/ansible/__init__.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
from multiprocessing import Process, Pipe
from itertools import izip
import os
import json
import traceback
import select

# non-core 
import paramiko

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 60
DEFAULT_REMOTE_USER    = 'root'

class Pooler(object):

    # credit: http://stackoverflow.com/questions/3288595/multiprocessing-using-pool-map-on-a-function-defined-in-a-class

    @classmethod
    def spawn(cls, f):
        def fun(pipe,x):
            pipe.send(f(x))
            pipe.close()
        return fun

    @classmethod
    def parmap(cls, f, X):
        pipe=[Pipe() for x in X]
        proc=[Process(target=cls.spawn(f),args=(c,x)) for x,(p,c) in izip(X,pipe)]
        [p.start() for p in proc]
        [p.join() for p in proc]
        return [p.recv() for (p,c) in pipe]

class Runner(object):

   def __init__(self, 
       host_list=DEFAULT_HOST_LIST, 
       module_path=DEFAULT_MODULE_PATH,
       module_name=DEFAULT_MODULE_NAME, 
       module_args=DEFAULT_MODULE_ARGS, 
       forks=DEFAULT_FORKS, 
       timeout=DEFAULT_TIMEOUT, 
       pattern=DEFAULT_PATTERN,
       remote_user=DEFAULT_REMOTE_USER,
       verbose=False):
      

       '''
       Constructor.
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose
       self.remote_user = remote_user

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ''' obtains a paramiko connection to the host '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username=self.remote_user,
              allow_agent=True, look_for_keys=True)
          return [ True, ssh ]
       except:
          return [ False, traceback.format_exc() ]

   def _executor(self, host):
       ''' callback executed in parallel for each host '''
       # TODO: try/catch returning none

       ok, conn = self._connect(host)
       if not ok:
           return [ host, False, conn ]

       if self.module_name != ""copy"":
           # transfer a module, set it executable, and run it
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           conn.close()
           return [ host, True, json.loads(result) ]
       else:
           # SFTP file copy module is not really a module
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           conn.close()
           return [ host, True, 1 ]
           

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = ""\n"".join(stdout.readlines())
       return results

   def _copy_module(self, conn):
       ''' transfer a module over SFTP '''
       in_path = os.path.expanduser(
           os.path.join(self.module_path, self.module_name)
       )
       out_path = os.path.join(
           ""/var/spool/"", 
           ""ansible_%s"" % self.module_name
       )
       sftp = conn.open_sftp()
       sftp.put(in_path, out_path)
       sftp.close()
       return out_path

   def run(self):
       ''' xfer & run module on all matched hosts '''
       hosts = [ h for h in self.host_list if self._matches(h) ]
       def executor(x):
           return self._executor(x)
       results = Pooler.parmap(executor, hosts)
       results2 = {
          ""successful"" : {},
          ""failed""     : {}
       }
       for x in results:
           (host, is_ok, result) = x
           if not is_ok:
               results2[""failed""][host] = result
           else:
               results2[""successful""][host] = result
       return results2


if __name__ == '__main__':

    # test code...

    r = Runner(
       host_list = DEFAULT_HOST_LIST,
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
from itertools import izip
import os
import json
import traceback
import select

# non-core 
import paramiko

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 60
DEFAULT_REMOTE_USER    = 'root'

def _executor_hook(x):
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

   def __init__(self, 
       host_list=DEFAULT_HOST_LIST, 
       module_path=DEFAULT_MODULE_PATH,
       module_name=DEFAULT_MODULE_NAME, 
       module_args=DEFAULT_MODULE_ARGS, 
       forks=DEFAULT_FORKS, 
       timeout=DEFAULT_TIMEOUT, 
       pattern=DEFAULT_PATTERN,
       remote_user=DEFAULT_REMOTE_USER,
       verbose=False):
      

       '''
       Constructor.
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose
       self.remote_user = remote_user

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ''' obtains a paramiko connection to the host '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username=self.remote_user,
              allow_agent=True, look_for_keys=True)
          return [ True, ssh ]
       except:
          return [ False, traceback.format_exc() ]

   def _executor(self, host):
       ''' callback executed in parallel for each host '''
       # TODO: try/catch returning none

       ok, conn = self._connect(host)
       if not ok:
           return [ host, False, conn ]

       if self.module_name != ""copy"":
           # transfer a module, set it executable, and run it
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           conn.close()
           return [ host, True, json.loads(result) ]
       else:
           # SFTP file copy module is not really a module
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           conn.close()
           return [ host, True, 1 ]
           

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = ""\n"".join(stdout.readlines())
       return results

   def _copy_module(self, conn):
       ''' transfer a module over SFTP '''
       in_path = os.path.expanduser(
           os.path.join(self.module_path, self.module_name)
       )
       out_path = os.path.join(
           ""/var/spool/"", 
           ""ansible_%s"" % self.module_name
       )
       sftp = conn.open_sftp()
       sftp.put(in_path, out_path)
       sftp.close()
       return out_path

   def run(self):
       ''' xfer & run module on all matched hosts '''
       hosts = [ h for h in self.host_list if self._matches(h) ]
       pool = multiprocessing.Pool(self.forks)
       hosts = [ (self,x) for x in hosts ]
       results = pool.map(_executor_hook, hosts)
       results2 = {
          ""successful"" : {},
          ""failed""     : {}
       }
       for x in results:
           (host, is_ok, result) = x
           if not is_ok:
               results2[""failed""][host] = result
           else:
               results2[""successful""][host] = result
       return results2


if __name__ == '__main__':

    # test code...

    r = Runner(
       host_list = DEFAULT_HOST_LIST,
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","@@ -20,7 +20,7 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import fnmatch
-from multiprocessing import Process, Pipe
+import multiprocessing
 from itertools import izip
 import os
 import json
@@ -39,24 +39,9 @@ DEFAULT_MODULE_ARGS    = ''
 DEFAULT_TIMEOUT        = 60
 DEFAULT_REMOTE_USER    = 'root'
 
-class Pooler(object):
-
-    # credit: http://stackoverflow.com/questions/3288595/multiprocessing-using-pool-map-on-a-function-defined-in-a-class
-
-    @classmethod
-    def spawn(cls, f):
-        def fun(pipe,x):
-            pipe.send(f(x))
-            pipe.close()
-        return fun
-
-    @classmethod
-    def parmap(cls, f, X):
-        pipe=[Pipe() for x in X]
-        proc=[Process(target=cls.spawn(f),args=(c,x)) for x,(p,c) in izip(X,pipe)]
-        [p.start() for p in proc]
-        [p.join() for p in proc]
-        return [p.recv() for (p,c) in pipe]
+def _executor_hook(x):
+    (runner, host) = x
+    return runner._executor(host)
 
 class Runner(object):
 
@@ -166,9 +151,9 @@ class Runner(object):
    def run(self):
        ''' xfer & run module on all matched hosts '''
        hosts = [ h for h in self.host_list if self._matches(h) ]
-       def executor(x):
-           return self._executor(x)
-       results = Pooler.parmap(executor, hosts)
+       pool = multiprocessing.Pool(self.forks)
+       hosts = [ (self,x) for x in hosts ]
+       results = pool.map(_executor_hook, hosts)
        results2 = {
           ""successful"" : {},
           ""failed""     : {}
",logic-fix,logic-fix: Modify __init__.py: +7/-22 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998366832733154,0.9082747414821548,Minor,Minor,YES
bd37864242907f780162e7af87506a5f450579bc,Comments and fixup on the dark/contacted code,lib/ansible/__init__.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback

# non-core 
import paramiko

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 60
DEFAULT_REMOTE_USER    = 'root'

def _executor_hook(x):
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

   def __init__(self, 
       host_list=DEFAULT_HOST_LIST, 
       module_path=DEFAULT_MODULE_PATH,
       module_name=DEFAULT_MODULE_NAME, 
       module_args=DEFAULT_MODULE_ARGS, 
       forks=DEFAULT_FORKS, 
       timeout=DEFAULT_TIMEOUT, 
       pattern=DEFAULT_PATTERN,
       remote_user=DEFAULT_REMOTE_USER,
       verbose=False):
      

       '''
       Constructor.
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose
       self.remote_user = remote_user

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ''' obtains a paramiko connection to the host '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username=self.remote_user,
              allow_agent=True, look_for_keys=True)
          return [ True, ssh ]
       except:
          return [ False, traceback.format_exc() ]

   def _executor(self, host):
       ''' callback executed in parallel for each host '''
       # TODO: try/catch returning none

       ok, conn = self._connect(host)
       if not ok:
           return [ host, False, conn ]

       if self.module_name != ""copy"":
           # transfer a module, set it executable, and run it
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           conn.close()
           return [ host, True, json.loads(result) ]
       else:
           # SFTP file copy module is not really a module
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           conn.close()
           return [ host, True, 1 ]
           

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = ""\n"".join(stdout.readlines())
       return results

   def _copy_module(self, conn):
       ''' transfer a module over SFTP '''
       in_path = os.path.expanduser(
           os.path.join(self.module_path, self.module_name)
       )
       out_path = os.path.join(
           ""/var/spool/"", 
           ""ansible_%s"" % self.module_name
       )
       sftp = conn.open_sftp()
       sftp.put(in_path, out_path)
       sftp.close()
       return out_path

   def run(self):
       ''' xfer & run module on all matched hosts '''
       hosts = [ h for h in self.host_list if self._matches(h) ]
       pool = multiprocessing.Pool(self.forks)
       hosts = [ (self,x) for x in hosts ]
       results = pool.map(_executor_hook, hosts)
       results2 = {
          ""contacted"" : {},
          ""dark""      : {}
       }
       for x in results:
           (host, is_ok, result) = x
           if not is_ok:
               results2[""failed""][host] = result
           else:
               results2[""successful""][host] = result
       return results2


if __name__ == '__main__':

    # test code...

    r = Runner(
       host_list = DEFAULT_HOST_LIST,
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback

# non-core 
import paramiko

DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'ping'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 3
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 60
DEFAULT_REMOTE_USER    = 'root'

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

   def __init__(self, 
       host_list=DEFAULT_HOST_LIST, 
       module_path=DEFAULT_MODULE_PATH,
       module_name=DEFAULT_MODULE_NAME, 
       module_args=DEFAULT_MODULE_ARGS, 
       forks=DEFAULT_FORKS, 
       timeout=DEFAULT_TIMEOUT, 
       pattern=DEFAULT_PATTERN,
       remote_user=DEFAULT_REMOTE_USER,
       verbose=False):
      

       '''
       Constructor.
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose
       self.remote_user = remote_user

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if fnmatch.fnmatch(host_name, self.pattern):
           return True
       return False

   def _connect(self, host):
       ''' 
       obtains a paramiko connection to the host.
       on success, returns (True, connection) 
       on failure, returns (False, traceback str)
       '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username=self.remote_user,
              allow_agent=True, look_for_keys=True)
          return [ True, ssh ]
       except:
          return [ False, traceback.format_exc() ]

   def _executor(self, host):
       ''' 
       callback executed in parallel for each host.
       returns (hostname, connected_ok, extra)
       where extra is the result of a successful connect
       or a traceback string
       '''
       # TODO: try/catch around JSON handling

       ok, conn = self._connect(host)
       if not ok:
           return [ host, False, conn ]

       if self.module_name != ""copy"":
           # transfer a module, set it executable, and run it
           outpath = self._copy_module(conn)
           self._exec_command(conn, ""chmod +x %s"" % outpath)
           cmd = self._command(outpath)
           result = self._exec_command(conn, cmd)
           conn.close()
           return [ host, True, json.loads(result) ]
       else:
           # SFTP file copy module is not really a module
           ftp = conn.open_sftp()
           ftp.put(self.module_args[0], self.module_args[1])
           ftp.close()
           conn.close()
           return [ host, True, 1 ]
           

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = ""\n"".join(stdout.readlines())
       return results

   def _copy_module(self, conn):
       ''' transfer a module over SFTP '''
       in_path = os.path.expanduser(
           os.path.join(self.module_path, self.module_name)
       )
       out_path = os.path.join(
           ""/var/spool/"", 
           ""ansible_%s"" % self.module_name
       )
       sftp = conn.open_sftp()
       sftp.put(in_path, out_path)
       sftp.close()
       return out_path

   def run(self):
       ''' xfer & run module on all matched hosts '''

       # find hosts that match the pattern
       hosts = [ h for h in self.host_list if self._matches(h) ]

       # attack pool of hosts in N forks
       pool = multiprocessing.Pool(self.forks)
       hosts = [ (self,x) for x in hosts ]
       results = pool.map(_executor_hook, hosts)

       # sort hosts by ones we successfully contacted
       # and ones we did not
       results2 = {
          ""contacted"" : {},
          ""dark""      : {}
       }
       for x in results:
           (host, is_ok, result) = x
           if not is_ok:
               results2[""dark""][host] = result
           else:
               results2[""contacted""][host] = result

       return results2


if __name__ == '__main__':

    # test code...

    r = Runner(
       host_list = DEFAULT_HOST_LIST,
       module_name='ping',
       module_args='',
       pattern='*',
       forks=3
    )   
    print r.run()

 

","@@ -38,6 +38,7 @@ DEFAULT_TIMEOUT        = 60
 DEFAULT_REMOTE_USER    = 'root'
 
 def _executor_hook(x):
+    ''' callback used by multiprocessing pool '''
     (runner, host) = x
     return runner._executor(host)
 
@@ -86,7 +87,11 @@ class Runner(object):
        return False
 
    def _connect(self, host):
-       ''' obtains a paramiko connection to the host '''
+       ''' 
+       obtains a paramiko connection to the host.
+       on success, returns (True, connection) 
+       on failure, returns (False, traceback str)
+       '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
@@ -97,8 +102,13 @@ class Runner(object):
           return [ False, traceback.format_exc() ]
 
    def _executor(self, host):
-       ''' callback executed in parallel for each host '''
-       # TODO: try/catch returning none
+       ''' 
+       callback executed in parallel for each host.
+       returns (hostname, connected_ok, extra)
+       where extra is the result of a successful connect
+       or a traceback string
+       '''
+       # TODO: try/catch around JSON handling
 
        ok, conn = self._connect(host)
        if not ok:
@@ -148,10 +158,17 @@ class Runner(object):
 
    def run(self):
        ''' xfer & run module on all matched hosts '''
+
+       # find hosts that match the pattern
        hosts = [ h for h in self.host_list if self._matches(h) ]
+
+       # attack pool of hosts in N forks
        pool = multiprocessing.Pool(self.forks)
        hosts = [ (self,x) for x in hosts ]
        results = pool.map(_executor_hook, hosts)
+
+       # sort hosts by ones we successfully contacted
+       # and ones we did not
        results2 = {
           ""contacted"" : {},
           ""dark""      : {}
@@ -159,9 +176,10 @@ class Runner(object):
        for x in results:
            (host, is_ok, result) = x
            if not is_ok:
-               results2[""failed""][host] = result
+               results2[""dark""][host] = result
            else:
-               results2[""successful""][host] = result
+               results2[""contacted""][host] = result
+
        return results2
 
 
",logic-fix,logic-fix: Modify __init__.py: +23/-5 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998941421508788,0.8756736479692854,Minor,Minor,YES
2fc109b47a1018e2b50c2a7151d41d38a26dbefd,Credit Tim for last patch.,AUTHORS.md,"Patches and Contributions 
=========================

   * Michael DeHaan - michael.dehaan AT gmail DOT com
   * Jeremy Katz - katzj AT fedoraproject DOT org
   * Seth Vidal - skvidal AT fedoraproject DOT org

Send in a github pull request to get your name here.

Upstream: github.com/mpdehaan/ansible

","Patches and Contributions 
=========================

   * Michael DeHaan - michael.dehaan AT gmail DOT com
   * Jeremy Katz - katzj AT fedoraproject DOT org
   * Seth Vidal - skvidal AT fedoraproject DOT org
   * Tim Bielawa - tbielawa AT gmail DOT com

Send in a github pull request to get your name here.

Upstream: github.com/mpdehaan/ansible

","@@ -4,6 +4,7 @@ Patches and Contributions
    * Michael DeHaan - michael.dehaan AT gmail DOT com
    * Jeremy Katz - katzj AT fedoraproject DOT org
    * Seth Vidal - skvidal AT fedoraproject DOT org
+   * Tim Bielawa - tbielawa AT gmail DOT com
 
 Send in a github pull request to get your name here.
 
",doc-fix,Credit Tim for last patch.,0.0,0.0,0,0,0,0,0.0,0,0,0.9986509680747986,0.7951179177912666,Minor,Minor,YES
43f7dee2471d90e155bd8e0024855b6768e778c7,"Added rough sketch of what I want for playbook support.  Debug heavy at the moment
as I figure out how logging/output might look.  A couple of major TODO features
also listed in the file.",bin/ansible,"#!/usr/bin/python

# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from optparse import OptionParser
import json
import os
import getpass
import ansible.runner
import ansible.playbook
import ansible.constants as C

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser()
        parser.add_option(""-P"", ""--askpass"", default=False, action=""store_true"",
            help=""ask the user to input the ssh password for connecting"")
        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
            help=""path to hosts list"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-L"", ""--library"", dest=""module_path"",
            help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-f"", ""--forks"", dest=""forks"", type=""int"",
            help=""level of parallelism"", default=C.DEFAULT_FORKS)
        parser.add_option(""-n"", ""--name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
            help=""hostname pattern"", default=C.DEFAULT_PATTERN)
        parser.add_option(""-u"", ""--remote-user"", dest=""remote_user"",
            help=""remote username"", default=C.DEFAULT_REMOTE_USER)
        parser.add_option(""-r"", ""--run-playbook"", dest=""playbook"",
            help=""playbook file, instead of -n and -a"", default=None)

        options, args = parser.parse_args()

        # TODO: more shell like splitting on module_args would
        # be a good idea

        sshpass = None
        if options.askpass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        if options.playbook is None:
            return ansible.runner.Runner(
                module_name=options.module_name,
                module_path=options.module_path,
                module_args=options.module_args.split(' '),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=False,
            )
        else:
            return ansible.playbook.PlayBook(
                module_path=options.module_path,
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                verbose=False,
            )

if __name__ == '__main__':

    result = Cli().runner().run()
    print json.dumps(result, sort_keys=True, indent=4)


","#!/usr/bin/python

# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from optparse import OptionParser
import json
import os
import getpass
import ansible.runner
import ansible.playbook
import ansible.constants as C

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser()
        parser.add_option(""-P"", ""--askpass"", default=False, action=""store_true"",
            help=""ask the user to input the ssh password for connecting"")
        parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
            help=""path to hosts list"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-L"", ""--library"", dest=""module_path"",
            help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-f"", ""--forks"", dest=""forks"", type=""int"",
            help=""level of parallelism"", default=C.DEFAULT_FORKS)
        parser.add_option(""-n"", ""--name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option(""-p"", ""--pattern"", dest=""pattern"",
            help=""hostname pattern"", default=C.DEFAULT_PATTERN)
        parser.add_option(""-u"", ""--remote-user"", dest=""remote_user"",
            help=""remote username"", default=C.DEFAULT_REMOTE_USER)
        parser.add_option(""-r"", ""--run-playbook"", dest=""playbook"",
            help=""playbook file, instead of -n and -a"", default=None)

        options, args = parser.parse_args()

        # TODO: more shell like splitting on module_args would
        # be a good idea

        sshpass = None
        if options.askpass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        if options.playbook is None:
            return ansible.runner.Runner(
                module_name=options.module_name,
                module_path=options.module_path,
                module_args=options.module_args.split(' '),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=False,
            )
        else:
            return ansible.playbook.PlayBook(
                playbook=options.playbook,
                module_path=options.module_path,
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                verbose=False,
            )

if __name__ == '__main__':

    result = Cli().runner().run()
    print json.dumps(result, sort_keys=True, indent=4)


","@@ -78,6 +78,7 @@ class Cli(object):
             )
         else:
             return ansible.playbook.PlayBook(
+                playbook=options.playbook,
                 module_path=options.module_path,
                 remote_user=options.remote_user,
                 remote_pass=sshpass,
",code-fix,code-fix: Modify ansible: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9929921499221114,Minor,Minor,YES
43f7dee2471d90e155bd8e0024855b6768e778c7,"Added rough sketch of what I want for playbook support.  Debug heavy at the moment
as I figure out how logging/output might look.  A couple of major TODO features
also listed in the file.",examples/playbook.yml,"- pattern: '*.prod.example.com'
  tasks:
  - do:
    - update apache (note: service module TBD)
    - command
    - [/usr/bin/yum, update, apache]
    onchange:
    - do:
      - restart apache (note: service module TBD)
      - command
      - [/sbin/service, apache, restart]
    - do:
      - run bin false
      - command
      - [/bin/false]

","- pattern: '*'
  tasks:
  - do:
    - update apache
    - command
    - [/usr/bin/yum, update, apache]
    onchange:
    - do:
      - restart apache
      - command
      - [/sbin/service, apache, restart]
    - do:
      - run bin false
      - command
      - [/bin/false]

","@@ -1,12 +1,12 @@
-- pattern: '*.prod.example.com'
+- pattern: '*'
   tasks:
   - do:
-    - update apache (note: service module TBD)
+    - update apache
     - command
     - [/usr/bin/yum, update, apache]
     onchange:
     - do:
-      - restart apache (note: service module TBD)
+      - restart apache
       - command
       - [/sbin/service, apache, restart]
     - do:
",config-fix,config-fix: Modify playbook.yml: +3/-3 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9969587326049804,0.6803357984559112,Minor,Major,NO
43f7dee2471d90e155bd8e0024855b6768e778c7,"Added rough sketch of what I want for playbook support.  Debug heavy at the moment
as I figure out how logging/output might look.  A couple of major TODO features
also listed in the file.",lib/ansible/playbook.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import json
import yaml

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls

        self.runner = ansible.runner.Runner(
            host_list=host_list,
            module_path=module_path,
            forks=forks,
            timeout=timeout,
            remote_user=remote_user,
            remote_pass=remote_pass,
            verbose=verbose
        )

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())

    def run(self):
        pass

#    r = Runner(
#       host_list = DEFAULT_HOST_LIST,
#       module_name='ping',
#       module_args='',
#       pattern='*',
#       forks=3
#    )   
#    print r.run()

 

","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import json
import yaml

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        return ""complete""

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        print ""GET TASK RUNNER FOR HL=%s"" % host_list

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
           host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern, task, host_list=None):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
           host_list = self.host_list

        print ""TASK=%s"" % task
        instructions = task['do']
        (comment, module_name, module_args) = instructions
        print ""running task: (%s) on hosts matching (%s)"" % (comment, pattern)
        runner = self._get_task_runner(
            pattern=pattern, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
        print ""RESULTS=%s"" % results
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])

        # TODO: filter based on values that indicate
        # they have changed events to emulate Puppet
        # 'notify' behavior, super easy -- just
        # a list comprehension -- but we need complaint
        # modules first

        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            print ""contacting %s failed -- %s"" % (host, msg)

        subtasks = task.get('onchange', [])
        if len(subtasks) > 0:
            print ""the following hosts have registered change events""
            print ok_hosts
            for subtask in subtasks:
                self._run_task(pattern, subtask, ok_hosts)

        # TODO: if a host fails in task 1, add it to an excludes
        # list such that no other tasks in the list ever execute
        # unlike Puppet, do not allow partial failure of the tree
        # and continuing as far as possible.  Fail fast.


    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern = pg['pattern']
        tasks   = pg['tasks']
        print ""PATTERN=%s"" % pattern
        print ""TASKS=%s"" % tasks
        for task in tasks:
            print ""*** RUNNING A TASK (%s)***"" % task
            self._run_task(pattern, task)



 

","@@ -30,7 +30,13 @@ import yaml
 class PlayBook(object):
     ''' 
     runs an ansible playbook, given as a datastructure
-    or YAML filename
+    or YAML filename.  a playbook is a deployment, config
+    management, or automation based set of commands to
+    run in series.
+
+    multiple patterns do not execute simultaneously,
+    but tasks in each pattern do execute in parallel
+    according to the number of forks requested.
     '''
 
     def __init__(self, 
@@ -44,31 +50,116 @@ class PlayBook(object):
         verbose=False):
 
         # runner is reused between calls
+ 
+        self.host_list   = host_list
+        self.module_path = module_path
+        self.forks       = forks
+        self.timeout     = timeout
+        self.remote_user = remote_user
+        self.remote_pass = remote_pass
+        self.verbose     = verbose
+
+        if type(playbook) == str:
+            playbook = yaml.load(file(playbook).read())
+        self.playbook = playbook
+        
+    def run(self):
+        ''' run against all patterns in the playbook '''
+
+        for pattern in self.playbook:
+            self._run_pattern(pattern)
+        return ""complete""
 
-        self.runner = ansible.runner.Runner(
+    def _get_task_runner(self, 
+        pattern=None, 
+        host_list=None,
+        module_name=None, 
+        module_args=None):
+
+        print ""GET TASK RUNNER FOR HL=%s"" % host_list
+
+        ''' 
+        return a runner suitable for running this task, using
+        preferences from the constructor 
+        '''
+
+        if host_list is None:
+           host_list = self.host_list
+
+        return ansible.runner.Runner(
+            pattern=pattern,
+            module_name=module_name,
+            module_args=module_args,
             host_list=host_list,
-            module_path=module_path,
-            forks=forks,
-            timeout=timeout,
-            remote_user=remote_user,
-            remote_pass=remote_pass,
-            verbose=verbose
+            forks=self.forks,
+            remote_user=self.remote_user,
+            remote_pass=self.remote_pass,
+            module_path=self.module_path,
+            timeout=self.timeout
         )
 
-        if type(playbook) == str:
-            playbook = yaml.load(file(playbook).read())
+    def _run_task(self, pattern, task, host_list=None):
+        ''' 
+        run a single task in the playbook and
+        recursively run any subtasks.
+        '''
+
+        if host_list is None:
+           host_list = self.host_list
+
+        print ""TASK=%s"" % task
+        instructions = task['do']
+        (comment, module_name, module_args) = instructions
+        print ""running task: (%s) on hosts matching (%s)"" % (comment, pattern)
+        runner = self._get_task_runner(
+            pattern=pattern, 
+            module_name=module_name,
+            module_args=module_args
+        )
+        results = runner.run()
+        print ""RESULTS=%s"" % results
+ 
+        dark = results.get(""dark"", [])
+        contacted = results.get(""contacted"", [])
+
+        # TODO: filter based on values that indicate
+        # they have changed events to emulate Puppet
+        # 'notify' behavior, super easy -- just
+        # a list comprehension -- but we need complaint
+        # modules first
+
+        ok_hosts = contacted.keys()
+
+        for host, msg in dark.items():
+            print ""contacting %s failed -- %s"" % (host, msg)
+
+        subtasks = task.get('onchange', [])
+        if len(subtasks) > 0:
+            print ""the following hosts have registered change events""
+            print ok_hosts
+            for subtask in subtasks:
+                self._run_task(pattern, subtask, ok_hosts)
+
+        # TODO: if a host fails in task 1, add it to an excludes
+        # list such that no other tasks in the list ever execute
+        # unlike Puppet, do not allow partial failure of the tree
+        # and continuing as far as possible.  Fail fast.
+
+
+    def _run_pattern(self, pg):
+        '''
+        run a list of tasks for a given pattern, in order
+        '''
+
+        pattern = pg['pattern']
+        tasks   = pg['tasks']
+        print ""PATTERN=%s"" % pattern
+        print ""TASKS=%s"" % tasks
+        for task in tasks:
+            print ""*** RUNNING A TASK (%s)***"" % task
+            self._run_task(pattern, task)
+
 
-    def run(self):
-        pass
-
-#    r = Runner(
-#       host_list = DEFAULT_HOST_LIST,
-#       module_name='ping',
-#       module_args='',
-#       pattern='*',
-#       forks=3
-#    )   
-#    print r.run()
 
  
 
",logic-fix,logic-fix: Modify playbook.py: +112/-21 lines,91.79354420425844,0.0,6,0,74,0,-91.79354420425844,-6,-74,0.9986579418182372,0.4092356434075415,Minor,Major,NO
4caf9d274bd5b172e42b7be4b6f90818b85755fa,Fix tbielawa email in AUTHORS file,AUTHORS.md,"Patches and Contributions 
=========================

   * Michael DeHaan - michael.dehaan AT gmail DOT com
   * Jeremy Katz - katzj AT fedoraproject DOT org
   * Seth Vidal - skvidal AT fedoraproject DOT org
   * Tim Bielawa - tbielawa AT gmail DOT com

Send in a github pull request to get your name here.

Upstream: github.com/mpdehaan/ansible

","Patches and Contributions 
=========================

   * Michael DeHaan - michael.dehaan AT gmail DOT com
   * Jeremy Katz - katzj AT fedoraproject DOT org
   * Seth Vidal - skvidal AT fedoraproject DOT org
   * Tim Bielawa - tbielawa AT redhat DOT com

Send in a github pull request to get your name here.

Upstream: github.com/mpdehaan/ansible

","@@ -4,7 +4,7 @@ Patches and Contributions
    * Michael DeHaan - michael.dehaan AT gmail DOT com
    * Jeremy Katz - katzj AT fedoraproject DOT org
    * Seth Vidal - skvidal AT fedoraproject DOT org
-   * Tim Bielawa - tbielawa AT gmail DOT com
+   * Tim Bielawa - tbielawa AT redhat DOT com
 
 Send in a github pull request to get your name here.
 
",doc-fix,doc-fix: Modify AUTHORS.md: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998078942298888,0.9506885335787996,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,lib/ansible/playbook.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import json
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
           host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
           host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
               if results.get(""rc"", 0) != 0:
                  failed=True
            elif results.get(""failed"", 0) == 1:
                  failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changes[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
               if results.get('changed', False):
                  for subtask in subtasks:
                      self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
               if not x.has_key(""run""):
                  x['run'] = []
               x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
                 ","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import json
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changes[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
","@@ -101,7 +101,7 @@ class PlayBook(object):
         '''
 
         if host_list is None:
-           host_list = self.host_list
+            host_list = self.host_list
 
         return ansible.runner.Runner(
             pattern=pattern,
@@ -122,7 +122,7 @@ class PlayBook(object):
         '''
 
         if host_list is None:
-           host_list = self.host_list
+            host_list = self.host_list
 
         instructions = task['do']
         (comment, module_details) = instructions
@@ -161,10 +161,10 @@ class PlayBook(object):
             self.processed[host] = 1
             failed = False
             if module_name == ""command"":
-               if results.get(""rc"", 0) != 0:
-                  failed=True
+                if results.get(""rc"", 0) != 0:
+                    failed=True
             elif results.get(""failed"", 0) == 1:
-                  failed=True
+                    failed=True
    
             if failed:
                 if self.verbose:
@@ -191,9 +191,9 @@ class PlayBook(object):
         subtasks = task.get('notify', [])
         if len(subtasks) > 0:
             for host, results in contacted.items():
-               if results.get('changed', False):
-                  for subtask in subtasks:
-                      self._flag_handler(handlers, subtask, host)
+                if results.get('changed', False):
+                    for subtask in subtasks:
+                         self._flag_handler(handlers, subtask, host)
 
         # TODO: if a host fails in any task, remove it from
         # the host list immediately
@@ -208,9 +208,9 @@ class PlayBook(object):
             attribs = x[""do""]
             name = attribs[0]
             if match_name == name:
-               if not x.has_key(""run""):
-                  x['run'] = []
-               x['run'].append(host)
+                if not x.has_key(""run""):
+                    x['run'] = []
+                x['run'].append(host)
 
     def _run_pattern(self, pg):
         '''
",logic-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998807907104,1.0,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,lib/ansible/runner.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

   def __init__(self, 
       host_list=C.DEFAULT_HOST_LIST, 
       module_path=C.DEFAULT_MODULE_PATH,
       module_name=C.DEFAULT_MODULE_NAME, 
       module_args=C.DEFAULT_MODULE_ARGS, 
       forks=C.DEFAULT_FORKS, 
       timeout=C.DEFAULT_TIMEOUT, 
       pattern=C.DEFAULT_PATTERN,
       remote_user=C.DEFAULT_REMOTE_USER,
       remote_pass=C.DEFAULT_REMOTE_PASS,
       verbose=False):
    
       ''' 
       Constructor
       host_list   -- file on disk listing hosts to manage, or an array of hostnames
       pattern ------ a fnmatch pattern selecting some of the hosts in host_list
       module_path -- location of ansible library on disk
       module_name -- which module to run
       module_args -- arguments to pass to module
       forks -------- how parallel should we be? 1 is extra debuggable.
       remote_user -- who to login as (default root)
       remote_pass -- provide only if you don't want to use keys or ssh-agent
       '''

       self.host_list   = self._parse_hosts(host_list)
       self.module_path = module_path
       self.module_name = module_name
       self.forks       = forks
       self.pattern     = pattern
       self.module_args = module_args
       self.timeout     = timeout
       self.verbose     = verbose
       self.remote_user = remote_user
       self.remote_pass = remote_pass

   def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


   def _matches(self, host_name, pattern=None):
       ''' returns if a hostname is matched by the pattern '''
       if host_name == '':
           return False
       if not pattern:
           pattern = self.pattern
       if fnmatch.fnmatch(host_name, pattern):
           return True
       return False

   def _connect(self, host):
       ''' 
       obtains a paramiko connection to the host.
       on success, returns (True, connection) 
       on failure, returns (False, traceback str)
       '''
       ssh = paramiko.SSHClient()
       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
       try:
          ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
          return [ True, ssh ]
       except:
          return [ False, traceback.format_exc() ]

   def _return_from_module(self, conn, host, result):
       conn.close()
       try:
           return [ host, True, json.loads(result) ]
       except:
           return [ host, False, result ]

   def _delete_remote_files(self, conn, files):
       for filename in files:
           self._exec_command(conn, ""rm -f %s"" % filename)

   def _transfer_file(self, conn, source, dest):
       self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
       ftp = conn.open_sftp()
       ftp.put(source, dest)
       ftp.close()

   def _transfer_module(self, conn):
       outpath = self._copy_module(conn)
       self._exec_command(conn, ""chmod +x %s"" % outpath)
       return outpath

   def _execute_module(self, conn, outpath):
       cmd = self._command(outpath)
       result = self._exec_command(conn, cmd)
       self._delete_remote_files(conn, [ outpath ])
       return result

   def _execute_normal_module(self, conn, host):
       ''' transfer a module, set it executable, and run it '''

       module = self._transfer_module(conn)
       result = self._execute_module(conn, module)
       return self._return_from_module(conn, host, result)

   def _execute_copy(self, conn, host):
       ''' handler for file transfer operations '''

       # transfer the file to a remote tmp location
       source = self.module_args[0]
       dest   = self.module_args[1]
       tmp_dest = self._get_tmp_path(conn, dest.split(""/"")[-1])
       self._transfer_file(conn, source, tmp_dest)

       # install the copy  module
       self.module_name = 'copy'
       module = self._transfer_module(conn)

       # run the copy module
       self.module_args = [ tmp_dest, dest ]
       result = self._execute_module(conn, module)
       self._delete_remote_files(conn, tmp_dest)
       return self._return_from_module(conn, host, result)

   def _execute_template(self, conn, host):
       ''' handler for template operations '''

       source   = self.module_args[0]
       dest     = self.module_args[1]
       metadata = '/etc/ansible/setup'

       # first copy the source template over
       tempname = os.path.split(source)[-1]
       temppath = self._get_tmp_path(conn, tempname)
       self._transfer_file(conn, source, temppath)

       # install the template module
       self.module_name = 'template'
       module = self._transfer_module(conn)

       # run the template module
       self.module_args = [ temppath, dest, metadata ]
       result = self._execute_module(conn, module)
       self._delete_remote_files(conn, [ temppath ])
       return self._return_from_module(conn, host, result)


   def _executor(self, host):
       ''' 
       callback executed in parallel for each host.
       returns (hostname, connected_ok, extra)
       where extra is the result of a successful connect
       or a traceback string
       '''

       ok, conn = self._connect(host)
       if not ok:
           return [ host, False, conn ]
       if self.module_name not in [ 'copy', 'template' ]:
           return self._execute_normal_module(conn, host)
       elif self.module_name == 'copy':
           return self._execute_copy(conn, host)
       elif self.module_name == 'template':
           return self._execute_template(conn, host)
       else:
           raise Exception(""???"")

   def _command(self, outpath):
       ''' form up a command string '''
       cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
       return cmd

   
   def remote_log(self, conn, msg):
       stdin, stdout, stderr = conn.exec_command('/usr/bin/logger -t ansible -p auth.info %r' % msg)

   def _exec_command(self, conn, cmd):
       ''' execute a command over SSH '''
       msg = '%s: %s' % (self.module_name, cmd)
       self.remote_log(conn, msg)
       stdin, stdout, stderr = conn.exec_command(cmd)
       results = ""\n"".join(stdout.readlines())
       return results

   def _get_tmp_path(self, conn, file_name):
       output = self._exec_command(conn, ""mktemp /tmp/%s.XXXXXX"" % file_name)
       return output.split(""\n"")[0]

   def _copy_module(self, conn):
       '''","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        if host_name == '':
            return False
        if not pattern:
            pattern = self.pattern
        if fnmatch.fnmatch(host_name, pattern):
            return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except:
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        conn.close()
        try:
            return [ host, True, json.loads(result) ]
        except:
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        ftp = conn.open_sftp()
        ftp.put(source, dest)
        ftp.close()

    def _transfer_module(self, conn):
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' transfer a module, set it executable, and run it '''

        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # transfer the file to a remote tmp location
        source = self.module_args[0]
        dest   = self.module_args[1]
        tmp_dest = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_dest)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ tmp_dest, dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_dest)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        source   = self.module_args[0]
        dest     = self.module_args[1]
        metadata = '/etc/ansible/setup'

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ temppath, dest, metadata ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, [ temppath ])
        return self._return_from_module(conn, host, result)


    def _executor(self, host):
        ''' 
        callback executed in parallel for each host.
        returns (hostname, connected_ok, extra)
        where extra is the result of a successful connect
        or a traceback string
        '''

        ok, conn = self._connect(host)
        if not ok:
            return [ host, False, conn ]
        if self.module_name not in [ 'copy', 'template' ]:
            return self._execute_normal_module(conn, host)
        elif self.module_name == 'copy':
            return self._execute_copy(conn, host)
        elif self.module_name == 'template':
            return self._execute_template(conn, host)
        else:
            raise Exception(""???"")

    def _command(self, outpath):
        ''' form up a command string '''
        cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
        return cmd

   
    def remote_log(self, conn, msg):
        stdin, stdout, stderr = conn.exec_command('/usr/bin/logger -t ansible -p auth.info %r' % msg)

    def _exec_command(self, conn, cmd):
        ''' execute a command over SSH '''
        msg = '%s: %s' % (self.module_name, cmd)
        self.remote_log(conn, msg)
        stdin, stdout, stderr = conn.exec_command(cmd)
        results = ""\n"".join(stdout.readlines())
        return results

    def _get_tmp_path(self, conn, file_name):
        ","@@ -34,42 +34,42 @@ def _executor_hook(x):
 
 class Runner(object):
 
-   def __init__(self, 
-       host_list=C.DEFAULT_HOST_LIST, 
-       module_path=C.DEFAULT_MODULE_PATH,
-       module_name=C.DEFAULT_MODULE_NAME, 
-       module_args=C.DEFAULT_MODULE_ARGS, 
-       forks=C.DEFAULT_FORKS, 
-       timeout=C.DEFAULT_TIMEOUT, 
-       pattern=C.DEFAULT_PATTERN,
-       remote_user=C.DEFAULT_REMOTE_USER,
-       remote_pass=C.DEFAULT_REMOTE_PASS,
-       verbose=False):
+    def __init__(self, 
+        host_list=C.DEFAULT_HOST_LIST, 
+        module_path=C.DEFAULT_MODULE_PATH,
+        module_name=C.DEFAULT_MODULE_NAME, 
+        module_args=C.DEFAULT_MODULE_ARGS, 
+        forks=C.DEFAULT_FORKS, 
+        timeout=C.DEFAULT_TIMEOUT, 
+        pattern=C.DEFAULT_PATTERN,
+        remote_user=C.DEFAULT_REMOTE_USER,
+        remote_pass=C.DEFAULT_REMOTE_PASS,
+        verbose=False):
     
-       ''' 
-       Constructor
-       host_list   -- file on disk listing hosts to manage, or an array of hostnames
-       pattern ------ a fnmatch pattern selecting some of the hosts in host_list
-       module_path -- location of ansible library on disk
-       module_name -- which module to run
-       module_args -- arguments to pass to module
-       forks -------- how parallel should we be? 1 is extra debuggable.
-       remote_user -- who to login as (default root)
-       remote_pass -- provide only if you don't want to use keys or ssh-agent
-       '''
-
-       self.host_list   = self._parse_hosts(host_list)
-       self.module_path = module_path
-       self.module_name = module_name
-       self.forks       = forks
-       self.pattern     = pattern
-       self.module_args = module_args
-       self.timeout     = timeout
-       self.verbose     = verbose
-       self.remote_user = remote_user
-       self.remote_pass = remote_pass
-
-   def _parse_hosts(self, host_list):
+        ''' 
+        Constructor
+        host_list   -- file on disk listing hosts to manage, or an array of hostnames
+        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
+        module_path -- location of ansible library on disk
+        module_name -- which module to run
+        module_args -- arguments to pass to module
+        forks -------- how parallel should we be? 1 is extra debuggable.
+        remote_user -- who to login as (default root)
+        remote_pass -- provide only if you don't want to use keys or ssh-agent
+        '''
+
+        self.host_list   = self._parse_hosts(host_list)
+        self.module_path = module_path
+        self.module_name = module_name
+        self.forks       = forks
+        self.pattern     = pattern
+        self.module_args = module_args
+        self.timeout     = timeout
+        self.verbose     = verbose
+        self.remote_user = remote_user
+        self.remote_pass = remote_pass
+
+    def _parse_hosts(self, host_list):
         ''' parse the host inventory file if not sent as an array '''
         if type(host_list) != list:
             host_list = os.path.expanduser(host_list)
@@ -77,193 +77,193 @@ class Runner(object):
         return host_list
 
 
-   def _matches(self, host_name, pattern=None):
-       ''' returns if a hostname is matched by the pattern '''
-       if host_name == '':
-           return False
-       if not pattern:
-           pattern = self.pattern
-       if fnmatch.fnmatch(host_name, pattern):
-           return True
-       return False
-
-   def _connect(self, host):
-       ''' 
-       obtains a paramiko connection to the host.
-       on success, returns (True, connection) 
-       on failure, returns (False, traceback str)
-       '''
-       ssh = paramiko.SSHClient()
-       ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
-       try:
-          ssh.connect(host, username=self.remote_user, allow_agent=True, 
+    def _matches(self, host_name, pattern=None):
+        ''' returns if a hostname is matched by the pattern '''
+        if host_name == '':
+            return False
+        if not pattern:
+            pattern = self.pattern
+        if fnmatch.fnmatch(host_name, pattern):
+            return True
+        return False
+
+    def _connect(self, host):
+        ''' 
+        obtains a paramiko connection to the host.
+        on success, returns (True, connection) 
+        on failure, returns (False, traceback str)
+        '''
+        ssh = paramiko.SSHClient()
+        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
+        try:
+            ssh.connect(host, username=self.remote_user, allow_agent=True, 
               look_for_keys=True, password=self.remote_pass)
-          return [ True, ssh ]
-       except:
-          return [ False, traceback.format_exc() ]
-
-   def _return_from_module(self, conn, host, result):
-       conn.close()
-       try:
-           return [ host, True, json.loads(result) ]
-       except:
-           return [ host, False, result ]
-
-   def _delete_remote_files(self, conn, files):
-       for filename in files:
-           self._exec_command(conn, ""rm -f %s"" % filename)
-
-   def _transfer_file(self, conn, source, dest):
-       self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
-       ftp = conn.open_sftp()
-       ftp.put(source, dest)
-       ftp.close()
-
-   def _transfer_module(self, conn):
-       outpath = self._copy_module(conn)
-       self._exec_command(conn, ""chmod +x %s"" % outpath)
-       return outpath
-
-   def _execute_module(self, conn, outpath):
-       cmd = self._command(outpath)
-       result = self._exec_command(conn, cmd)
-       self._delete_remote_files(conn, [ outpath ])
-       return result
-
-   def _execute_normal_module(self, conn, host):
-       ''' transfer a module, set it executable, and run it '''
-
-       module = self._transfer_module(conn)
-       result = self._execute_module(conn, module)
-       return self._return_from_module(conn, host, result)
-
-   def _execute_copy(self, conn, host):
-       ''' handler for file transfer operations '''
-
-       # transfer the file to a remote tmp location
-       source = self.module_args[0]
-       dest   = self.module_args[1]
-       tmp_dest = self._get_tmp_path(conn, dest.split(""/"")[-1])
-       self._transfer_file(conn, source, tmp_dest)
-
-       # install the copy  module
-       self.module_name = 'copy'
-       module = self._transfer_module(conn)
-
-       # run the copy module
-       self.module_args = [ tmp_dest, dest ]
-       result = self._execute_module(conn, module)
-       self._delete_remote_files(conn, tmp_dest)
-       return self._return_from_module(conn, host, result)
-
-   def _execute_template(self, conn, host):
-       ''' handler for template operations '''
-
-       source   = self.module_args[0]
-       dest     = self.module_args[1]
-       metadata = '/etc/ansible/setup'
-
-       # first copy the source template over
-       tempname = os.path.split(source)[-1]
-       temppath = self._get_tmp_path(conn, tempname)
-       self._transfer_file(conn, source, temppath)
-
-       # install the template module
-       self.module_name = 'template'
-       module = self._transfer_module(conn)
-
-       # run the template module
-       self.module_args = [ temppath, dest, metadata ]
-       result = self._execute_module(conn, module)
-       self._delete_remote_files(conn, [ temppath ])
-       return self._return_from_module(conn, host, result)
-
-
-   def _executor(self, host):
-       ''' 
-       callback executed in parallel for each host.
-       returns (hostname, connected_ok, extra)
-       where extra is the result of a successful connect
-       or a traceback string
-       '''
-
-       ok, conn = self._connect(host)
-       if not ok:
-           return [ host, False, conn ]
-       if self.module_name not in [ 'copy', 'template' ]:
-           return self._execute_normal_module(conn, host)
-       elif self.module_name == 'copy':
-           return ",logic-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.9999513030052184,0.9846065822368292,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,library/command,"#!/usr/bin/python

try:
	import json
except ImportError:
	import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","@@ -1,9 +1,9 @@
 #!/usr/bin/python
 
 try:
-	import json
+    import json
 except ImportError:
-	import simplejson as json
+    import simplejson as json
 
 import subprocess
 import sys
",code-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.999518871307373,1.0,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,library/copy,"#!/usr/bin/python

import sys
import os

try:
     import json
except ImportError:
     import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
 
# raise an error if there is no source file
if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % source
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
   md5sum = os.popen(""md5sum %s"" % dest).read()

os.system(""cp %s %s"" % (source, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
   changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os

try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
 
# raise an error if there is no source file
if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % source
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read()

os.system(""cp %s %s"" % (source, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -4,9 +4,9 @@ import sys
 import os
 
 try:
-     import json
+    import json
 except ImportError:
-     import simplejson as json
+    import simplejson as json
 
 source   = sys.argv[1]
 dest     = sys.argv[2]
@@ -22,14 +22,14 @@ if not os.path.exists(source):
 md5sum = None
 changed = False
 if os.path.exists(dest):
-   md5sum = os.popen(""md5sum %s"" % dest).read()
+    md5sum = os.popen(""md5sum %s"" % dest).read()
 
 os.system(""cp %s %s"" % (source, dest))
 
 md5sum2 = os.popen(""md5sum %s"" % dest).read()
 
 if md5sum != md5sum2:
-   changed = True
+    changed = True
 
 # mission accomplished
 print json.dumps({
",code-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.9998571872711182,1.0,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,library/ohai,"#!/usr/bin/python

# requires 'ohai' to be installed

try:
   import json
except ImportError:
   import simplejson as json

import subprocess

cmd = subprocess.Popen(""/usr/bin/ohai"", stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = cmd.communicate()

# try to cleanup the JSON, for some reason facter --json doesn't need this hack
print json.dumps(json.loads(out))
","#!/usr/bin/python

# requires 'ohai' to be installed

try:
    import json
except ImportError:
    import simplejson as json

import subprocess

cmd = subprocess.Popen(""/usr/bin/ohai"", stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = cmd.communicate()

# try to cleanup the JSON, for some reason facter --json doesn't need this hack
print json.dumps(json.loads(out))
","@@ -3,9 +3,9 @@
 # requires 'ohai' to be installed
 
 try:
-   import json
+    import json
 except ImportError:
-   import simplejson as json
+    import simplejson as json
 
 import subprocess
 
",code-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.999912977218628,1.0,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,library/ping,"#!/usr/bin/python

try:
	import json
except ImportError:
	import simplejson as json

print json.dumps(1)
","#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json

print json.dumps(1)
","@@ -1,8 +1,8 @@
 #!/usr/bin/python
 
 try:
-	import json
+    import json
 except ImportError:
-	import simplejson as json
+    import simplejson as json
 
 print json.dumps(1)
",code-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.9957423210144044,1.0,Minor,Minor,YES
b44ae0af90cf920212ee49bd11a5ec83dd681c74,applying indentation patch from skvidal,library/template,"#!/usr/bin/python

import sys
import os
import jinja2
try:
     import json
except ImportError:
     import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
metadata = sys.argv[3]
 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
   md5sum = os.popen(""md5sum %s"" % dest).read()

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
   changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os
import jinja2
try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
metadata = sys.argv[3]
 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read()

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -4,9 +4,9 @@ import sys
 import os
 import jinja2
 try:
-     import json
+    import json
 except ImportError:
-     import simplejson as json
+    import simplejson as json
 
 source   = sys.argv[1]
 dest     = sys.argv[2]
@@ -45,7 +45,7 @@ source = file(source).read()
 changed = False
 md5sum = None
 if os.path.exists(dest):
-   md5sum = os.popen(""md5sum %s"" % dest).read()
+    md5sum = os.popen(""md5sum %s"" % dest).read()
 
 # call Jinja2 here and save the new template file
 template = jinja2.Template(source)
@@ -61,7 +61,7 @@ f.close()
 md5sum2 = os.popen(""md5sum %s"" % dest).read()
 
 if md5sum != md5sum2:
-   changed = True
+    changed = True
 
 # mission accomplished
 print json.dumps({
",code-fix,applying indentation patch from skvidal,0.0,0.0,0,0,0,0,0.0,0,0,0.9996678829193116,1.0,Minor,Minor,YES
d308254eaeefd86c494cc322459af131aa5428a7,"A basic service module with 'ensure' idempotence semantics.  Playbook updated to use service
module vs command module for restarting.  May be some bugs and requires the service to implement 'status' -- and probably some better error handling (i.e. return JSON with ""failed"" element if failed).

Improvements welcome.",examples/playbook.yml,"- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - do:
    - configure template & module variables
    - setup a=2 b=3 c=4
  - do:
    - copy a file
    - copy /srv/a /srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template /srv/template.j2 /srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - something that will fail
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - command /sbin/service httpd restart
    - do:
      - quack like a duck
      - command /bin/true
","- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - do:
    - configure template & module variables
    - setup a=2 b=3 c=4
  - do:
    - copy a file
    - copy /srv/a /srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template /srv/template.j2 /srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - something that will fail
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted
    - do:
      - quack like a duck
      - command /bin/true
","@@ -21,7 +21,7 @@
   handlers:
     - do:
       - restart apache
-      - command /sbin/service httpd restart
+      - service name=httpd ensure=restarted
     - do:
       - quack like a duck
       - command /bin/true
",config-fix,config-fix: Modify playbook.yml: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998252987861632,0.9369950402542914,Minor,Minor,YES
d308254eaeefd86c494cc322459af131aa5428a7,"A basic service module with 'ensure' idempotence semantics.  Playbook updated to use service
module vs command module for restarting.  May be some bugs and requires the service to implement 'status' -- and probably some better error handling (i.e. return JSON with ""failed"" element if failed).

Improvements welcome.",lib/ansible/playbook.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import json
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changes[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changes[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
            ","@@ -21,7 +21,6 @@
 
 import ansible.runner
 import ansible.constants as C
-import json
 import yaml
 import shlex
 
",code-fix,code-fix: Modify playbook.py: +0/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999538660049438,0.9965120020714362,Minor,Minor,YES
d308254eaeefd86c494cc322459af131aa5428a7,"A basic service module with 'ensure' idempotence semantics.  Playbook updated to use service
module vs command module for restarting.  May be some bugs and requires the service to implement 'status' -- and probably some better error handling (i.e. return JSON with ""failed"" element if failed).

Improvements welcome.",library/service,,"#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json
import os
import sys
import shlex
import subprocess

# ===========================================
# convert arguments of form ensure=running name=foo
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

name = params['name']
ensure = params.get('ensure','running')

# ===========================================
# get service status

status = os.popen(""/sbin/service %s status"" % name).read()

# ===========================================
# determine if we are going to change anything

running = False
if status.find(""not running"") != -1:
    running = False
elif status.find(""running"") != -1:
    running = True
elif name == 'iptables' and status.find(""ACCEPT"") != -1:
    # iptables status command output is lame
    # TODO: lookup if we can use a return code for this instead?
    running = True

changed = False
if not running and ensure == ""started"":
    changed = True
elif running and ensure == ""stopped"":
    changed = True
elif ensure == ""restarted"":
    changed = True

# ===========================================
# run change commands if we need to

def _run(cmd):
    return subprocess.call(cmd, 
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE, shell=True)


rc = 0
if changed:
    if ensure == 'started':
        rc = _run(""/sbin/service %s start"" %  name)
    elif ensure == 'stopped':
        rc = _run(""/sbin/service %s stop"" % name)
    elif ensure == 'restarted':
        rc1 = _run(""/sbin/service %s stop"" % name)
        rc2 = _run(""/sbin/service %s start"" % name)
        rc  = rc1 and rc2

if rc != 0:
    # yeah, should probably include output of failure...
    print json.dumps({
        ""failed"" : 1
    })
    sys.exit(1)

# ===============================================
# success

print json.dumps({
   ""changed"" : changed
})

","@@ -0,0 +1,86 @@
+#!/usr/bin/python
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+import os
+import sys
+import shlex
+import subprocess
+
+# ===========================================
+# convert arguments of form ensure=running name=foo
+# to a dictionary
+# FIXME: make more idiomatic
+
+args = "" "".join(sys.argv[1:])
+items = shlex.split(args)
+params = {}
+for x in items:
+    (k, v) = x.split(""="")
+    params[k] = v
+
+name = params['name']
+ensure = params.get('ensure','running')
+
+# ===========================================
+# get service status
+
+status = os.popen(""/sbin/service %s status"" % name).read()
+
+# ===========================================
+# determine if we are going to change anything
+
+running = False
+if status.find(""not running"") != -1:
+    running = False
+elif status.find(""running"") != -1:
+    running = True
+elif name == 'iptables' and status.find(""ACCEPT"") != -1:
+    # iptables status command output is lame
+    # TODO: lookup if we can use a return code for this instead?
+    running = True
+
+changed = False
+if not running and ensure == ""started"":
+    changed = True
+elif running and ensure == ""stopped"":
+    changed = True
+elif ensure == ""restarted"":
+    changed = True
+
+# ===========================================
+# run change commands if we need to
+
+def _run(cmd):
+    return subprocess.call(cmd, 
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE, shell=True)
+
+
+rc = 0
+if changed:
+    if ensure == 'started':
+        rc = _run(""/sbin/service %s start"" %  name)
+    elif ensure == 'stopped':
+        rc = _run(""/sbin/service %s stop"" % name)
+    elif ensure == 'restarted':
+        rc1 = _run(""/sbin/service %s stop"" % name)
+        rc2 = _run(""/sbin/service %s start"" % name)
+        rc  = rc1 and rc2
+
+if rc != 0:
+    # yeah, should probably include output of failure...
+    print json.dumps({
+        ""failed"" : 1
+    })
+    sys.exit(1)
+
+# ===============================================
+# success
+
+print json.dumps({
+   ""changed"" : changed
+})
+
",code-fix,code-fix: Modify service: +86/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5642555952072144,0.0,Major,Major,YES
deb71da91e8e2761482dabfee5d98198afb9884e,"trim md5sum string so it does not contain the filename

also fix a bug/typo in the reporting from playbook",lib/ansible/playbook.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changes[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
            ","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
            ","@@ -183,7 +183,7 @@ class PlayBook(object):
                     if not self.changed.has_key(host):
                         self.changed[host] = 1
                     else:
-                        self.changes[host] = self.changed[host] + 1
+                        self.changed[host] = self.changed[host] + 1
 
 
         # flag which notify handlers need to be run
",logic-fix,logic-fix: Modify playbook.py: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.996818313213151,Minor,Minor,YES
deb71da91e8e2761482dabfee5d98198afb9884e,"trim md5sum string so it does not contain the filename

also fix a bug/typo in the reporting from playbook",library/copy,"#!/usr/bin/python

import sys
import os

try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
 
# raise an error if there is no source file
if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % source
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read()

os.system(""cp %s %s"" % (source, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os

try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
 
# raise an error if there is no source file
if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % source
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

os.system(""cp %s %s"" % (source, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -22,11 +22,11 @@ if not os.path.exists(source):
 md5sum = None
 changed = False
 if os.path.exists(dest):
-    md5sum = os.popen(""md5sum %s"" % dest).read()
+    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]
 
 os.system(""cp %s %s"" % (source, dest))
 
-md5sum2 = os.popen(""md5sum %s"" % dest).read()
+md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]
 
 if md5sum != md5sum2:
     changed = True
",code-fix,code-fix: Modify copy: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9995291233062744,0.9453194398324472,Minor,Minor,YES
deb71da91e8e2761482dabfee5d98198afb9884e,"trim md5sum string so it does not contain the filename

also fix a bug/typo in the reporting from playbook",library/template,"#!/usr/bin/python

import sys
import os
import jinja2
try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
metadata = sys.argv[3]
 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read()

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read()

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os
import jinja2
try:
    import json
except ImportError:
    import simplejson as json

source   = sys.argv[1]
dest     = sys.argv[2]
metadata = sys.argv[3]
 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -45,7 +45,7 @@ source = file(source).read()
 changed = False
 md5sum = None
 if os.path.exists(dest):
-    md5sum = os.popen(""md5sum %s"" % dest).read()
+    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]
 
 # call Jinja2 here and save the new template file
 template = jinja2.Template(source)
@@ -58,7 +58,7 @@ f.close()
 # other end unless things were successful
 
 # record m5sum and return success and whether things have changed
-md5sum2 = os.popen(""md5sum %s"" % dest).read()
+md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]
 
 if md5sum != md5sum2:
     changed = True
",code-fix,code-fix: Modify template: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.99969220161438,0.9777259261726056,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",examples/playbook.yml,"- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - do:
    - configure template & module variables for future template calls
    - setup a=2 b=3 c=4
  - do:
    - copy a file from the local disk to the remote
    - copy src=/srv/a dest=/srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template src=/srv/template.j2 dest=/srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - if running as non-root whne you template, you should specify the MD file (1)
    - setup a=3 b=4 c=5 metadata=/tmp/metadata.json 
  - do:
    - if running as non-root when you template, you should specify the MD file (2)
    - template src=/srv/template.j2 dest=/srv/file2.out metadata=/tmp/metadata.json
  - do:
    - call something that will fail just to demo failure counts and such
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted
    - do:
      - quack like a duck
      - command /bin/true
","- pattern: '*'
  hosts: /etc/ansible/hosts
  tasks:
  - do:
    - restart apache for kicks
    - command /sbin/service apache restart
  - do:
    - configure template & module variables for future template calls
    - setup a=2 b=3 c=4
  - do:
    - copy a file from the local disk to the remote
    - copy src=/srv/a dest=/srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template src=/srv/template.j2 dest=/srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - if running as non-root whne you template, you should specify the MD file (1)
    - setup a=3 b=4 c=5 metadata=/tmp/metadata.json 
  - do:
    - if running as non-root when you template, you should specify the MD file (2)
    - template src=/srv/template.j2 dest=/srv/file2.out metadata=/tmp/metadata.json
  - do:
    - call something that will fail just to demo failure counts and such
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted
    - do:
      - quack like a duck
      - command /bin/true
","@@ -1,6 +1,9 @@
 - pattern: '*'
-  hosts: '/etc/ansible/hosts'
+  hosts: /etc/ansible/hosts
   tasks:
+  - do:
+    - restart apache for kicks
+    - command /sbin/service apache restart
   - do:
     - configure template & module variables for future template calls
     - setup a=2 b=3 c=4
",config-fix,config-fix: Modify playbook.yml: +4/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9992048144340516,0.9106868224360348,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",lib/ansible/playbook.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _get_task_runner(self, 
        pattern=None, 
        host_list=None,
        module_name=None, 
        module_args=None):

        ''' 
        return a runner suitable for running this task, using
        preferences from the constructor 
        '''

        if host_list is None:
            host_list = self.host_list

        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = self._get_task_runner(
            pattern=pattern,
            host_list=host_list, 
            module_name=module_name,
            module_args=module_args
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
            ","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # runner is reused between calls
 
        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # list of changes/invocations/failure counts per host
        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run against all patterns in the playbook '''

        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            host_list = self.host_list

        instructions = task['do']
        (comment, module_details) = instructions
        tokens = shlex.split(module_details)
        module_name = tokens[0]
        module_args = tokens[1:]

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (comment)
            else:
                print ""\nNOTIFIED [%s]"" % (comment)

        runner = ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_user=self.remote_user, # FIXME: read from playbook
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout
        )
        results = runner.run()
 
        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1


        # flag which notify handlers need to be run
        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

        # TODO: if a host fails in any task, remove it from
        # the host list immediately

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''
        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                if not x.has_key(""run""):
                    x['run'] = []
                x['run'].append(host)

    def _run_pattern(self, pg):
        '''
        run a list of tasks for a given pattern, in order
        '''

        pattern  = pg['pattern']
        tasks    = pg['tasks']
        handlers = pg['handlers']

        self.host_list = pg.get('hosts', '/etc/ansible/hosts')

        if self.verbose:
            print ""PLAY: [%s] from [%s] ********** "" % (pattern, self.host_list)

        for task in tasks:
            self._run_task(pattern=pattern, task=task, handlers=handlers)
        for task in handlers:
            if type(task.get(""run"", None)) == list:
                self._run_task(
                   pattern=pattern, 
                   task=task, 
                   handlers=handlers,
                   host_list=task.get('run',[]),
                   conditional=True
                )

 

","@@ -88,32 +88,6 @@ class PlayBook(object):
             } 
         return results
 
-    def _get_task_runner(self, 
-        pattern=None, 
-        host_list=None,
-        module_name=None, 
-        module_args=None):
-
-        ''' 
-        return a runner suitable for running this task, using
-        preferences from the constructor 
-        '''
-
-        if host_list is None:
-            host_list = self.host_list
-
-        return ansible.runner.Runner(
-            pattern=pattern,
-            module_name=module_name,
-            module_args=module_args,
-            host_list=host_list,
-            forks=self.forks,
-            remote_user=self.remote_user,
-            remote_pass=self.remote_pass,
-            module_path=self.module_path,
-            timeout=self.timeout
-        )
-
     def _run_task(self, pattern=None, task=None, host_list=None, handlers=None, conditional=False):
         ''' 
         run a single task in the playbook and
@@ -135,11 +109,16 @@ class PlayBook(object):
             else:
                 print ""\nNOTIFIED [%s]"" % (comment)
 
-        runner = self._get_task_runner(
+        runner = ansible.runner.Runner(
             pattern=pattern,
-            host_list=host_list, 
             module_name=module_name,
-            module_args=module_args
+            module_args=module_args,
+            host_list=host_list,
+            forks=self.forks,
+            remote_user=self.remote_user, # FIXME: read from playbook
+            remote_pass=self.remote_pass,
+            module_path=self.module_path,
+            timeout=self.timeout
         )
         results = runner.run()
  
",logic-fix,logic-fix: Modify playbook.py: +8/-29 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9499086794764464,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",lib/ansible/runner.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        if host_name == '':
            return False
        if not pattern:
            pattern = self.pattern
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except:
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        conn.close()
        try:
            return [ host, True, json.loads(result) ]
        except:
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        ftp = conn.open_sftp()
        ftp.put(source, dest)
        ftp.close()

    def _transfer_module(self, conn):
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' transfer a module, set it executable, and run it '''

        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # transfer the file to a remote tmp location
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        tmp_dest = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_dest)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ tmp_dest, dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_dest)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ temppath, dest, metadata ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, [ temppath ])
        return self._return_from_module(conn, host, result)


    def _executor(self, host):
        ''' 
        callback executed in parallel for each host.
        returns (hostname, connected_ok, extra)
        where extra is the result of a successful connect
        or a traceback string
        '''

        ok, conn = self._connect(host)
        if not ok:
            return [ host, False, conn ]
        if self.module_name not in [ 'copy', 'template' ]:
            return self._execute_normal_module(conn, host)
        elif self.module_name == 'copy':
            return self._execute_copy(conn, host)
        elif self.module_name == 'template':
            return self._execute_template(conn, host)
        else:
            raise Exception(""???"")

    def _command(self, outpath):
        ''' form up a command string '''
        cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
        return cmd

   
    def remote_log(self, conn, msg):
        stdin, stdout, stderr = conn.exec_command('/us","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")
        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        if host_name == '':
            return False
        if not pattern:
            pattern = self.pattern
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except:
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        conn.close()
        try:
            return [ host, True, json.loads(result) ]
        except:
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        ftp = conn.open_sftp()
        ftp.put(source, dest)
        ftp.close()

    def _transfer_module(self, conn):
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' transfer a module, set it executable, and run it '''

        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # transfer the file to a remote tmp location
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, [ temppath ])
        return self._return_from_module(conn, host, result)


    def _executor(self, host):
        ''' 
        callback executed in parallel for each host.
        returns (hostname, connected_ok, extra)
        where extra is the result of a successful connect
        or a traceback string
        '''

        ok, conn = self._connect(host)
        if not ok:
            return [ host, False, conn ]
        if self.module_name not in [ 'copy', 'template' ]:
            return self._execute_normal_module(conn, host)
        elif self.module_name == 'copy':
            return self._execute_copy(conn, host)
        elif self.module_name == 'template':
            return self._execute_template(conn, host)
        else:
            raise Exception(""???"")

    def _command(self, outpath):
        ''' form up a command string '''
        cmd = ""%s %s"" % (outpath, "" "".join(self.module_args))
        return cmd

   
    def remote_log(self, conn, ms","@@ -154,17 +154,17 @@ class Runner(object):
         options = self._parse_kv(self.module_args)
         source = options['src']
         dest   = options['dest']
-        tmp_dest = self._get_tmp_path(conn, dest.split(""/"")[-1])
-        self._transfer_file(conn, source, tmp_dest)
+        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
+        self._transfer_file(conn, source, tmp_src)
 
         # install the copy  module
         self.module_name = 'copy'
         module = self._transfer_module(conn)
 
         # run the copy module
-        self.module_args = [ tmp_dest, dest ]
+        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
         result = self._execute_module(conn, module)
-        self._delete_remote_files(conn, tmp_dest)
+        self._delete_remote_files(conn, tmp_src)
         return self._return_from_module(conn, host, result)
 
     def _execute_template(self, conn, host):
@@ -185,7 +185,7 @@ class Runner(object):
         module = self._transfer_module(conn)
 
         # run the template module
-        self.module_args = [ temppath, dest, metadata ]
+        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
         result = self._execute_module(conn, module)
         self._delete_remote_files(conn, [ temppath ])
         return self._return_from_module(conn, host, result)
",logic-fix,logic-fix: Modify runner.py: +5/-5 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9712352191112446,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",library/copy,"#!/usr/bin/python

import sys
import os

try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form ensure=running name=foo
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

src  = params['src']
dest = params['dest']

 
# raise an error if there is no src file
if not os.path.exists(src):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % src
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

os.system(""cp %s %s"" % (src, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os
import shlex

try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form ensure=running name=foo
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

src  = params['src']
dest = params['dest']

 
# raise an error if there is no src file
if not os.path.exists(src):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source %s failed to transfer"" % src
    })
    sys.exit(1)

md5sum = None
changed = False
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

os.system(""cp %s %s"" % (src, dest))

md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -2,6 +2,7 @@
 
 import sys
 import os
+import shlex
 
 try:
     import json
",code-fix,code-fix: Modify copy: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9994826316833496,0.9736728431640584,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",library/setup,"#!/usr/bin/python

DEFAULT_ANSIBLE_SETUP     = ""/etc/ansible/setup""

import sys
import os
import shlex

try:
    import json
except ImportError:
    import simplejson as json

# load config & template variables

input_data = sys.argv[1:]
new_options = dict([ x.split('=') for x in input_data ])
ansible_file = new_options.get('metadata', DEFAULT_ANSIBLE_SETUP)
ansible_dir = os.path.dirname(metadata)

# create the config dir if it doesn't exist

if not os.path.exists(ansible_dir):
    os.makedirs(ansible_dir)

changed = False
if not os.path.exists(ansible_file):
    changed = True
else:
    md5sum = os.popen(""md5sum %s"" % ansible_file).read()

# write the template/settings file using
# instructions from server

f = open(ansible_file, ""w+"")
reformat = json.dumps(new_options)
f.write(reformat)
f.close()

md5sum2 = os.popen(""md5sum %s"" % ansible_file).read()

if md5sum != md5sum2:
   changed = True

result = {
   ""changed"" : changed,
   ""md5sum""  : md5sum
}

print json.dumps(result)
","#!/usr/bin/python

DEFAULT_ANSIBLE_SETUP     = ""/etc/ansible/setup""

import sys
import os
import shlex

try:
    import json
except ImportError:
    import simplejson as json

# load config & template variables

input_data = sys.argv[1:]
new_options = dict([ x.split('=') for x in input_data ])
ansible_file = new_options.get('metadata', DEFAULT_ANSIBLE_SETUP)
ansible_dir = os.path.dirname(ansible_file)

# create the config dir if it doesn't exist

if not os.path.exists(ansible_dir):
    os.makedirs(ansible_dir)

changed = False
md5sum = None
if not os.path.exists(ansible_file):
    changed = True
else:
    md5sum = os.popen(""md5sum %s"" % ansible_file).read()

# write the template/settings file using
# instructions from server

f = open(ansible_file, ""w+"")
reformat = json.dumps(new_options)
f.write(reformat)
f.close()

md5sum2 = os.popen(""md5sum %s"" % ansible_file).read()

if md5sum != md5sum2:
   changed = True

result = {
   ""changed"" : changed,
   ""md5sum""  : md5sum
}

print json.dumps(result)
","@@ -16,7 +16,7 @@ except ImportError:
 input_data = sys.argv[1:]
 new_options = dict([ x.split('=') for x in input_data ])
 ansible_file = new_options.get('metadata', DEFAULT_ANSIBLE_SETUP)
-ansible_dir = os.path.dirname(metadata)
+ansible_dir = os.path.dirname(ansible_file)
 
 # create the config dir if it doesn't exist
 
@@ -24,6 +24,7 @@ if not os.path.exists(ansible_dir):
     os.makedirs(ansible_dir)
 
 changed = False
+md5sum = None
 if not os.path.exists(ansible_file):
     changed = True
 else:
",code-fix,code-fix: Modify setup: +2/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998971223831176,0.9405441894619312,Minor,Minor,YES
61d064d011b47c522d77ef736d6d67470fb0f977,"Fixed up KV munging in runner, misc fixes to copy, setup, and template modules",library/template,"#!/usr/bin/python

import sys
import os
import jinja2
try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form ensure=running name=foo
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

source  = params['src']
dest    = params['dest']
metadata = params.get('metadata', '/etc/ansible/setup') 

 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

import sys
import os
import jinja2
import shlex
try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form ensure=running name=foo
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

source  = params['src']
dest    = params['dest']
metadata = params.get('metadata', '/etc/ansible/setup') 

 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -3,6 +3,7 @@
 import sys
 import os
 import jinja2
+import shlex
 try:
     import json
 except ImportError:
",code-fix,code-fix: Modify template: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999018907546996,0.9868891056239044,Minor,Minor,YES
86bf871e0727f2777292c9be207a0534ab826aea,Fixup the naming of the docs.,Makefile,"#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.1
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1
","#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1
","@@ -2,7 +2,7 @@
 
 ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
 ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
-MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.1
+MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.5
 SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")
 
 docs: manuals
",code-fix,code-fix: Modify Makefile: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999971389770508,0.9754238144469,Minor,Minor,YES
86bf871e0727f2777292c9be207a0534ab826aea,Fixup the naming of the docs.,docs/man/man5/ansible-modules.5,"'\"" t
.\""     Title: ansible-modules
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-modules 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-modules \- stock modules shipped with ansible
.SH ""DESCRIPTION""
.sp
Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
.SH ""IDEMPOTENCE""
.sp
Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
.SH ""COMMAND""
.sp
The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
.sp
Example usage:
.sp
""/sbin/shutdown \-t now""
.sp
This module does not support change hooks\&.
.sp
Returns the return code from the program as well as timing information\&.
.sp
Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
.SH ""COPY""
.sp
The copy module takes a list of source files
.PP
\fBsrc=\fR
.RS 4
Local absolute path to a file to copy to the remote server
.RE
.PP
\fBdest=\fR
.RS 4
Remote absolute path where the file should end up
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""FACTER""
.sp
Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
.sp
Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""FILE""
.sp
Ensures the ownership and permissions of files are as desired\&.
.sp
Use copy or template first if you need to make sure a file is on the box\&.
.sp
In plan\&.
.SH ""GIT""
.sp
Deploys software from git checkouts\&.
.sp
This module is in plan\&.
.SH ""OHAI""
.sp
Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
.sp
Requires that \fIohai\fR be installed on the remote end\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""PING""
.sp
A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
.sp
This module does not support change hooks\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""SERVICE""
.sp
Controls services on remote machines\&.
.PP
\fBensure=\fR
.RS 4
Values are
\fIstarted\fR,
\fIstopped\fR, or
\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
\fIrestarted\fR
will always bounce the service
.RE
.PP
\fBname=\fR
.RS 4
The name of the service
.RE
.SH ""SETUP""
.sp
Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
.PP
\fBmetadata=\fR
.RS 4
Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.SH ""TEMPLATE""
.sp
Templates a file out to a remote server\&. Call the setup module prior to usage\&.
.PP
\fBsrc=\fR
.RS 4
path of a Jinja2 formatted template on the local server
.RE
.PP
\fBdest\fR
.RS 4
location to render the template on the remote server
.RE
.PP
\fBmetadata\fR
.RS 4
location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""USER""
.sp
This module is in plan\&.
.SH ""YUM""
.sp
This module is in plan\&.
.SH ""WRITING YOUR OWN MODULES""
.sp
To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""SEE ALSO""
.sp
ansible(1)
.sp
ansible\-playbook(1) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
",,"@@ -1,155 +0,0 @@
-'\"" t
-.\""     Title: ansible-modules
-.\""    Author: [see the ""AUTHOR"" section]
-.\"" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
-.\""      Date: 02/26/2012
-.\""    Manual: System administration commands
-.\""    Source: Ansible-modules 0.0.1
-.\""  Language: English
-.\""
-.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
-.\"" -----------------------------------------------------------------
-.\"" * set default formatting
-.\"" -----------------------------------------------------------------
-.\"" disable hyphenation
-.nh
-.\"" disable justification (adjust text to left margin only)
-.ad l
-.\"" -----------------------------------------------------------------
-.\"" * MAIN CONTENT STARTS HERE *
-.\"" -----------------------------------------------------------------
-.SH ""NAME""
-ansible-modules \- stock modules shipped with ansible
-.SH ""DESCRIPTION""
-.sp
-Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
-.SH ""IDEMPOTENCE""
-.sp
-Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
-.SH ""COMMAND""
-.sp
-The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
-.sp
-Example usage:
-.sp
-""/sbin/shutdown \-t now""
-.sp
-This module does not support change hooks\&.
-.sp
-Returns the return code from the program as well as timing information\&.
-.sp
-Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
-.SH ""COPY""
-.sp
-The copy module takes a list of source files
-.PP
-\fBsrc=\fR
-.RS 4
-Local absolute path to a file to copy to the remote server
-.RE
-.PP
-\fBdest=\fR
-.RS 4
-Remote absolute path where the file should end up
-.RE
-.sp
-This module also returns md5sum information about the resultant file\&.
-.SH ""FACTER""
-.sp
-Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
-.sp
-Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
-.sp
-This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
-.SH ""FILE""
-.sp
-Ensures the ownership and permissions of files are as desired\&.
-.sp
-Use copy or template first if you need to make sure a file is on the box\&.
-.sp
-In plan\&.
-.SH ""GIT""
-.sp
-Deploys software from git checkouts\&.
-.sp
-This module is in plan\&.
-.SH ""OHAI""
-.sp
-Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
-.sp
-Requires that \fIohai\fR be installed on the remote end\&.
-.sp
-This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
-.SH ""PING""
-.sp
-A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
-.sp
-This module does not support change hooks\&.
-.sp
-This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
-.SH ""SERVICE""
-.sp
-Controls services on remote machines\&.
-.PP
-\fBensure=\fR
-.RS 4
-Values are
-\fIstarted\fR,
-\fIstopped\fR, or
-\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
-\fIrestarted\fR
-will always bounce the service
-.RE
-.PP
-\fBname=\fR
-.RS 4
-The name of the service
-.RE
-.SH ""SETUP""
-.sp
-Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
-.PP
-\fBmetadata=\fR
-.RS 4
-Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
-\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
-.RE
-.SH ""TEMPLATE""
-.sp
-Templates a file out to a remote server\&. Call the setup module prior to usage\&.
-.PP
-\fBsrc=\fR
-.RS 4
-path of a Jinja2 formatted template on the local server
-.RE
-.PP
-\fBdest\fR
-.RS 4
-location to render the template on the remote server
-.RE
-.PP
-\fBmetadata\fR
-.RS 4
-location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
-.RE
-.sp
-This module also returns md5sum information about the resultant file\&.
-.SH ""USER""
-.sp
-This module is in plan\&.
-.SH ""YUM""
-.sp
-This module is in plan\&.
-.SH ""WRITING YOUR OWN MODULES""
-.sp
-To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
-.SH ""AUTHOR""
-.sp
-Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
-.SH ""SEE ALSO""
-.sp
-ansible(1)
-.sp
-ansible\-playbook(1) \- pending
-.sp
-Ansible home page: https://github\&.com/mpdehaan/ansible/
",code-fix,code-fix: Modify ansible-modules.5: +0/-155 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5842382907867432,0.0,Major,Major,YES
86bf871e0727f2777292c9be207a0534ab826aea,Fixup the naming of the docs.,docs/man/man5/ansible-modules.5.asciidoc,,,,unknown,unknown: Modify ansible-modules.5.asciidoc: +0/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.0,Minor,Major,NO
b4fd0042f61c9164416e7336ec3195c1d1b35e39,"Fix up some wording/formatting in ansible-modyles.5. Also: Section 5 is for configuration, update the see-also to reflect this with respect to ansible-playbook.",docs/man/man5/ansible-modules.5,,"'\"" t
.\""     Title: ansible-modules
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-modules 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-modules \- stock modules shipped with ansible
.SH ""DESCRIPTION""
.sp
Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
.SH ""IDEMPOTENCE""
.sp
Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
.SH ""COMMAND""
.sp
The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
.PP
Example usage
.RS 4
/sbin/shutdown \-t now
.RE
.sp
This module does not support change hooks\&.
.sp
Returns the return code from the program as well as timing information\&.
.sp
Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
.SH ""COPY""
.sp
The copy module takes a list of source files
.PP
\fBsrc=\fR
.RS 4
Local absolute path to a file to copy to the remote server
.RE
.PP
\fBdest=\fR
.RS 4
Remote absolute path where the file should end up
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""FACTER""
.sp
Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
.sp
Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""FILE""
.sp
Ensures the ownership and permissions of files are as desired\&.
.sp
Use copy or template first if you need to make sure a file is on the box\&.
.sp
In plan\&.
.SH ""GIT""
.sp
Deploys software from git checkouts\&.
.sp
This module is in plan\&.
.SH ""OHAI""
.sp
Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
.sp
Requires that \fIohai\fR be installed on the remote end\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""PING""
.sp
A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
.sp
This module does not support change hooks\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""SERVICE""
.sp
Controls services on remote machines\&.
.PP
\fBensure=\fR
.RS 4
Values are
\fIstarted\fR,
\fIstopped\fR, or
\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
\fIrestarted\fR
will always bounce the service
.RE
.PP
\fBname=\fR
.RS 4
The name of the service
.RE
.SH ""SETUP""
.sp
Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
.PP
\fBmetadata=\fR
.RS 4
Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.SH ""TEMPLATE""
.sp
Templates a file out to a remote server\&. Call the setup module prior to usage\&.
.PP
\fBsrc=\fR
.RS 4
path of a Jinja2 formatted template on the local server
.RE
.PP
\fBdest\fR
.RS 4
location to render the template on the remote server
.RE
.PP
\fBmetadata\fR
.RS 4
location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""USER""
.sp
This module is in plan\&.
.SH ""YUM""
.sp
This module is in plan\&.
.SH ""WRITING YOUR OWN MODULES""
.sp
To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""SEE ALSO""
.sp
ansible(1)
.sp
ansible\-playbook(5) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","@@ -0,0 +1,165 @@
+'\"" t
+.\""     Title: ansible-modules
+.\""    Author: [see the ""AUTHOR"" section]
+.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
+.\""      Date: 02/26/2012
+.\""    Manual: System administration commands
+.\""    Source: Ansible-modules 0.0.1
+.\""  Language: English
+.\""
+.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
+.\"" -----------------------------------------------------------------
+.\"" * Define some portability stuff
+.\"" -----------------------------------------------------------------
+.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+.\"" http://bugs.debian.org/507673
+.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
+.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"" -----------------------------------------------------------------
+.\"" * set default formatting
+.\"" -----------------------------------------------------------------
+.\"" disable hyphenation
+.nh
+.\"" disable justification (adjust text to left margin only)
+.ad l
+.\"" -----------------------------------------------------------------
+.\"" * MAIN CONTENT STARTS HERE *
+.\"" -----------------------------------------------------------------
+.SH ""NAME""
+ansible-modules \- stock modules shipped with ansible
+.SH ""DESCRIPTION""
+.sp
+Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
+.SH ""IDEMPOTENCE""
+.sp
+Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
+.SH ""COMMAND""
+.sp
+The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
+.PP
+Example usage
+.RS 4
+/sbin/shutdown \-t now
+.RE
+.sp
+This module does not support change hooks\&.
+.sp
+Returns the return code from the program as well as timing information\&.
+.sp
+Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
+.SH ""COPY""
+.sp
+The copy module takes a list of source files
+.PP
+\fBsrc=\fR
+.RS 4
+Local absolute path to a file to copy to the remote server
+.RE
+.PP
+\fBdest=\fR
+.RS 4
+Remote absolute path where the file should end up
+.RE
+.sp
+This module also returns md5sum information about the resultant file\&.
+.SH ""FACTER""
+.sp
+Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
+.sp
+Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
+.sp
+This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
+.SH ""FILE""
+.sp
+Ensures the ownership and permissions of files are as desired\&.
+.sp
+Use copy or template first if you need to make sure a file is on the box\&.
+.sp
+In plan\&.
+.SH ""GIT""
+.sp
+Deploys software from git checkouts\&.
+.sp
+This module is in plan\&.
+.SH ""OHAI""
+.sp
+Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
+.sp
+Requires that \fIohai\fR be installed on the remote end\&.
+.sp
+This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
+.SH ""PING""
+.sp
+A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
+.sp
+This module does not support change hooks\&.
+.sp
+This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
+.SH ""SERVICE""
+.sp
+Controls services on remote machines\&.
+.PP
+\fBensure=\fR
+.RS 4
+Values are
+\fIstarted\fR,
+\fIstopped\fR, or
+\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
+\fIrestarted\fR
+will always bounce the service
+.RE
+.PP
+\fBname=\fR
+.RS 4
+The name of the service
+.RE
+.SH ""SETUP""
+.sp
+Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
+.PP
+\fBmetadata=\fR
+.RS 4
+Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
+\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
+.RE
+.SH ""TEMPLATE""
+.sp
+Templates a file out to a remote server\&. Call the setup module prior to usage\&.
+.PP
+\fBsrc=\fR
+.RS 4
+path of a Jinja2 formatted template on the local server
+.RE
+.PP
+\fBdest\fR
+.RS 4
+location to render the template on the remote server
+.RE
+.PP
+\fBmetadata\fR
+.RS 4
+location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
+.RE
+.sp
+This module also returns md5sum information about the resultant file\&.
+.SH ""USER""
+.sp
+This module is in plan\&.
+.SH ""YUM""
+.sp
+This module is in plan\&.
+.SH ""WRITING YOUR OWN MODULES""
+.sp
+To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
+.SH ""AUTHOR""
+.sp
+Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
+.SH ""SEE ALSO""
+.sp
+ansible(1)
+.sp
+ansible\-playbook(5) \- pending
+.sp
+Ansible home page: https://github\&.com/mpdehaan/ansible/
",code-fix,code-fix: Modify ansible-modules.5: +165/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5816956162452698,0.0,Major,Major,YES
b4fd0042f61c9164416e7336ec3195c1d1b35e39,"Fix up some wording/formatting in ansible-modyles.5. Also: Section 5 is for configuration, update the see-also to reflect this with respect to ansible-playbook.",docs/man/man5/ansible-modules.5.asciidoc,"ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-modules
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-modules - stock modules shipped with ansible


DESCRIPTION
-----------

Ansible ships with a number of modules that can be executed directly on remote hosts or through
ansible playbooks.


IDEMPOTENCE
-----------

Most modules other than command are idempotent, meaning they will seek to avoid changes
unless a change needs to be made.  When using ansible playbooks, these modules can
trigger change events.  Unless otherwise noted, all modules support change hooks.


command
-------

The command module takes the command name followed by a list of arguments, space delimited.
This is the only module that does not use key=value style parameters.

Example usage:

""/sbin/shutdown -t now""

This module does not support change hooks.

Returns the return code from the program as well as timing information.

Async command running and command execution time limits are in plan.  These will probably
be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1
and ANS_ASYNC=1 or similar.

copy
----

The copy module takes a list of source files

*src=*::

Local absolute path to a file to copy to the remote server


*dest=*::

Remote absolute path where the file should end up


This module also returns md5sum information about the resultant file.


facter
------

Runs the discovery program 'facter' on the remote system, returning
JSON data that can be useful for inventory purposes.

Requires that 'facter' and 'ruby-json' be installed on the remote end.

This module is information only - it takes no parameters & does not support change hooks,
nor does it make any changes on the system.


file
----

Ensures the ownership and permissions of files are as desired.

Use copy or template first if you need to make sure a file is on the box.

In plan.


git
---

Deploys software from git checkouts.

This module is in plan.


ohai
----

Similar to the facter module, this returns JSON inventory data.  Ohai data
is a bit more verbose and nested than facter.

Requires that 'ohai' be installed on the remote end.

This module is information only - it takes no parameters & does not support change hooks,
nor does it make any changes on the system.


ping
----

A trivial test module, this module always returns the integer '1' on
successful contact.

This module does not support change hooks.

This module is information only - it takes no parameters & does not support change hooks,
nor does it make any changes on the system.


service
-------

Controls services on remote machines.

*ensure=*::

Values are 'started', 'stopped', or 'restarted'.   Started/stopped
are idempotent actions that will not run commands unless neccessary.
'restarted' will always bounce the service


*name=*::

The name of the service


setup
-----

Writes a JSON file containing key/value data, for use in templating.
Call this once before using the template modules, usually as the very
first step in your playbook. 

*metadata=*::

Optionally overrides the default JSON file location of /etc/ansible/setup.
If used, also supply the metadata parameter to 'template'.  Change if
running as a non-root remote user who does not have permissions on /etc/ansible.


template
--------

Templates a file out to a remote server.  Call the setup module prior to usage.

*src=*::

path of a Jinja2 formatted template on the local server


*dest*::

location to render the template on the remote server


*metadata*::

location of a JSON file to use to supply template data.  Default is /etc/ansible/setup
which is the same as the default for the setup module.   Change if running as a non-root
remote user who does not have permissions on /etc/ansible.


This module also returns md5sum information about the resultant file.


user
----

This module is in plan.


yum
---

This module is in plan.


WRITING YOUR OWN MODULES
------------------------

To write your own modules, simply follow the convention of those already available in
/usr/share/ansible.  Modules must return JSON but can be written in any language.
To support change hooks, modules should return hashes, with a changed: True/False
element at the top level.  Modules can also choose to indicate a failure scenario
by returning a top level 'failure' element with a True value.

AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.

SEE ALSO
--------

ansible(1)

ansible-playbook(1) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-modules
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-modules - stock modules shipped with ansible


DESCRIPTION
-----------

Ansible ships with a number of modules that can be executed directly on remote hosts or through
ansible playbooks.


IDEMPOTENCE
-----------

Most modules other than command are idempotent, meaning they will seek to avoid changes
unless a change needs to be made.  When using ansible playbooks, these modules can
trigger change events.  Unless otherwise noted, all modules support change hooks.


command
-------

The command module takes the command name followed by a list of arguments, space delimited.
This is the only module that does not use key=value style parameters.

Example usage::

/sbin/shutdown -t now

This module does not support change hooks.

Returns the return code from the program as well as timing information.

Async command running and command execution time limits are in plan.  These will probably
be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1
and ANS_ASYNC=1 or similar.

copy
----

The copy module takes a list of source files

*src=*::

Local absolute path to a file to copy to the remote server


*dest=*::

Remote absolute path where the file should end up


This module also returns md5sum information about the resultant file.


facter
------

Runs the discovery program 'facter' on the remote system, returning
JSON data that can be useful for inventory purposes.

Requires that 'facter' and 'ruby-json' be installed on the remote end.

This module is informative only - it takes no parameters & does not support change hooks,
nor does it make any changes on the system.


file
----

Ensures the ownership and permissions of files are as desired.

Use copy or template first if you need to make sure a file is on the box.

In plan.


git
---

Deploys software from git checkouts.

This module is in plan.


ohai
----

Similar to the facter module, this returns JSON inventory data.  Ohai
data is a bit more verbose and nested than facter.

Requires that 'ohai' be installed on the remote end.

This module is information only - it takes no parameters & does not
support change hooks, nor does it make any changes on the system.


ping
----

A trivial test module, this module always returns the integer '1' on
successful contact.

This module does not support change hooks.

This module is informative only - it takes no parameters & does not
support change hooks, nor does it make any changes on the system.


service
-------

Controls services on remote machines.

*ensure=*::

Values are 'started', 'stopped', or 'restarted'.   Started/stopped
are idempotent actions that will not run commands unless neccessary.
'restarted' will always bounce the service


*name=*::

The name of the service


setup
-----

Writes a JSON file containing key/value data, for use in templating.
Call this once before using the template modules, usually as the very
first step in your playbook. 

*metadata=*::

Optionally overrides the default JSON file location of /etc/ansible/setup.
If used, also supply the metadata parameter to 'template'.  Change if
running as a non-root remote user who does not have permissions on /etc/ansible.


template
--------

Templates a file out to a remote server.  Call the setup module prior to usage.

*src=*::

path of a Jinja2 formatted template on the local server


*dest*::

location to render the template on the remote server


*metadata*::

location of a JSON file to use to supply template data.  Default is /etc/ansible/setup
which is the same as the default for the setup module.   Change if running as a non-root
remote user who does not have permissions on /etc/ansible.


This module also returns md5sum information about the resultant file.


user
----

This module is in plan.


yum
---

This module is in plan.


WRITING YOUR OWN MODULES
------------------------

To write your own modules, simply follow the convention of those already available in
/usr/share/ansible.  Modules must return JSON but can be written in any language.
To support change hooks, modules should return hashes, with a changed: True/False
element at the top level.  Modules can also choose to indicate a failure scenario
by returning a top level 'failure' element with a True value.

AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.

SEE ALSO
--------

ansible(1)

ansible-playbook(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","@@ -32,9 +32,9 @@ command
 The command module takes the command name followed by a list of arguments, space delimited.
 This is the only module that does not use key=value style parameters.
 
-Example usage:
+Example usage::
 
-""/sbin/shutdown -t now""
+/sbin/shutdown -t now
 
 This module does not support change hooks.
 
@@ -70,7 +70,7 @@ JSON data that can be useful for inventory purposes.
 
 Requires that 'facter' and 'ruby-json' be installed on the remote end.
 
-This module is information only - it takes no parameters & does not support change hooks,
+This module is informative only - it takes no parameters & does not support change hooks,
 nor does it make any changes on the system.
 
 
@@ -95,13 +95,13 @@ This module is in plan.
 ohai
 ----
 
-Similar to the facter module, this returns JSON inventory data.  Ohai data
-is a bit more verbose and nested than facter.
+Similar to the facter module, this returns JSON inventory data.  Ohai
+data is a bit more verbose and nested than facter.
 
 Requires that 'ohai' be installed on the remote end.
 
-This module is information only - it takes no parameters & does not support change hooks,
-nor does it make any changes on the system.
+This module is information only - it takes no parameters & does not
+support change hooks, nor does it make any changes on the system.
 
 
 ping
@@ -112,8 +112,8 @@ successful contact.
 
 This module does not support change hooks.
 
-This module is information only - it takes no parameters & does not support change hooks,
-nor does it make any changes on the system.
+This module is informative only - it takes no parameters & does not
+support change hooks, nor does it make any changes on the system.
 
 
 service
@@ -204,6 +204,6 @@ SEE ALSO
 
 ansible(1)
 
-ansible-playbook(1) - pending
+ansible-playbook(5) - pending
 
 Ansible home page: <https://github.com/mpdehaan/ansible/>
",code-fix,code-fix: Modify ansible-modules.5.asciidoc: +10/-10 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999668598175048,0.9822459663318492,Minor,Minor,YES
cdbc2168c117835a583ce2b73c2fc09277b47364,Fix makefile manpage targets,Makefile,"#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1
","#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1
","@@ -2,7 +2,7 @@
 
 ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
 ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
-MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.1 docs/man/man5/ansible-playbook.5
+MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
 SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")
 
 docs: manuals
",code-fix,code-fix: Modify Makefile: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999964833259584,0.9754238144469,Minor,Minor,YES
66127727110532ed943724904e79c4d82bb41874,"Update man pages. Fix formatting in playbook example. Also, YAML documents by definition start with '---', so I have added this to the example and the manpage",docs/man/man1/ansible.1,"'\"" t
.\""     Title: ansible
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE"" ""1"" ""02/26/2012"" ""Ansible 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible \- run a command somewhere else
.SH ""SYNOPSIS""
.sp
ansible [\-H hosts_path] [\-L library_path] [\-f forks] [\-n module_name] [\-a [args1 [args2 \&...]]] [\-p host_pattern] [\-u remote_user]
.SH ""DESCRIPTION""
.sp
\fBAnsible\fR is an extra\-simple Python API for doing \*(Aqremote things\*(Aq over SSH\&.
.SH ""OPTIONS""
.PP
\fB\-P\fR, \fB\-\-askpass\fR
.RS 4
Ask the user to input the ssh password for connecting\&.
.RE
.PP
\fB\-H\fR, \fB\-\-host\-list\fR
.RS 4
Path to hosts list\&.
.RE
.PP
\fB\-L\fR, \fB\-\-library\fR
.RS 4
Path to module library\&.
.RE
.PP
\fB\-f\fR, \fB\-\-forks\fR
.RS 4
Level of parallelism\&. Specify as an integer\&.
.RE
.PP
\fB\-n\fR, \fB\-\-name\fR
.RS 4
Module name to execute\&.
.RE
.PP
\fB\-a\fR, \fB\-\-args\fR
.RS 4
Arguments to module\&.
.RE
.PP
\fB\-p\fR, \fB\-\-pattern\fR
.RS 4
Hostname pattern\&. Accepts shell\-like globs\&.
.RE
.PP
\fB\-r\fR, \fB\-\-run\-playbook\fR
.RS 4
Playbook file to run\&. Replaces the
\fB\-n\fR
and
\fB\-a\fR
options\&.
.RE
.PP
\fB\-u\fR, \fB\-\-remote\-user\fR
.RS 4
Remote user to connect as\&. Uses
\fIroot\fR
by default\&.
.RE
.SH ""INVENTORY""
.sp
Ansible stores the hosts it can potentially operate on in an inventory file\&. The syntax is simple: one host per line\&. Organize your hosts into multiple groups by separating them into multiple inventory files\&.
.SH ""FILES""
.sp
/etc/ansible/hosts \(em Default hosts file
.sp
/usr/share/ansible \(em Default module library
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""COPYRIGHT""
.sp
Copyright \(co 2012, Michael DeHaan
.sp
Ansible is released under the terms of the MIT license\&.
.SH ""SEE ALSO""
.sp
ansible\-modules (5)
.sp
ansible\-playbook (5)
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","'\"" t
.\""     Title: ansible
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE"" ""1"" ""02/26/2012"" ""Ansible 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible \- run a command somewhere else
.SH ""SYNOPSIS""
.sp
ansible [\-H hosts_path] [\-L library_path] [\-f forks] [\-n module_name] [\-a [args1 [args2 \&...]]] [\-p host_pattern] [\-u remote_user]
.SH ""DESCRIPTION""
.sp
\fBAnsible\fR is an extra\-simple Python API for doing \*(Aqremote things\*(Aq over SSH\&.
.SH ""OPTIONS""
.PP
\fB\-P\fR, \fB\-\-askpass\fR
.RS 4
Ask the user to input the ssh password for connecting\&.
.RE
.PP
\fB\-H\fR, \fB\-\-host\-list\fR
.RS 4
Path to hosts list\&.
.RE
.PP
\fB\-L\fR, \fB\-\-library\fR
.RS 4
Path to module library\&.
.RE
.PP
\fB\-f\fR, \fB\-\-forks\fR
.RS 4
Level of parallelism\&. Specify as an integer\&.
.RE
.PP
\fB\-n\fR, \fB\-\-name\fR
.RS 4
Module name to execute\&.
.RE
.PP
\fB\-a\fR, \fB\-\-args\fR
.RS 4
Arguments to module\&.
.RE
.PP
\fB\-p\fR, \fB\-\-pattern\fR
.RS 4
Hostname pattern\&. Accepts shell\-like globs\&.
.RE
.PP
\fB\-r\fR, \fB\-\-run\-playbook\fR
.RS 4
Playbook file to run\&. Replaces the
\fB\-n\fR
and
\fB\-a\fR
options\&.
.RE
.PP
\fB\-u\fR, \fB\-\-remote\-user\fR
.RS 4
Remote user to connect as\&. Uses
\fIroot\fR
by default\&.
.RE
.SH ""INVENTORY""
.sp
Ansible stores the hosts it can potentially operate on in an inventory file\&. The syntax is simple: one host per line\&. Organize your hosts into multiple groups by separating them into multiple inventory files\&.
.SH ""FILES""
.sp
/etc/ansible/hosts \(em Default hosts file
.sp
/usr/share/ansible \(em Default module library
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""COPYRIGHT""
.sp
Copyright \(co 2012, Michael DeHaan
.sp
Ansible is released under the terms of the MIT license\&.
.SH ""SEE ALSO""
.sp
\fBansible\-modules\fR(5), \fBansible\-playbook\fR(5)
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","@@ -105,8 +105,6 @@ Copyright \(co 2012, Michael DeHaan
 Ansible is released under the terms of the MIT license\&.
 .SH ""SEE ALSO""
 .sp
-ansible\-modules (5)
-.sp
-ansible\-playbook (5)
+\fBansible\-modules\fR(5), \fBansible\-playbook\fR(5)
 .sp
 Ansible home page: https://github\&.com/mpdehaan/ansible/
",code-fix,code-fix: Modify ansible.1: +1/-3 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9821037987069212,Minor,Minor,YES
66127727110532ed943724904e79c4d82bb41874,"Update man pages. Fix formatting in playbook example. Also, YAML documents by definition start with '---', so I have added this to the example and the manpage",docs/man/man5/ansible-modules.5,"'\"" t
.\""     Title: ansible-modules
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-modules 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-modules \- stock modules shipped with ansible
.SH ""DESCRIPTION""
.sp
Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
.SH ""IDEMPOTENCE""
.sp
Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
.SH ""COMMAND""
.sp
The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
.PP
Example usage
.RS 4
/sbin/shutdown \-t now
.RE
.sp
This module does not support change hooks\&.
.sp
Returns the return code from the program as well as timing information\&.
.sp
Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
.SH ""COPY""
.sp
The copy module takes a list of source files
.PP
\fBsrc=\fR
.RS 4
Local absolute path to a file to copy to the remote server
.RE
.PP
\fBdest=\fR
.RS 4
Remote absolute path where the file should end up
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""FACTER""
.sp
Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
.sp
Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""FILE""
.sp
Ensures the ownership and permissions of files are as desired\&.
.sp
Use copy or template first if you need to make sure a file is on the box\&.
.sp
In plan\&.
.SH ""GIT""
.sp
Deploys software from git checkouts\&.
.sp
This module is in plan\&.
.SH ""OHAI""
.sp
Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
.sp
Requires that \fIohai\fR be installed on the remote end\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""PING""
.sp
A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
.sp
This module does not support change hooks\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""SERVICE""
.sp
Controls services on remote machines\&.
.PP
\fBensure=\fR
.RS 4
Values are
\fIstarted\fR,
\fIstopped\fR, or
\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
\fIrestarted\fR
will always bounce the service
.RE
.PP
\fBname=\fR
.RS 4
The name of the service
.RE
.SH ""SETUP""
.sp
Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
.PP
\fBmetadata=\fR
.RS 4
Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.SH ""TEMPLATE""
.sp
Templates a file out to a remote server\&. Call the setup module prior to usage\&.
.PP
\fBsrc=\fR
.RS 4
path of a Jinja2 formatted template on the local server
.RE
.PP
\fBdest\fR
.RS 4
location to render the template on the remote server
.RE
.PP
\fBmetadata\fR
.RS 4
location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""USER""
.sp
This module is in plan\&.
.SH ""YUM""
.sp
This module is in plan\&.
.SH ""WRITING YOUR OWN MODULES""
.sp
To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""SEE ALSO""
.sp
ansible(1)
.sp
ansible\-playbook(5) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","'\"" t
.\""     Title: ansible-modules
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-modules 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-modules 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-modules \- stock modules shipped with ansible
.SH ""DESCRIPTION""
.sp
Ansible ships with a number of modules that can be executed directly on remote hosts or through ansible playbooks\&.
.SH ""IDEMPOTENCE""
.sp
Most modules other than command are idempotent, meaning they will seek to avoid changes unless a change needs to be made\&. When using ansible playbooks, these modules can trigger change events\&. Unless otherwise noted, all modules support change hooks\&.
.SH ""COMMAND""
.sp
The command module takes the command name followed by a list of arguments, space delimited\&. This is the only module that does not use key=value style parameters\&.
.PP
Example usage
.RS 4
/sbin/shutdown \-t now
.RE
.sp
This module does not support change hooks\&.
.sp
Returns the return code from the program as well as timing information\&.
.sp
Async command running and command execution time limits are in plan\&. These will probably be special keyvalue parameters expressed on the end of the command line, like ANSTIMEOUT=1 and ANS_ASYNC=1 or similar\&.
.SH ""COPY""
.sp
The copy module takes a list of source files
.PP
\fBsrc=\fR
.RS 4
Local absolute path to a file to copy to the remote server
.RE
.PP
\fBdest=\fR
.RS 4
Remote absolute path where the file should end up
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""FACTER""
.sp
Runs the discovery program \fIfacter\fR on the remote system, returning JSON data that can be useful for inventory purposes\&.
.sp
Requires that \fIfacter\fR and \fIruby\-json\fR be installed on the remote end\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""FILE""
.sp
Ensures the ownership and permissions of files are as desired\&.
.sp
Use copy or template first if you need to make sure a file is on the box\&.
.sp
In plan\&.
.SH ""GIT""
.sp
Deploys software from git checkouts\&.
.sp
This module is in plan\&.
.SH ""OHAI""
.sp
Similar to the facter module, this returns JSON inventory data\&. Ohai data is a bit more verbose and nested than facter\&.
.sp
Requires that \fIohai\fR be installed on the remote end\&.
.sp
This module is information only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""PING""
.sp
A trivial test module, this module always returns the integer \fI1\fR on successful contact\&.
.sp
This module does not support change hooks\&.
.sp
This module is informative only \- it takes no parameters & does not support change hooks, nor does it make any changes on the system\&.
.SH ""SERVICE""
.sp
Controls services on remote machines\&.
.PP
\fBensure=\fR
.RS 4
Values are
\fIstarted\fR,
\fIstopped\fR, or
\fIrestarted\fR\&. Started/stopped are idempotent actions that will not run commands unless neccessary\&.
\fIrestarted\fR
will always bounce the service
.RE
.PP
\fBname=\fR
.RS 4
The name of the service
.RE
.SH ""SETUP""
.sp
Writes a JSON file containing key/value data, for use in templating\&. Call this once before using the template modules, usually as the very first step in your playbook\&.
.PP
\fBmetadata=\fR
.RS 4
Optionally overrides the default JSON file location of /etc/ansible/setup\&. If used, also supply the metadata parameter to
\fItemplate\fR\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.SH ""TEMPLATE""
.sp
Templates a file out to a remote server\&. Call the setup module prior to usage\&.
.PP
\fBsrc=\fR
.RS 4
path of a Jinja2 formatted template on the local server
.RE
.PP
\fBdest\fR
.RS 4
location to render the template on the remote server
.RE
.PP
\fBmetadata\fR
.RS 4
location of a JSON file to use to supply template data\&. Default is /etc/ansible/setup which is the same as the default for the setup module\&. Change if running as a non\-root remote user who does not have permissions on /etc/ansible\&.
.RE
.sp
This module also returns md5sum information about the resultant file\&.
.SH ""USER""
.sp
This module is in plan\&.
.SH ""YUM""
.sp
This module is in plan\&.
.SH ""WRITING YOUR OWN MODULES""
.sp
To write your own modules, simply follow the convention of those already available in /usr/share/ansible\&. Modules must return JSON but can be written in any language\&. To support change hooks, modules should return hashes, with a changed: True/False element at the top level\&. Modules can also choose to indicate a failure scenario by returning a top level \fIfailure\fR element with a True value\&.
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""SEE ALSO""
.sp
\fBansible\fR(1)
.sp
\fBansible\-playbook\fR(5) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","@@ -158,8 +158,8 @@ To write your own modules, simply follow the convention of those already availab
 Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
 .SH ""SEE ALSO""
 .sp
-ansible(1)
+\fBansible\fR(1)
 .sp
-ansible\-playbook(5) \- pending
+\fBansible\-playbook\fR(5) \- pending
 .sp
 Ansible home page: https://github\&.com/mpdehaan/ansible/
",code-fix,code-fix: Modify ansible-modules.5: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9951641713167846,Minor,Minor,YES
66127727110532ed943724904e79c4d82bb41874,"Update man pages. Fix formatting in playbook example. Also, YAML documents by definition start with '---', so I have added this to the example and the manpage",docs/man/man5/ansible-playbook.5,"'\"" t
.\""     Title: ansible-modules
.\""    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\"" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-playbook 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-playbook 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-playbook \- format and function of an ansible playbook file
.SH ""DESCRIPTION""
.sp
Ansible ships with a ansible\-playbook tool for running playbooks\&. Playbooks can represent frequent tasks, desired system configurations, or deployment processes\&.
.SH ""FORMAT""
.sp
Playbooks are currently writeable in YAML\&. Other formats (JSON?) may be supported in the future\&.
.SH ""EXAMPLE""
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
pattern:
\fI*\fR
hosts:
\fI/etc/ansible/hosts\fR
tasks:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
do:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
configure template & module variables for future template calls
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
setup http_port=80 max_clients=200
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
do:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
write the apache config file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
template src=/srv/mytemplates/httpd\&.j2 dest=/etc/httpd/conf notify:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
restart apache
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
do
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ensure apache is running
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
service name=httpd ensure=started handlers:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
do:
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
restart apache
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
service name=httpd ensure=restarted
.RE
.SH ""WHAT THE EXAMPLE MEANS""
.sp
Here\(cqs what the above example will do\&.
.sp
For all hosts in /etc/ansible/hosts (one host per line) that are named \fIwebserver\-anything\fR, first write a JSON file into /etc/ansible/setup on each remote system with the values max_clients and http_port\&.
.sp
Next, use a Jinja2 template locally residing at /srv/mytemplates/httpd\&.j2 to write the Apache config file on each host to the path /etc/httpd/conf, using the previous values\&.
.sp
Ensure that apache is running if stopped\&.
.sp
If and only if the config file changed, note that we need to restart apache at the end of the run, otherwise, don\(cqt bother because we already know it is running\&.
.SH ""HIGH LEVEL EXPLANATION""
.sp
Playbooks are executed top down and can contain multiple references to patterns\&. For instance, a playbook could do something to all webservers, then do something to all database servers, then do something different to all webservers again\&.
.sp
For each pattern, the tasks in the \fItasks\fR list are executed in order for all hosts in the host file matching the pattern\&.
.sp
For each task, a ""do"" statement describes what the task is and what ansible module to use to accomplish the task, along with any arguments\&. The first line in the ""do"" is the name of the task \(em this will appear in any log output\&.
.sp
The second line in each ""do"" is the module name followed by module arguments\&.
.sp
Most modules accept key=value format arguments\&.
.sp
Handlers are like tasks, but are conditionally executed\&. If a module reports a \fIchange\fR, it can choose to notify a handler by name\&. If notified, it will run only for hosts that changed\&.
.SH ""FUTURE BEHAVIOR""
.sp
What the playbook run does with a host when an error is detected is currently being refined and is subject to change\&.
.SH ""SEE ALSO""
.sp
ansible(1)
.sp
ansible\-playbook(1) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","'\"" t
.\""     Title: ansible-modules
.\""    Author: [see the ""AUTHOR"" section]
.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\""      Date: 02/26/2012
.\""    Manual: System administration commands
.\""    Source: Ansible-playbook 0.0.1
.\""  Language: English
.\""
.TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-playbook 0\&.0\&.1"" ""System administration commands""
.\"" -----------------------------------------------------------------
.\"" * Define some portability stuff
.\"" -----------------------------------------------------------------
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\"" http://bugs.debian.org/507673
.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"" -----------------------------------------------------------------
.\"" * set default formatting
.\"" -----------------------------------------------------------------
.\"" disable hyphenation
.nh
.\"" disable justification (adjust text to left margin only)
.ad l
.\"" -----------------------------------------------------------------
.\"" * MAIN CONTENT STARTS HERE *
.\"" -----------------------------------------------------------------
.SH ""NAME""
ansible-playbook \- format and function of an ansible playbook file
.SH ""DESCRIPTION""
.sp
Ansible ships with a ansible\-playbook tool for running playbooks\&. Playbooks can represent frequent tasks, desired system configurations, or deployment processes\&.
.SH ""FORMAT""
.sp
Playbooks are currently writeable in YAML\&. Other formats (JSON?) may be supported in the future\&.
.SH ""EXAMPLE""
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-\-
\- pattern: \*(Aq*\*(Aq
  hosts: \*(Aq/etc/ansible/hosts\*(Aq
  tasks:
  \- do:
    \- configure template & module variables for future template calls
    \- setup http_port=80 max_clients=200
  \- do:
    \- write the apache config file
    \- template src=/srv/mytemplates/httpd\&.j2 dest=/etc/httpd/conf
    notify:
    \- restart apache
  \- do
    \- ensure apache is running
    \- service name=httpd ensure=started
  handlers:
    \- do:
      \- restart apache
      \- service name=httpd ensure=restarted
.fi
.if n \{\
.RE
.\}
.SH ""WHAT THE EXAMPLE MEANS""
.sp
Here\(cqs what the above example will do\&.
.sp
For all hosts in /etc/ansible/hosts (one host per line) that are named \fIwebserver\-anything\fR, first write a JSON file into /etc/ansible/setup on each remote system with the values max_clients and http_port\&.
.sp
Next, use a Jinja2 template locally residing at /srv/mytemplates/httpd\&.j2 to write the Apache config file on each host to the path /etc/httpd/conf, using the previous values\&.
.sp
Ensure that apache is running if stopped\&.
.sp
If and only if the config file changed, note that we need to restart apache at the end of the run, otherwise, don\(cqt bother because we already know it is running\&.
.SH ""HIGH LEVEL EXPLANATION""
.sp
Playbooks are executed top down and can contain multiple references to patterns\&. For instance, a playbook could do something to all webservers, then do something to all database servers, then do something different to all webservers again\&.
.sp
For each pattern, the tasks in the \fItasks\fR list are executed in order for all hosts in the host file matching the pattern\&.
.sp
For each task, a ""do"" statement describes what the task is and what ansible module to use to accomplish the task, along with any arguments\&. The first line in the ""do"" is the name of the task \(em this will appear in any log output\&.
.sp
The second line in each ""do"" is the module name followed by module arguments\&.
.sp
Most modules accept key=value format arguments\&.
.sp
Handlers are like tasks, but are conditionally executed\&. If a module reports a \fIchange\fR, it can choose to notify a handler by name\&. If notified, it will run only for hosts that changed\&.
.SH ""FUTURE BEHAVIOR""
.sp
What the playbook run does with a host when an error is detected is currently being refined and is subject to change\&.
.SH ""AUTHOR""
.sp
Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
.SH ""SEE ALSO""
.sp
\fBansible\fR(1)
.sp
\fBansible\-playbook\fR(5) \- pending
.sp
Ansible home page: https://github\&.com/mpdehaan/ansible/
","@@ -1,7 +1,7 @@
 '\"" t
 .\""     Title: ansible-modules
-.\""    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
-.\"" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
+.\""    Author: [see the ""AUTHOR"" section]
+.\"" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
 .\""      Date: 02/26/2012
 .\""    Manual: System administration commands
 .\""    Source: Ansible-playbook 0.0.1
@@ -9,6 +9,15 @@
 .\""
 .TH ""ANSIBLE\-MODULES"" ""5"" ""02/26/2012"" ""Ansible\-playbook 0\&.0\&.1"" ""System administration commands""
 .\"" -----------------------------------------------------------------
+.\"" * Define some portability stuff
+.\"" -----------------------------------------------------------------
+.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+.\"" http://bugs.debian.org/507673
+.\"" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
+.\"" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"" -----------------------------------------------------------------
 .\"" * set default formatting
 .\"" -----------------------------------------------------------------
 .\"" disable hyphenation
@@ -28,163 +37,33 @@ Ansible ships with a ansible\-playbook tool for running playbooks\&. Playbooks c
 Playbooks are currently writeable in YAML\&. Other formats (JSON?) may be supported in the future\&.
 .SH ""EXAMPLE""
 .sp
+.if n \{\
 .RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-pattern:
-\fI*\fR
-hosts:
-\fI/etc/ansible/hosts\fR
-tasks:
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-do:
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-configure template & module variables for future template calls
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-setup http_port=80 max_clients=200
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-do:
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-write the apache config file
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-template src=/srv/mytemplates/httpd\&.j2 dest=/etc/httpd/conf notify:
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-restart apache
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-do
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-ensure apache is running
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
 .\}
-service name=httpd ensure=started handlers:
+.nf
+\-\-\-
+\- pattern: \*(Aq*\*(Aq
+  hosts: \*(Aq/etc/ansible/hosts\*(Aq
+  tasks:
+  \- do:
+    \- configure template & module variables for future template calls
+    \- setup http_port=80 max_clients=200
+  \- do:
+    \- write the apache config file
+    \- template src=/srv/mytemplates/httpd\&.j2 dest=/etc/httpd/conf
+    notify:
+    \- restart apache
+  \- do
+    \- ensure apache is running
+    \- service name=httpd ensure=started
+  handlers:
+    \- do:
+      \- restart apache
+      \- service name=httpd ensure=restarted
+.fi
+.if n \{\
 .RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-do:
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
 .\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-restart apache
-.RE
-.sp
-.RS 4
-.ie n \{\
-\h'-04'\(bu\h'+03'\c
-.\}
-.el \{\
-.sp -1
-.IP \(bu 2.3
-.\}
-service name=httpd ensure=restarted
-.RE
 .SH ""WHAT THE EXAMPLE MEANS""
 .sp
 Here\(cqs what the above example will do\&.
@@ -212,10 +91,13 @@ Handlers are like tasks, but are conditionally executed\&. If a module reports a
 .SH ""FUTURE BEHAVIOR""
 .sp
 What the playbook run does with a host when an error is detected is currently being refined and is subject to change\&.
+.SH ""AUTHOR""
+.sp
+Ansible was originally written by Michael DeHaan\&. See the AUTHORS file for a complete list of contributors\&.
 .SH ""SEE ALSO""
 .sp
-ansible(1)
+\fBansible\fR(1)
 .sp
-ansible\-playbook(1) \- pending
+\fBansible\-playbook\fR(5) \- pending
 .sp
 Ansible home page: https://github\&.com/mpdehaan/ansible/
",code-fix,code-fix: Modify ansible-playbook.5: +39/-157 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9984623193740844,0.6134806958655906,Minor,Major,NO
66127727110532ed943724904e79c4d82bb41874,"Update man pages. Fix formatting in playbook example. Also, YAML documents by definition start with '---', so I have added this to the example and the manpage",docs/man/man5/ansible-playbook.5.asciidoc,"ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.  Playbooks can represent
frequent tasks, desired system configurations, or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may be supported in the future.


EXAMPLE
-------

- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - do:
    - configure template & module variables for future template calls
    - setup http_port=80 max_clients=200
  - do:
    - write the apache config file
    - template src=/srv/mytemplates/httpd.j2 dest=/etc/httpd/conf
    notify:
    - restart apache
  - do
    - ensure apache is running
    - service name=httpd ensure=started
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted


WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named 'webserver-anything', first
write a JSON file into /etc/ansible/setup on each remote system with the values
max_clients and http_port.

Next, use a Jinja2 template locally residing 
at /srv/mytemplates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd/conf, using the previous values.

Ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart apache at the end of
the run, otherwise, don't bother because we already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to patterns.
For instance, a playbook could do something to all webservers, then do something
to all database servers, then do something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order for all
hosts in the host file matching the pattern.

For each task, a ""do"" statement describes what the task is and what ansible
module to use to accomplish the task, along with any arguments.  The first
line in the ""do"" is the name of the task -- this will appear in any log output.

The second line in each ""do"" is the module name followed by module arguments.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module reports
a 'change', it can choose to notify a handler by name.  If notified, it will
run only for hosts that changed.


FUTURE BEHAVIOR
---------------

What the playbook run does with a host when an error is detected is currently being refined
and is subject to change. 


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.
Playbooks can represent frequent tasks, desired system configurations,
or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may
be supported in the future.


EXAMPLE
-------

[literal]
---
- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - do:
    - configure template & module variables for future template calls
    - setup http_port=80 max_clients=200
  - do:
    - write the apache config file
    - template src=/srv/mytemplates/httpd.j2 dest=/etc/httpd/conf
    notify:
    - restart apache
  - do
    - ensure apache is running
    - service name=httpd ensure=started
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted


WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named
'webserver-anything', first write a JSON file into /etc/ansible/setup
on each remote system with the values max_clients and http_port.

Next, use a Jinja2 template locally residing at
/srv/mytemplates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd/conf, using the previous values.

Ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart
apache at the end of the run, otherwise, don't bother because we
already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to
patterns.  For instance, a playbook could do something to all
webservers, then do something to all database servers, then do
something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order
for all hosts in the host file matching the pattern.

For each task, a ""do"" statement describes what the task is and what
ansible module to use to accomplish the task, along with any
arguments.  The first line in the ""do"" is the name of the task -- this
will appear in any log output.

The second line in each ""do"" is the module name followed by module
arguments.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module
reports a 'change', it can choose to notify a handler by name.  If
notified, it will run only for hosts that changed.


FUTURE BEHAVIOR
---------------

What the playbook run does with a host when an error is detected is
currently being refined and is subject to change.


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","@@ -14,19 +14,23 @@ ansible-playbook - format and function of an ansible playbook file
 DESCRIPTION
 -----------
 
-Ansible ships with a ansible-playbook tool for running playbooks.  Playbooks can represent
-frequent tasks, desired system configurations, or deployment processes.
+Ansible ships with a ansible-playbook tool for running playbooks.
+Playbooks can represent frequent tasks, desired system configurations,
+or deployment processes.
 
 
 FORMAT
 ------
 
-Playbooks are currently writeable in YAML.  Other formats (JSON?) may be supported in the future.
+Playbooks are currently writeable in YAML.  Other formats (JSON?) may
+be supported in the future.
 
 
 EXAMPLE
 -------
 
+[literal]
+---
 - pattern: '*'
   hosts: '/etc/ansible/hosts'
   tasks:
@@ -52,48 +56,52 @@ WHAT THE EXAMPLE MEANS
 
 Here's what the above example will do.
 
-For all hosts in /etc/ansible/hosts (one host per line) that are named 'webserver-anything', first
-write a JSON file into /etc/ansible/setup on each remote system with the values
-max_clients and http_port.
+For all hosts in /etc/ansible/hosts (one host per line) that are named
+'webserver-anything', first write a JSON file into /etc/ansible/setup
+on each remote system with the values max_clients and http_port.
 
-Next, use a Jinja2 template locally residing 
-at /srv/mytemplates/httpd.j2 to write the Apache config file on each host
+Next, use a Jinja2 template locally residing at
+/srv/mytemplates/httpd.j2 to write the Apache config file on each host
 to the path /etc/httpd/conf, using the previous values.
 
 Ensure that apache is running if stopped.
 
-If and only if the config file changed, note that we need to restart apache at the end of
-the run, otherwise, don't bother because we already know it is running.
+If and only if the config file changed, note that we need to restart
+apache at the end of the run, otherwise, don't bother because we
+already know it is running.
 
 
 HIGH LEVEL EXPLANATION
 ----------------------
 
-Playbooks are executed top down and can contain multiple references to patterns.
-For instance, a playbook could do something to all webservers, then do something
-to all database servers, then do something different to all webservers again.
+Playbooks are executed top down and can contain multiple references to
+patterns.  For instance, a playbook could do something to all
+webservers, then do something to all database servers, then do
+something different to all webservers again.
 
-For each pattern, the tasks in the 'tasks' list are executed in order for all
-hosts in the host file matching the pattern.
+For each pattern, the tasks in the 'tasks' list are executed in order
+for all hosts in the host file matching the pattern.
 
-For each task, a ""do"" statement describes what the task is and what ansible
-module to use to accomplish the task, along with any arguments.  The first
-line in the ""do"" is the name of the task -- this will appear in any log output.
+For each task, a ""do"" statement describes what the task is and what
+ansible module to use to accomplish the task, along with any
+arguments.  The first line in the ""do"" is the name of the task -- this
+will appear in any log output.
 
-The second line in each ""do"" is the module name followed by module arguments.
+The second line in each ""do"" is the module name followed by module
+arguments.
 
 Most modules accept key=value format arguments.
 
-Handlers are like tasks, but are conditionally executed.  If a module reports
-a 'change', it can choose to notify a handler by name.  If notified, it will
-run only for hosts that changed.
+Handlers are like tasks, but are conditionally executed.  If a module
+reports a 'change', it can choose to notify a handler by name.  If
+notified, it will run only for hosts that changed.
 
 
 FUTURE BEHAVIOR
 ---------------
 
-What the playbook run does with a host when an error is detected is currently being refined
-and is subject to change. 
+What the playbook run does with a host when an error is detected is
+currently being refined and is subject to change.
 
 
 AUTHOR
",code-fix,code-fix: Modify ansible-playbook.5.asciidoc: +32/-24 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.999853491783142,0.9922041693829003,Minor,Minor,YES
66127727110532ed943724904e79c4d82bb41874,"Update man pages. Fix formatting in playbook example. Also, YAML documents by definition start with '---', so I have added this to the example and the manpage",examples/playbook.yml,"- pattern: '*'
  hosts: /etc/ansible/hosts
  tasks:
  - do:
    - configure template & module variables for future template calls
    - setup a=2 b=3 c=4
  - do:
    - copy a file from the local disk to the remote
    - copy src=/srv/a dest=/srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template src=/srv/template.j2 dest=/srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - if running as non-root whne you template, you should specify the MD file (1)
    - setup a=3 b=4 c=5 metadata=/tmp/metadata.json 
  - do:
    - if running as non-root when you template, you should specify the MD file (2)
    - template src=/srv/template.j2 dest=/srv/file2.out metadata=/tmp/metadata.json
  - do:
    - call something that will fail just to demo failure counts and such
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted
    - do:
      - quack like a duck
      - command /bin/true
","---
- pattern: '*'
  hosts: /etc/ansible/hosts
  tasks:
  - do:
    - configure template & module variables for future template calls
    - setup a=2 b=3 c=4
  - do:
    - copy a file from the local disk to the remote
    - copy src=/srv/a dest=/srv/b
    notify: 
    - restart apache
  - do:
    - template from local file template.j2 to remote location /srv/file.out
    - template src=/srv/template.j2 dest=/srv/file.out
    notify:
    - restart apache
    - quack like a duck
  - do:
    - if running as non-root whne you template, you should specify the MD file (1)
    - setup a=3 b=4 c=5 metadata=/tmp/metadata.json 
  - do:
    - if running as non-root when you template, you should specify the MD file (2)
    - template src=/srv/template.j2 dest=/srv/file2.out metadata=/tmp/metadata.json
  - do:
    - call something that will fail just to demo failure counts and such
    - command /bin/false
  handlers:
    - do:
      - restart apache
      - service name=httpd ensure=restarted
    - do:
      - quack like a duck
      - command /bin/true
","@@ -1,3 +1,4 @@
+---
 - pattern: '*'
   hosts: /etc/ansible/hosts
   tasks:
",config-fix,config-fix: Modify playbook.yml: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999653100967408,0.993398979229516,Minor,Minor,YES
1a20b00d1f29d0079e81d2bbdd11a39ac9b18221,If the error is an authentication exception - just report it that way don't dump out an unappetizing traceback which just says the same,lib/ansible/runner.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
   ","@@ -108,6 +108,8 @@ class Runner(object):
             ssh.connect(host, username=self.remote_user, allow_agent=True, 
               look_for_keys=True, password=self.remote_pass)
             return [ True, ssh ]
+        except paramiko.AuthenticationException, e:
+            return [ False, str(e) ]
         except:
             # it failed somehow, return the failure string
             return [ False, traceback.format_exc() ]
",logic-fix,If the error is an authentication exception - just report it that way don't dump out an unappetizing traceback which just says the same,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9858627497662524,Minor,Minor,YES
bd7a71bb29d0fc26ed6fbae802018d06ddefc346,"implement manual multiprocessing pools for the runner.
this fixes the ctrl-c not-working problem.

implemented this solution: http://www.bryceboe.com/2010/08/26/python-multiprocessing-and-keyboardinterrupt/#georges

also add hosts which do not get a chance to return results to the 'dark' results.",lib/ansible/runner.py,"# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(x):
    ''' callback used by multiprocessing pool '''
    (runner, host) = x
    return runner._executor(host)

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn, tempname)
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
   ","# Copyright (c) 2012 Michael DeHaan <michael.dehaan@gmail.com>
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated documentation 
# files (the ""Software""), to deal in the Software without restriction, 
# including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import fnmatch
import multiprocessing
import signal
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self._parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass

    def _parse_hosts(self, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_src = self._get_tmp_path(conn, dest.split(""/"")[-1])
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath =","@@ -21,16 +21,23 @@
 
 import fnmatch
 import multiprocessing
+import signal
 import os
 import json
 import traceback
 import paramiko # non-core dependency
 import ansible.constants as C 
 
-def _executor_hook(x):
+def _executor_hook(job_queue, result_queue):
     ''' callback used by multiprocessing pool '''
-    (runner, host) = x
-    return runner._executor(host)
+    signal.signal(signal.SIGINT, signal.SIG_IGN)
+    while not job_queue.empty():
+        try:
+            job = job_queue.get(block=False)
+            runner, host = job
+            result_queue.put(runner._executor(host))
+        except Queue.Empty:
+            pass
 
 class Runner(object):
 
@@ -288,7 +295,7 @@ class Runner(object):
 
     def run(self):
         ''' xfer & run module on all matched hosts '''
-
+        
         # find hosts that match the pattern
         hosts = self.match_hosts(self.pattern)
 
@@ -296,10 +303,34 @@ class Runner(object):
         # _executor_hook does all of the work
         hosts = [ (self,x) for x in hosts ]
         if self.forks > 1:
-            pool = multiprocessing.Pool(self.forks)
-            results = pool.map(_executor_hook, hosts)
+            job_queue = multiprocessing.Queue()
+            result_queue = multiprocessing.Queue()
+ 
+            for i in hosts:
+                job_queue.put(i)
+ 
+            workers = []
+            for i in range(self.forks):
+                tmp = multiprocessing.Process(target=_executor_hook,
+                                      args=(job_queue, result_queue))
+                tmp.start()
+                workers.append(tmp)
+ 
+            try:
+                for worker in workers:
+                    worker.join()
+            except KeyboardInterrupt:
+                print 'parent received ctrl-c'
+                for worker in workers:
+                    worker.terminate()
+                    worker.join()
+            
+            results = []
+            while not result_queue.empty():
+                results.append(result_queue.get(block=False))
+ 
         else:
-            results = [ _executor_hook(x) for x in hosts ]
+            results = [ x._executor(h) for (x,h) in hosts ]
 
         # sort hosts by ones we successfully contacted
         # and ones we did not so that we can return a 
@@ -309,13 +340,22 @@ class Runner(object):
           ""contacted"" : {},
           ""dark""      : {}
         }
+        hosts_with_results = []
         for x in results:
             (host, is_ok, result) = x
+            hosts_with_results.append(host)
             if not is_ok:
                 results2[""dark""][host] = result
             else:
                 results2[""contacted""][host] = result
-
+        # hosts which were contacted but never got a chance
+        # to return a result before we exited/ctrl-c'd
+        # perhaps these shouldn't be 'dark' but I'm not sure if they fit
+        # anywhere else.
+        for host in self.match_hosts(self.pattern):
+            if host not in hosts_with_results:
+                results2[""dark""][host] = {}
+                
         return results2
 
 
",logic-fix,logic-fix: Modify runner.py: +48/-8 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9977141618728638,0.9644765393419068,Minor,Minor,YES
39f42cfd75305e5e2a893e54c0a20781be6231ae,when it is an IOError or an OSError - return a normal error message instead of a traceback barf,library/command,"#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""error"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","@@ -17,6 +17,12 @@ try:
     cmd = subprocess.Popen(args, shell=False, 
         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     out, err = cmd.communicate()
+except (OSError, IOError), e:
+    print json.dumps({
+        ""failed"": 1,
+        ""error"": str(e),
+        })
+    sys.exit(1)
 except:
     print json.dumps({
         ""failed"" : 1,
",code-fix,when it is an IOError or an OSError - return a normal error message instead of a traceback barf,0.0,0.0,0,0,0,0,0.0,0,0,0.9977577924728394,0.8471483953962876,Minor,Minor,YES
f32f5d5ac523d9d470c927a5fc2b8b7f94f1b7a1,Fix markdown bullets,README.md,"Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

    * Dead simple setup
    * Super fast & parallel by default
    * No server or client daemons; use existing SSHd
    * No additional software required on client boxes
    * Modules can be written in ANY language
    * Awesome API for creating very powerful distributed scripts
    * Be usable as non-root
    * Create the easiest config management system to use, ever.

Requirements
============

For the server the tool is running from, *only*:

    * paramiko
    * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
    * PyYAML (only if using playbooks)

Optional -- If you want to push templates, the nodes need a template library,
which for bonus points you can install with ansible!  Easy enough.

    * python-jinja2 

Inventory file
==============

To use ansible you must have a list of hosts somewhere.  The default inventory file (override with -H) is /etc/ansible/hosts and is a list of all hostnames to manage with ansible, one per line.  These can be hostnames or IPs.

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-p) to target
specific hosts.  This is covered below.  You can also organize groups of systems by having multiple inventory files (i.e. keeping webservers different from dbservers, etc)

Massive Parallelism, Pattern Matching, and a Usage Example
==========================================================

Reboot all web servers in Atlanta, 10 at a time:
 
   * ssh-agent bash
   * ssh-add ~/.ssh/id_rsa.pub
   * ansible -p ""atlanta-web*"" -f 10 -n command -a ""/sbin/reboot""

Other than the comamnd module, though, ansible modules are not scripts.  They make
the remote system look like you state, and run the commands neccessary to get it 
there.

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

   * ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Templating
==========

JSON files can be placed for template metadata using Jinja2.  Variables
placed by 'setup' can be reused between ansible runs.

   * ansible -p ""*"" -n setup -a ""favcolor=red ntp_server=192.168.1.1""
   * ansible -p ""*"" -n template /srv/motd.j2 /etc/motd 
   * ansible -p ""*"" -n template /srv/ntp.j2 /etc/ntp.conf

Very soon, templates will be able to also include facter and ohai
variables.

Git Deployments
===============

Deploy your webapp straight from git

  * ansible -p ""web*"" -n git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Take Inventory
==============

Run popular open-source data discovery tools across a wide number of hosts.
This is best used from API scripts that want to learn about remote systems.

  * ansible -p ""dbserver*"" -n facter
  * ansible -p ""dbserver"""" -n ohai

Other Modules
=============

See the library directory for lots of extras.  There's also a manpage,
ansible-modules(5) that covers all the options they take.  You can
read the asciidoc in github in the 'docs' directory.

Playbooks
=========

Playbooks are particularly awesome.  Playbooks can batch ansible commands
together, and can even fire off triggers when certain commands report changes.
They are the basis for a really simple configuration management system, unlike
any that already exist.  Powerful, concise, but dead simple.

See examples/playbook.yml for what the syntax looks like.

To run a playbook:

ansible -r playbook.yml

Read ansible-playbook(5) for more details.

Future plans
============

   * see github's issue tracker for what we're thinking about

License
=======

   * MIT

Mailing List
============

   * Join the mailing list to talk about Ansible!
   * [ansible-project](http://groups.google.com/group/ansible-project)

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

   * Dead simple setup
   * Super fast & parallel by default
   * No server or client daemons; use existing SSHd
   * No additional software required on client boxes
   * Modules can be written in ANY language
   * Awesome API for creating very powerful distributed scripts
   * Be usable as non-root
   * Create the easiest config management system to use, ever.

Requirements
============

For the server the tool is running from, *only*:

   * paramiko
   * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
   * PyYAML (only if using playbooks)

Optional -- If you want to push templates, the nodes need a template library,
which for bonus points you can install with ansible!  Easy enough.

   * python-jinja2 

Inventory file
==============

To use ansible you must have a list of hosts somewhere.  The default inventory file (override with -H) is /etc/ansible/hosts and is a list of all hostnames to manage with ansible, one per line.  These can be hostnames or IPs.

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-p) to target
specific hosts.  This is covered below.  You can also organize groups of systems by having multiple inventory files (i.e. keeping webservers different from dbservers, etc)

Massive Parallelism, Pattern Matching, and a Usage Example
==========================================================

Reboot all web servers in Atlanta, 10 at a time:
 
   * ssh-agent bash
   * ssh-add ~/.ssh/id_rsa.pub
   * ansible -p ""atlanta-web*"" -f 10 -n command -a ""/sbin/reboot""

Other than the comamnd module, though, ansible modules are not scripts.  They make
the remote system look like you state, and run the commands neccessary to get it 
there.

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

   * ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Templating
==========

JSON files can be placed for template metadata using Jinja2.  Variables
placed by 'setup' can be reused between ansible runs.

   * ansible -p ""*"" -n setup -a ""favcolor=red ntp_server=192.168.1.1""
   * ansible -p ""*"" -n template /srv/motd.j2 /etc/motd 
   * ansible -p ""*"" -n template /srv/ntp.j2 /etc/ntp.conf

Very soon, templates will be able to also include facter and ohai
variables.

Git Deployments
===============

Deploy your webapp straight from git

  * ansible -p ""web*"" -n git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Take Inventory
==============

Run popular open-source data discovery tools across a wide number of hosts.
This is best used from API scripts that want to learn about remote systems.

  * ansible -p ""dbserver*"" -n facter
  * ansible -p ""dbserver"""" -n ohai

Other Modules
=============

See the library directory for lots of extras.  There's also a manpage,
ansible-modules(5) that covers all the options they take.  You can
read the asciidoc in github in the 'docs' directory.

Playbooks
=========

Playbooks are particularly awesome.  Playbooks can batch ansible commands
together, and can even fire off triggers when certain commands report changes.
They are the basis for a really simple configuration management system, unlike
any that already exist.  Powerful, concise, but dead simple.

See examples/playbook.yml for what the syntax looks like.

To run a playbook:

ansible -r playbook.yml

Read ansible-playbook(5) for more details.

Future plans
============

   * see github's issue tracker for what we're thinking about

License
=======

   * MIT

Mailing List
============

   * Join the mailing list to talk about Ansible!
   * [ansible-project](http://groups.google.com/group/ansible-project)

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","@@ -24,28 +24,28 @@ and the source will be blindingly obvious.
 Design Principles
 =================
 
-    * Dead simple setup
-    * Super fast & parallel by default
-    * No server or client daemons; use existing SSHd
-    * No additional software required on client boxes
-    * Modules can be written in ANY language
-    * Awesome API for creating very powerful distributed scripts
-    * Be usable as non-root
-    * Create the easiest config management system to use, ever.
+   * Dead simple setup
+   * Super fast & parallel by default
+   * No server or client daemons; use existing SSHd
+   * No additional software required on client boxes
+   * Modules can be written in ANY language
+   * Awesome API for creating very powerful distributed scripts
+   * Be usable as non-root
+   * Create the easiest config management system to use, ever.
 
 Requirements
 ============
 
 For the server the tool is running from, *only*:
 
-    * paramiko
-    * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
-    * PyYAML (only if using playbooks)
+   * paramiko
+   * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
+   * PyYAML (only if using playbooks)
 
 Optional -- If you want to push templates, the nodes need a template library,
 which for bonus points you can install with ansible!  Easy enough.
 
-    * python-jinja2 
+   * python-jinja2 
 
 Inventory file
 ==============
",doc-fix,doc-fix: Modify README.md: +12/-12 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9997605681419371,1.0,Minor,Minor,YES
186dab4dff653b29d8e7fac19cba79e66179d0fc,"Include facter variables for free in setup JSON (prefix with 'facter'.

Also sort keys in JSON file and pretty print",library/setup,"#!/usr/bin/python

DEFAULT_ANSIBLE_SETUP     = ""/etc/ansible/setup""

import sys
import os
import shlex

try:
    import json
except ImportError:
    import simplejson as json

# load config & template variables

input_data = sys.argv[1:]
new_options = dict([ x.split('=') for x in input_data ])
ansible_file = new_options.get('metadata', DEFAULT_ANSIBLE_SETUP)
ansible_dir = os.path.dirname(ansible_file)

# create the config dir if it doesn't exist

if not os.path.exists(ansible_dir):
    os.makedirs(ansible_dir)

changed = False
md5sum = None
if not os.path.exists(ansible_file):
    changed = True
else:
    md5sum = os.popen(""md5sum %s"" % ansible_file).read()

# write the template/settings file using
# instructions from server

f = open(ansible_file, ""w+"")
reformat = json.dumps(new_options)
f.write(reformat)
f.close()

md5sum2 = os.popen(""md5sum %s"" % ansible_file).read()

if md5sum != md5sum2:
   changed = True

result = {
   ""changed"" : changed,
   ""md5sum""  : md5sum
}

print json.dumps(result)
","#!/usr/bin/python

DEFAULT_ANSIBLE_SETUP     = ""/etc/ansible/setup""

import sys
import os
import shlex
import subprocess

try:
    import json
except ImportError:
    import simplejson as json

# load config & template variables

input_data = sys.argv[1:]
new_options = dict([ x.split('=') for x in input_data ])
ansible_file = new_options.get('metadata', DEFAULT_ANSIBLE_SETUP)
ansible_dir = os.path.dirname(ansible_file)

# create the config dir if it doesn't exist

if not os.path.exists(ansible_dir):
    os.makedirs(ansible_dir)

changed = False
md5sum = None
if not os.path.exists(ansible_file):
    changed = True
else:
    md5sum = os.popen(""md5sum %s"" % ansible_file).read()

# if facter is installed, and we can use --json because
# ruby-json is ALSO installed, include facter data in the JSON

if os.path.exists(""/usr/bin/facter""):
   cmd = subprocess.Popen(""/usr/bin/facter --json"", shell=True,
       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   out, err = cmd.communicate()
   facter = True
   try:
       facter_ds = json.loads(out)
   except:
       facter = False
   if facter:
       for (k,v) in facter_ds.items():
           new_options[""facter_%s"" % k] = v

# write the template/settings file using
# instructions from server

f = open(ansible_file, ""w+"")
reformat = json.dumps(new_options, sort_keys=True, indent=4)
f.write(reformat)
f.close()

md5sum2 = os.popen(""md5sum %s"" % ansible_file).read()

if md5sum != md5sum2:
   changed = True

result = {
   ""changed"" : changed,
   ""md5sum""  : md5sum
}

print json.dumps(result)
","@@ -5,6 +5,7 @@ DEFAULT_ANSIBLE_SETUP     = ""/etc/ansible/setup""
 import sys
 import os
 import shlex
+import subprocess
 
 try:
     import json
@@ -30,11 +31,27 @@ if not os.path.exists(ansible_file):
 else:
     md5sum = os.popen(""md5sum %s"" % ansible_file).read()
 
+# if facter is installed, and we can use --json because
+# ruby-json is ALSO installed, include facter data in the JSON
+
+if os.path.exists(""/usr/bin/facter""):
+   cmd = subprocess.Popen(""/usr/bin/facter --json"", shell=True,
+       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+   out, err = cmd.communicate()
+   facter = True
+   try:
+       facter_ds = json.loads(out)
+   except:
+       facter = False
+   if facter:
+       for (k,v) in facter_ds.items():
+           new_options[""facter_%s"" % k] = v
+
 # write the template/settings file using
 # instructions from server
 
 f = open(ansible_file, ""w+"")
-reformat = json.dumps(new_options)
+reformat = json.dumps(new_options, sort_keys=True, indent=4)
 f.write(reformat)
 f.close()
 
",code-fix,code-fix: Modify setup: +18/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.995671272277832,0.633294408965291,Minor,Major,NO
c8005e6c60973f565ac64dd2d9fc4f866f9d7fde,fix markdown links,README.md,"Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

   * Dead simple setup
   * Super fast & parallel by default
   * No server or client daemons; use existing SSHd
   * No additional software required on client boxes
   * Modules can be written in ANY language
   * Awesome API for creating very powerful distributed scripts
   * Be usable as non-root
   * Create the easiest config management system to use, ever.

Requirements
============

For the server the tool is running from, *only*:

   * paramiko
   * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
   * PyYAML (only if using playbooks)

Optional -- If you want to push templates, the nodes need a template library,
which for bonus points you can install with ansible!  Easy enough.

   * python-jinja2 

Inventory file
==============

To use ansible you must have a list of hosts somewhere.  The default inventory file (override with -H) is /etc/ansible/hosts and is a list of all hostnames to manage with ansible, one per line.  These can be hostnames or IPs.

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-p) to target
specific hosts.  This is covered below.  You can also organize groups of systems by having multiple inventory files (i.e. keeping webservers different from dbservers, etc)

Massive Parallelism, Pattern Matching, and a Usage Example
==========================================================

Reboot all web servers in Atlanta, 10 at a time:
 
    ssh-agent bash
    ssh-add ~/.ssh/id_rsa.pub
    ansible -p ""atlanta-web*"" -f 10 -n command -a ""/sbin/reboot""

Other than the comamnd module, though, ansible modules are not scripts.  They make
the remote system look like you state, and run the commands neccessary to get it 
there.

(Read the manpage)[https://github.com/mpdehaan/ansible/blob/master/docs/man/man1/ansible.1.asciidoc]

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

    ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Templating
==========

JSON files can be placed for template metadata using Jinja2.  Variables
placed by 'setup' can be reused between ansible runs.

    ansible -p ""*"" -n setup -a ""favcolor=red ntp_server=192.168.1.1""
    ansible -p ""*"" -n template /srv/motd.j2 /etc/motd 
    ansible -p ""*"" -n template /srv/ntp.j2 /etc/ntp.conf

Need something like the fqdn in a template?  If facter or ohai are installed, data from these projects
will also be made available to the template engine, using 'facter_' and 'ohai_'
prefixes for each.

Git Deployments
===============

Deploy your webapp straight from git

    ansible -p ""web*"" -n git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Take Inventory
==============

Run popular open-source data discovery tools across a wide number of hosts.
This is best used from API scripts that want to learn about remote systems.

    ansible -p ""dbserver*"" -n facter
    ansible -p ""dbserver"""" -n ohai

Other Modules
=============

See the library directory for lots of extras.  There's also a manpage,
(ansible-modules(5))[https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc] that covers all the options they take.  You can
read the asciidoc in github in the 'docs' directory.

Playbooks
=========

Playbooks are particularly awesome.  Playbooks can batch ansible commands
together, and can even fire off triggers when certain commands report changes.
They are the basis for a really simple configuration management system, unlike
any that already exist.  Powerful, concise, but dead simple.

See examples/playbook.yml for what the syntax looks like, and the manpage -- (ansible-playbook(5))[https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc] for more details.

To run a playbook:

    ansible -r playbook.yml


Future plans
============

See github's issue tracker for what we're thinking about

License
=======

MIT

Mailing List
============

Join the mailing list to talk about Ansible!

[ansible-project](http://groups.google.com/group/ansible-project)

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

   * Dead simple setup
   * Super fast & parallel by default
   * No server or client daemons; use existing SSHd
   * No additional software required on client boxes
   * Modules can be written in ANY language
   * Awesome API for creating very powerful distributed scripts
   * Be usable as non-root
   * Create the easiest config management system to use, ever.

Requirements
============

For the server the tool is running from, *only*:

   * paramiko
   * python 2.6 (or the 2.4/2.5 backport of the multiprocessing module)
   * PyYAML (only if using playbooks)

Optional -- If you want to push templates, the nodes need a template library,
which for bonus points you can install with ansible!  Easy enough.

   * python-jinja2 

Inventory file
==============

To use ansible you must have a list of hosts somewhere.  The default inventory file (override with -H) is /etc/ansible/hosts and is a list of all hostnames to manage with ansible, one per line.  These can be hostnames or IPs.

Example:

    abc.example.com
    def.example.com
    192.168.10.50
    192.168.10.51

This list is further filtered by the pattern wildcard (-p) to target
specific hosts.  This is covered below.  You can also organize groups of systems by having multiple inventory files (i.e. keeping webservers different from dbservers, etc)

Massive Parallelism, Pattern Matching, and a Usage Example
==========================================================

Reboot all web servers in Atlanta, 10 at a time:
 
    ssh-agent bash
    ssh-add ~/.ssh/id_rsa.pub
    ansible -p ""atlanta-web*"" -f 10 -n command -a ""/sbin/reboot""

Other than the comamnd module, though, ansible modules are not scripts.  They make
the remote system look like you state, and run the commands neccessary to get it 
there.

[Read the manpage](https://github.com/mpdehaan/ansible/blob/master/docs/man/man1/ansible.1.asciidoc)

File Transfer
=============

Ansible can SCP lots of files to lots of places in parallel.

    ansible -p ""web-*.acme.net"" -f 10 -n copy -a ""/etc/hosts /tmp/hosts""

Templating
==========

JSON files can be placed for template metadata using Jinja2.  Variables
placed by 'setup' can be reused between ansible runs.

    ansible -p ""*"" -n setup -a ""favcolor=red ntp_server=192.168.1.1""
    ansible -p ""*"" -n template /srv/motd.j2 /etc/motd 
    ansible -p ""*"" -n template /srv/ntp.j2 /etc/ntp.conf

Need something like the fqdn in a template?  If facter or ohai are installed, data from these projects
will also be made available to the template engine, using 'facter_' and 'ohai_'
prefixes for each.

Git Deployments
===============

Deploy your webapp straight from git

    ansible -p ""web*"" -n git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Take Inventory
==============

Run popular open-source data discovery tools across a wide number of hosts.
This is best used from API scripts that want to learn about remote systems.

    ansible -p ""dbserver*"" -n facter
    ansible -p ""dbserver"""" -n ohai

Other Modules
=============

See the library directory for lots of extras.  There's also a manpage,
[ansible-modules(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc) that covers all the options they take.  You can
read the asciidoc in github in the 'docs' directory.

Playbooks
=========

Playbooks are particularly awesome.  Playbooks can batch ansible commands
together, and can even fire off triggers when certain commands report changes.
They are the basis for a really simple configuration management system, unlike
any that already exist.  Powerful, concise, but dead simple.

See examples/playbook.yml for what the syntax looks like, and the manpage -- [ansible-playbook(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc) for more details.

To run a playbook:

    ansible -r playbook.yml


Future plans
============

See github's issue tracker for what we're thinking about

License
=======

MIT

Mailing List
============

Join the mailing list to talk about Ansible!

[ansible-project](http://groups.google.com/group/ansible-project)

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","@@ -75,7 +75,7 @@ Other than the comamnd module, though, ansible modules are not scripts.  They ma
 the remote system look like you state, and run the commands neccessary to get it 
 there.
 
-(Read the manpage)[https://github.com/mpdehaan/ansible/blob/master/docs/man/man1/ansible.1.asciidoc]
+[Read the manpage](https://github.com/mpdehaan/ansible/blob/master/docs/man/man1/ansible.1.asciidoc)
 
 File Transfer
 =============
@@ -118,7 +118,7 @@ Other Modules
 =============
 
 See the library directory for lots of extras.  There's also a manpage,
-(ansible-modules(5))[https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc] that covers all the options they take.  You can
+[ansible-modules(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc) that covers all the options they take.  You can
 read the asciidoc in github in the 'docs' directory.
 
 Playbooks
@@ -129,7 +129,7 @@ together, and can even fire off triggers when certain commands report changes.
 They are the basis for a really simple configuration management system, unlike
 any that already exist.  Powerful, concise, but dead simple.
 
-See examples/playbook.yml for what the syntax looks like, and the manpage -- (ansible-playbook(5))[https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc] for more details.
+See examples/playbook.yml for what the syntax looks like, and the manpage -- [ansible-playbook(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc) for more details.
 
 To run a playbook:
 
",doc-fix,doc-fix: Modify README.md: +3/-3 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9877694107766416,Minor,Minor,YES
03bf465c3afcc4befd92df84d48cde0873062ca4,attempt to fix asciidoc so it shows up on github,docs/man/man5/ansible-playbook.5.asciidoc,"ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.
Playbooks can represent frequent tasks, desired system configurations,
or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may
be supported in the future.


EXAMPLE
-------

[literal]
---
- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - name: configure template & module variables for future template calls
    action: setup http_port=80 max_clients=200
  - name: write the apache config file
    action: template src=/srv/templates/httpd.j2 dest=/etc/httpd/conf
    notify:
    - restart apache
  - name: ensure apache is running
    action: service name=httpd state=started
  handlers:
    - name: restart apache
    - action: service name=httpd state=restarted


WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named
'webserver-anything', first write a JSON file into /etc/ansible/setup
on each remote system with the values max_clients and http_port.

Next, use a Jinja2 template locally residing at
/srv/templates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd/conf, using the previous values.

We'll ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart
apache at the end of the run, otherwise, don't bother because we
already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to
patterns.  For instance, a playbook could do something to all
webservers, then do something to all database servers, then do
something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order
for all hosts in the host file matching the pattern.

For each task, a name/action pair describes what the task is and what
ansible module to use to accomplish the task, along with any
arguments.   Additional fields like 'comment:' can be added and will
be ignored, so feel free to take notes in the file.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module
reports a 'change', it can notify one or more handler by name.  If
notified, it will run only for hosts that changed.


ERROR HANDLING
--------------

If a host has a failure, the host will be ignored for the remainder
of the playbook execution.


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.
Playbooks can represent frequent tasks, desired system configurations,
or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may
be supported in the future.


EXAMPLE
-------

[source,yaml]
----
- pattern: '*'
  hosts: '/etc/ansible/hosts'
  tasks:
  - name: configure template & module variables for future template calls
    action: setup http_port=80 max_clients=200
  - name: write the apache config file
    action: template src=/srv/templates/httpd.j2 dest=/etc/httpd/conf
    notify:
    - restart apache
  - name: ensure apache is running
    action: service name=httpd state=started
  handlers:
    - name: restart apache
    - action: service name=httpd state=restarted
----


WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named
'webserver-anything', first write a JSON file into /etc/ansible/setup
on each remote system with the values max_clients and http_port.

Next, use a Jinja2 template locally residing at
/srv/templates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd/conf, using the previous values.

We'll ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart
apache at the end of the run, otherwise, don't bother because we
already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to
patterns.  For instance, a playbook could do something to all
webservers, then do something to all database servers, then do
something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order
for all hosts in the host file matching the pattern.

For each task, a name/action pair describes what the task is and what
ansible module to use to accomplish the task, along with any
arguments.   Additional fields like 'comment:' can be added and will
be ignored, so feel free to take notes in the file.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module
reports a 'change', it can notify one or more handler by name.  If
notified, it will run only for hosts that changed.


ERROR HANDLING
--------------

If a host has a failure, the host will be ignored for the remainder
of the playbook execution.


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","@@ -29,8 +29,8 @@ be supported in the future.
 EXAMPLE
 -------
 
-[literal]
----
+[source,yaml]
+----
 - pattern: '*'
   hosts: '/etc/ansible/hosts'
   tasks:
@@ -45,6 +45,7 @@ EXAMPLE
   handlers:
     - name: restart apache
     - action: service name=httpd state=restarted
+----
 
 
 WHAT THE EXAMPLE MEANS
",code-fix,code-fix: Modify ansible-playbook.5.asciidoc: +3/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999459385871888,0.9860352617346432,Minor,Minor,YES
0321afb1e3c1802eb12f7107f68d3b6a00ea2cf2,"Minor error handling tweaks (yell if no args) for ansible-command and some minor
style bits (underscores between compound words, use dest always in optparse)",bin/ans-command,"#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, errorprint


def main(args):
    parser = base_ans_parser(outputpath=False)
    parser.usage = ""ans-command [options] command-to-run""
    parser.add_option('--returncodes', action='store_true', 
            help=""prefix each line with the commands returncode"")
    parser.add_option('-1', '--oneline', action='store_true', 
            help=""output all things as one line - to make grepping easier, will \
                  not remove \\n's from output of commands, though"")
    parser.add_option('-o', '--output-to-dir', dest='output_dest', default=None,
          help=""output each hosts results to a file in a dir named for the host"")
    options, args = parser.parse_args(args)

    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")
    pattern = '*'
    if options.host:
        pattern += ';'.join(options.host)

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    mycmd = ' '.join(args)
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=pattern,
                verbose=True,
            )

    print mycmd
    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            errorprint(msg)
            continue

        if options.output_dest:
            fo = open(options.output_dest + '/' + hn +'.output', 'w')
            fo.write(mycmd + '\n')
            fo.write('%s:\n' % hn)
            if options.returncodes:
                fo.write('return code: %s\n' % d['rc'])
            fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
            fo.close()
            continue

        if options.oneline:
            if options.returncodes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.returncodes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        errorprint('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            errorprint(hn)
        print ''


    if options.output_dest:
        print ""output written to %s"" % options.output_dest

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):
    parser = base_ans_parser(output_path=False)
    parser.usage = ""ans-command [options] command-to-run""
    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
            help=""prefix each line with the commands returncode"")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
            help=""output all things as one line - to make grepping easier, will \
                  not remove \\n's from output of commands, though"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
          help=""output each host's results to a file in a dir named for the host"")
    options, args = parser.parse_args(args)

    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")
    pattern = '*'
    if options.host:
        pattern += ';'.join(options.host)

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    print ""FORKS=%s"" % options.forks
 
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=pattern,
                verbose=True,
            )

    print mycmd
    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.output_dest:
            fo = open(options.output_dest + '/' + hn +'.output', 'w')
            fo.write(mycmd + '\n')
            fo.write('%s:\n' % hn)
            if options.return_codes:
                fo.write('return code: %s\n' % d['rc'])
            fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
            fo.close()
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''


    if options.output_dest:
        print ""output written to %s"" % options.output_dest

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -25,19 +25,19 @@ import os
 import getpass
 import ansible.runner
 import shlex
-from ansible.scripts import base_ans_parser, errorprint
+from ansible.scripts import base_ans_parser, error_print
 
 
 def main(args):
-    parser = base_ans_parser(outputpath=False)
+    parser = base_ans_parser(output_path=False)
     parser.usage = ""ans-command [options] command-to-run""
-    parser.add_option('--returncodes', action='store_true', 
+    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
             help=""prefix each line with the commands returncode"")
-    parser.add_option('-1', '--oneline', action='store_true', 
+    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
             help=""output all things as one line - to make grepping easier, will \
                   not remove \\n's from output of commands, though"")
-    parser.add_option('-o', '--output-to-dir', dest='output_dest', default=None,
-          help=""output each hosts results to a file in a dir named for the host"")
+    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
+          help=""output each host's results to a file in a dir named for the host"")
     options, args = parser.parse_args(args)
 
     sshpass = None
@@ -61,7 +61,14 @@ def main(args):
             print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
             sys.exit(1)
 
+    if len(args) == 0:
+       print >> sys.stderr, ""Missing argument.  What should be executed?""
+       sys.exit(1)
+
     mycmd = ' '.join(args)
+   
+    print ""FORKS=%s"" % options.forks
+ 
     runner = ansible.runner.Runner(
                 module_name='command',
                 module_path=options.module_path,
@@ -86,36 +93,36 @@ def main(args):
             msg += d.get('stderr', '')
             msg += d.get('traceback', '')
             msg += d.get('error', '')
-            errorprint(msg)
+            error_print(msg)
             continue
 
         if options.output_dest:
             fo = open(options.output_dest + '/' + hn +'.output', 'w')
             fo.write(mycmd + '\n')
             fo.write('%s:\n' % hn)
-            if options.returncodes:
+            if options.return_codes:
                 fo.write('return code: %s\n' % d['rc'])
             fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
             fo.close()
             continue
 
-        if options.oneline:
-            if options.returncodes:
+        if options.one_line:
+            if options.return_codes:
                 print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
             else:
                 print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
         else:
             print '%s:' % hn
-            if options.returncodes:
+            if options.return_codes:
                 print 'return code:%s\n' % d['rc']
             print '%s' % d['stdout']
             if d.get('stderr', None):
                 print '%s' % d['stderr']
 
     if results['dark']:
-        errorprint('Hosts which could not be contacted or did not respond:')
+        error_print('Hosts which could not be contacted or did not respond:')
         for hn in sorted(results['dark']):
-            errorprint(hn)
+            error_print(hn)
         print ''
 
 
",code-fix,code-fix: Modify ans-command: +20/-13 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9997684359550476,0.8828868384750729,Minor,Minor,YES
0321afb1e3c1802eb12f7107f68d3b6a00ea2cf2,"Minor error handling tweaks (yell if no args) for ansible-command and some minor
style bits (underscores between compound words, use dest always in optparse)",lib/ansible/scripts.py,"# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

from optparse import OptionParser
import sys
import constants as C

def base_ans_parser(opthosts=True, outputpath=True, forkdef=C.DEFAULT_FORKS):
    parser = OptionParser()
    if opthosts:
        parser.add_option('--host', default=[], action='append',
            help=""hosts to act on, defaults to ALL"")
    parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
        help=""path to hosts list"", default=C.DEFAULT_HOST_LIST)
    parser.add_option(""-L"", ""--library"", dest=""module_path"",
        help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
    parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER, 
        dest='remote_user', help='set the default username')
    parser.add_option(""-P"", ""--askpass"", default=False, action=""store_true"",
         help=""ask the user to input the ssh password for connecting"")
    parser.add_option('-f','--forks', default=forkdef, type='int',
               help='set the number of forks to start up')
    if outputpath:
        parser.add_option('--outputpath', default='/tmp/ansible', dest=""outputpath"",
                   help=""basepath to store results/errors output."")
    return parser

# other functions as needed for nicely handling output from json back
# to things people might be more inclined to deal with at a bash prompt


def errorprint(msg):
    print >> sys.stderr, msg
    
","# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

from optparse import OptionParser
import sys
import constants as C

def base_ans_parser(opthosts=True, output_path=True, forkdef=C.DEFAULT_FORKS):
    parser = OptionParser()
    if opthosts:
        parser.add_option('--host', default=[], action='append',
            help=""hosts to act on, defaults to ALL"")
    parser.add_option(""-H"", ""--host-list"", dest=""host_list"",
        help=""path to hosts list"", default=C.DEFAULT_HOST_LIST)
    parser.add_option(""-L"", ""--library"", dest=""module_path"",
        help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
    parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER, 
        dest='remote_user', help='set the default username')
    parser.add_option(""-P"", ""--askpass"", default=False, action=""store_true"",
        help=""ask the user to input the ssh password for connecting"")
    parser.add_option('-f','--forks', dest='forks', default=forkdef, type='int',
        help='set the number of forks to start up')
    if output_path:
        parser.add_option('--output-path', default='/tmp/ansible', dest=""output_path"",
                   help=""basepath to store results/errors output."")
    return parser

# other functions as needed for nicely handling output from json back
# to things people might be more inclined to deal with at a bash prompt


def error_print(msg):
    print >> sys.stderr, msg
    
","@@ -18,7 +18,7 @@ from optparse import OptionParser
 import sys
 import constants as C
 
-def base_ans_parser(opthosts=True, outputpath=True, forkdef=C.DEFAULT_FORKS):
+def base_ans_parser(opthosts=True, output_path=True, forkdef=C.DEFAULT_FORKS):
     parser = OptionParser()
     if opthosts:
         parser.add_option('--host', default=[], action='append',
@@ -30,11 +30,11 @@ def base_ans_parser(opthosts=True, outputpath=True, forkdef=C.DEFAULT_FORKS):
     parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER, 
         dest='remote_user', help='set the default username')
     parser.add_option(""-P"", ""--askpass"", default=False, action=""store_true"",
-         help=""ask the user to input the ssh password for connecting"")
-    parser.add_option('-f','--forks', default=forkdef, type='int',
-               help='set the number of forks to start up')
-    if outputpath:
-        parser.add_option('--outputpath', default='/tmp/ansible', dest=""outputpath"",
+        help=""ask the user to input the ssh password for connecting"")
+    parser.add_option('-f','--forks', dest='forks', default=forkdef, type='int',
+        help='set the number of forks to start up')
+    if output_path:
+        parser.add_option('--output-path', default='/tmp/ansible', dest=""output_path"",
                    help=""basepath to store results/errors output."")
     return parser
 
@@ -42,6 +42,6 @@ def base_ans_parser(opthosts=True, outputpath=True, forkdef=C.DEFAULT_FORKS):
 # to things people might be more inclined to deal with at a bash prompt
 
 
-def errorprint(msg):
+def error_print(msg):
     print >> sys.stderr, msg
     
",logic-fix,logic-fix: Modify scripts.py: +7/-7 lines,96.81688287422986,96.81688287422986,4,4,47,47,0.0,0,0,0.999975085258484,0.9464508898181492,Minor,Minor,YES
0321afb1e3c1802eb12f7107f68d3b6a00ea2cf2,"Minor error handling tweaks (yell if no args) for ansible-command and some minor
style bits (underscores between compound words, use dest always in optparse)",setup.py,"#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/copy',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
      ]
)
","#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/copy',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
         'bin/ans-command',
      ]
)
","@@ -30,5 +30,6 @@ setup(name='ansible',
       ],
       scripts=[
          'bin/ansible',
+         'bin/ans-command',
       ]
 )
",build-fix,build-fix: Modify setup.py: +1/-0 lines,100.0,100.0,0,0,34,35,0.0,0,1,0.9998809099197388,0.954005815973756,Minor,Minor,YES
7de661dd2cfc9b7584d6d5a0976c205df4425c81,"Add ansible command, fix import error in runner",bin/ans-playbook,,"#!/usr/bin/python -tt
# (C) 2012, Michael DeHaan, <michael.dehaan@gmail.com>

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import ansible.playbook
from ansible.scripts import base_ans_parser, error_print

def main(args):
    parser = base_ans_parser(output_path=False)
    parser.usage = ""ans-playbook playbook.yml""
    options, args = parser.parse_args(args)

    if len(args) == 0:
       print >> sys.stderr, ""playbook path is a required argument""
       return 1

    for playbook in args:
        pb = ansible.playbook.PlayBook(
            playbook=playbook,
            module_path=options.module_path,
            remote_user=options.remote_user,
            forks=options.forks,
            verbose=True
        )
        pb.run()

    return 0


if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -0,0 +1,52 @@
+#!/usr/bin/python -tt
+# (C) 2012, Michael DeHaan, <michael.dehaan@gmail.com>
+
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+import sys
+import ansible.playbook
+from ansible.scripts import base_ans_parser, error_print
+
+def main(args):
+    parser = base_ans_parser(output_path=False)
+    parser.usage = ""ans-playbook playbook.yml""
+    options, args = parser.parse_args(args)
+
+    if len(args) == 0:
+       print >> sys.stderr, ""playbook path is a required argument""
+       return 1
+
+    for playbook in args:
+        pb = ansible.playbook.PlayBook(
+            playbook=playbook,
+            module_path=options.module_path,
+            remote_user=options.remote_user,
+            forks=options.forks,
+            verbose=True
+        )
+        pb.run()
+
+    return 0
+
+
+if __name__ == ""__main__"":
+    sys.exit(main(sys.argv[1:]))
+
+
+
+
+
",code-fix,code-fix: Modify ans-playbook: +52/-0 lines,0.0,90.9245657168732,0,3,0,52,90.9245657168732,3,52,0.5726710557937622,0.0,Major,Major,YES
7de661dd2cfc9b7584d6d5a0976c205df4425c81,"Add ansible command, fix import error in runner",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import fnmatch
import multiprocessing
import signal
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self._tmp_paths = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn) + tempname
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
        res","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import fnmatch
import multiprocessing
import signal
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 
import Queue

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self._tmp_paths = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn) + tempname
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ","@@ -24,6 +24,7 @@ import json
 import traceback
 import paramiko # non-core dependency
 import ansible.constants as C 
+import Queue
 
 def _executor_hook(job_queue, result_queue):
     ''' callback used by multiprocessing pool '''
",code-fix,code-fix: Modify runner.py: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.999901533126831,0.9958966468502564,Minor,Minor,YES
7de661dd2cfc9b7584d6d5a0976c205df4425c81,"Add ansible command, fix import error in runner",library/command,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""error"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""error"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

if out is None:
   out = ''
if err is None:
   err = ''

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","@@ -51,6 +51,11 @@ except:
 endd = datetime.datetime.now()
 delta = endd - startd
 
+if out is None:
+   out = ''
+if err is None:
+   err = ''
+
 result = {
    ""stdout"" : out,
    ""stderr"" : err,
",code-fix,code-fix: Modify command: +5/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999476075172424,0.9321260909725392,Minor,Minor,YES
c6eb3f1006a45e00df0ee10dcabea69e585ad052,remove debug statement,bin/ans-command,"#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):
    parser = base_ans_parser(output_path=False)
    parser.usage = ""ans-command [options] command-to-run""
    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
            help=""prefix each line with the commands returncode"")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
            help=""output all things as one line - to make grepping easier, will \
                  not remove \\n's from output of commands, though"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
          help=""output each host's results to a file in a dir named for the host"")
    options, args = parser.parse_args(args)

    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")
    pattern = '*'
    if options.host:
        pattern += ';'.join(options.host)

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    print ""FORKS=%s"" % options.forks
 
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=pattern,
                verbose=True,
            )

    print mycmd
    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.output_dest:
            fo = open(options.output_dest + '/' + hn +'.output', 'w')
            fo.write(mycmd + '\n')
            fo.write('%s:\n' % hn)
            if options.return_codes:
                fo.write('return code: %s\n' % d['rc'])
            fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
            fo.close()
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''


    if options.output_dest:
        print ""output written to %s"" % options.output_dest

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):
    parser = base_ans_parser(output_path=False)
    parser.usage = ""ans-command [options] command-to-run""
    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
            help=""prefix each line with the commands returncode"")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
            help=""output all things as one line - to make grepping easier, will \
                  not remove \\n's from output of commands, though"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
          help=""output each host's results to a file in a dir named for the host"")
    options, args = parser.parse_args(args)

    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")
    pattern = '*'
    if options.host:
        pattern += ';'.join(options.host)

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=pattern,
                verbose=True,
            )

    print mycmd
    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.output_dest:
            fo = open(options.output_dest + '/' + hn +'.output', 'w')
            fo.write(mycmd + '\n')
            fo.write('%s:\n' % hn)
            if options.return_codes:
                fo.write('return code: %s\n' % d['rc'])
            fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
            fo.close()
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''


    if options.output_dest:
        print ""output written to %s"" % options.output_dest

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -67,8 +67,6 @@ def main(args):
 
     mycmd = ' '.join(args)
    
-    print ""FORKS=%s"" % options.forks
- 
     runner = ansible.runner.Runner(
                 module_name='command',
                 module_path=options.module_path,
",code-fix,code-fix: Modify ans-command: +0/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998807907104,0.9883423845114112,Minor,Minor,YES
c6eb3f1006a45e00df0ee10dcabea69e585ad052,remove debug statement,setup.py,"#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/copy',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
         'bin/ans-command',
      ]
)
","#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/ohai',
             'library/copy',
             'library/setup',
             'library/template',
             'library/git',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
         'bin/ans-command',
      ]
)
","@@ -18,7 +18,11 @@ setup(name='ansible',
              'library/ping',
              'library/command',
              'library/facter',
+             'library/ohai',
              'library/copy',
+             'library/setup',
+             'library/template',
+             'library/git',
          ]),
          ('man/man1', [
                 'docs/man/man1/ansible.1'
",build-fix,build-fix: Modify setup.py: +4/-0 lines,100.0,100.0,0,0,35,39,0.0,0,4,0.9982128143310548,0.8820568251238248,Minor,Minor,YES
cc2d3e0f1aaadc3ec3592625f2413cbf589c0aaa,Fix my error from not removing this parameter,bin/ans-command,"#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):

    parser = base_ans_parser(output_path=False)
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
        help=""prefix each line with the command's return code"")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""output each host's results to a file in a dir named for the host"")

    options, args = parser.parse_args(args)

    # TODO: move into lib/ansible/scripts.py
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )

    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):

    parser = base_ans_parser()
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
        help=""prefix each line with the command's return code"")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""output each host's results to a file in a dir named for the host"")

    options, args = parser.parse_args(args)

    # TODO: move into lib/ansible/scripts.py
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )

    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -30,7 +30,7 @@ from ansible.scripts import base_ans_parser, error_print
 
 def main(args):
 
-    parser = base_ans_parser(output_path=False)
+    parser = base_ans_parser()
     parser.usage = ""ans-command [options] command-to-run""
 
     parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
",code-fix,code-fix: Modify ans-command: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998255372047424,0.9940722320705284,Minor,Minor,YES
b9b0240543145e977903d2763b24a5832d5351db,"Continued ans-command output upgrades, fixed output_dest back again",bin/ans-command,"#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):

    parser = base_ans_parser()
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""output each host's results to a file in a dir named for the host"")

    options, args = parser.parse_args(args)

    # TODO: move into lib/ansible/scripts.py
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )

    results = runner.run()

    for hostname in sorted(results['contacted']):

        result    = results['contacted'][hostname]
        rc        = result.get('rc',0)
        failed    = result.get('failed', 0)
        stdout    = result.get('stdout', '')
        stderr    = result.get('stderr', '')
        traceback = result.get('traceback', '')
        error     = result.get('error', '')

        if rc != 0 or failed:
            msg = 'Error: %s: ' % hostname
            # too bad stdout/stderr is not interleaved :(
            msg += stdout
            msg += stderr
            msg += traceback
            msg += error
            error_print(msg)
            continue

        if options.one_line:
            msg = ""(stdout) %s"" % stdout
            if stderr.rstrip() != '':
                msg = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
            print ""%s | rc=%s | %s"" % (
                hostname, rc, msg
            )
        else:
            print ""%s | rc=%s >>"" % (hostname, rc)
            print stdout
            if stderr:
                print stderr

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        failed_hosts = results['dark'].keys()
        for hostname in keys:
            error_print(""%s:%s"" % (hostname, results['dark'][hostname]))
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):

    parser = base_ans_parser()
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""output each host's results to a file in a dir named for the host"")

    options, args = parser.parse_args(args)

    # TODO: move into lib/ansible/scripts.py
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )

    results = runner.run()

    for hostname in sorted(results['contacted']):

        result    = results['contacted'][hostname]
        rc        = result.get('rc',0)
        failed    = result.get('failed', 0)
        stdout    = result.get('stdout', '')
        stderr    = result.get('stderr', '')
        traceback = result.get('traceback', '')
        error     = result.get('error', '')

        if rc != 0 or failed:
            msg = 'Error: %s: ' % hostname
            # too bad stdout/stderr is not interleaved :(
            msg += stdout
            msg += stderr
            msg += traceback
            msg += error
            error_print(msg)
            continue

        if options.one_line:
            msg = ""(stdout) %s"" % stdout
            if stderr.rstrip() != '':
                msg = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
            print ""%s | rc=%s | %s"" % (
                hostname, rc, msg
            )
        else:
            buf = ''
            buf += ""%s | rc=%s >>\n"" % (hostname, rc)
            buf += stdout
            if stderr:
                buf += stderr
            print buf
            if options.output_dest:
                path = os.path.join(options.output_dest, hostname)
                fd = open(path, ""w+"")
                fd.write(buf)
                fd.close()

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        failed_hosts = results['dark'].keys()
        for hostname in keys:
            error_print(""%s:%s"" % (hostname, results['dark'][hostname]))
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -108,10 +108,17 @@ def main(args):
                 hostname, rc, msg
             )
         else:
-            print ""%s | rc=%s >>"" % (hostname, rc)
-            print stdout
+            buf = ''
+            buf += ""%s | rc=%s >>\n"" % (hostname, rc)
+            buf += stdout
             if stderr:
-                print stderr
+                buf += stderr
+            print buf
+            if options.output_dest:
+                path = os.path.join(options.output_dest, hostname)
+                fd = open(path, ""w+"")
+                fd.write(buf)
+                fd.close()
 
     if results['dark']:
         error_print('Hosts which could not be contacted or did not respond:')
",code-fix,code-fix: Modify ans-command: +10/-3 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999999403953552,0.9335262592059694,Minor,Minor,YES
42767b30fe0407fce20c82c30bee82887bd9e263,Fix output on failed hosts,bin/ans-command,"#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):

    parser = base_ans_parser()
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""output each host's results to a file in a dir named for the host"")

    options, args = parser.parse_args(args)

    # TODO: move into lib/ansible/scripts.py
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )

    results = runner.run()

    for hostname in sorted(results['contacted']):

        result    = results['contacted'][hostname]
        rc        = result.get('rc',0)
        failed    = result.get('failed', 0)
        stdout    = result.get('stdout', '')
        stderr    = result.get('stderr', '')
        traceback = result.get('traceback', '')
        error     = result.get('error', '')

        if rc != 0 or failed:
            msg = 'Error: %s: ' % hostname
            # too bad stdout/stderr is not interleaved :(
            msg += stdout
            msg += stderr
            msg += traceback
            msg += error
            error_print(msg)
            continue

        if options.one_line:
            msg = ""(stdout) %s"" % stdout
            if stderr.rstrip() != '':
                msg = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
            print ""%s | rc=%s | %s"" % (
                hostname, rc, msg
            )
        else:
            buf = ''
            buf += ""%s | rc=%s >>\n"" % (hostname, rc)
            buf += stdout
            if stderr:
                buf += stderr
            print buf
            if options.output_dest:
                path = os.path.join(options.output_dest, hostname)
                fd = open(path, ""w+"")
                fd.write(buf)
                fd.close()

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        failed_hosts = results['dark'].keys()
        for hostname in keys:
            error_print(""%s:%s"" % (hostname, results['dark'][hostname]))
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt

# skvidal, (c) Red Hat, Inc 2012
# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

# TODO: add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):


    # ==================================
    # parse options
    parser = base_ans_parser()
    parser.usage = ""ans-command [options] command-to-run""

    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
        help=""output results on one line to make grepping easier, however will \
            not remove newlines from command output"")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
        help=""if specified, a directory name to save output to, one file per host"")

    options, args = parser.parse_args(args)

    # get user's password if not supplied
    # TODO: move into lib/ansible/scripts.py (?)
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt=""SSH password: "")

    # if specifying output destination (aka tree output saves), create the 
    # directory to output to

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                sys.exit(1)
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
            sys.exit(1)

    # if no arguments are specified, error out

    if len(args) == 0:
       print >> sys.stderr, ""Missing argument.  What should be executed?""
       sys.exit(1)

    # make the actual ansible API call

    mycmd = ' '.join(args)
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )
    results = runner.run()

    # walk through results and summarize them neatly

    for hostname in sorted(results['contacted']):

        result    = results['contacted'][hostname]
        rc        = result.get('rc',0)
        failed    = result.get('failed', 0)
        stdout    = result.get('stdout', '')
        stderr    = result.get('stderr', '')
        traceback = result.get('traceback', '')
        error     = result.get('error', '')

        # detect and show failures, if any

        if rc != 0 or failed:
            msg = ""Error: %s: \n"" % hostname
            msg += stdout
            msg += stderr
            msg += traceback
            msg += error
            error_print(msg)
            continue

        if options.one_line:
            # try to print everything on one line, but don't strip newlines
            # if the command output happend to be too long
            msg = ""(stdout) %s"" % stdout
            if stderr.rstrip() != '':
                msg = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
            print ""%s | rc=%s | %s"" % (
                hostname, rc, msg
            )
        else:
            # summarize response from command in multiple lines
            buf = ''
            buf += ""%s | rc=%s >>\n"" % (hostname, rc)
            buf += stdout
            if stderr:
                buf += stderr
            print buf
            if options.output_dest:
                path = os.path.join(options.output_dest, hostname)
                fd = open(path, ""w+"")
                fd.write(buf)
                fd.close()

    # print errors for hosts we could not reach
    if results['dark']:
        print ''
        error_print('Hosts which could not be contacted or did not respond:')
        failed_hosts = results['dark'].keys()
        for hostname in failed_hosts:
            error_print(""%s:\n%s\n"" % (hostname, results['dark'][hostname]))
        print ''

    
if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -1,5 +1,7 @@
 #!/usr/bin/python -tt
-#skvidal, (c) Red Hat, Inc 2012
+
+# skvidal, (c) Red Hat, Inc 2012
+# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
 
 # This file is part of Ansible
 #
@@ -17,8 +19,7 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-#todo
-# add 'execution time' option output to the output
+# TODO: add 'execution time' option output to the output
 
 import sys
 import os
@@ -30,6 +31,9 @@ from ansible.scripts import base_ans_parser, error_print
 
 def main(args):
 
+
+    # ==================================
+    # parse options
     parser = base_ans_parser()
     parser.usage = ""ans-command [options] command-to-run""
 
@@ -37,15 +41,19 @@ def main(args):
         help=""output results on one line to make grepping easier, however will \
             not remove newlines from command output"")
     parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
-        help=""output each host's results to a file in a dir named for the host"")
+        help=""if specified, a directory name to save output to, one file per host"")
 
     options, args = parser.parse_args(args)
 
-    # TODO: move into lib/ansible/scripts.py
+    # get user's password if not supplied
+    # TODO: move into lib/ansible/scripts.py (?)
     sshpass = None
     if options.askpass:
         sshpass = getpass.getpass(prompt=""SSH password: "")
 
+    # if specifying output destination (aka tree output saves), create the 
+    # directory to output to
+
     if options.output_dest:
         if options.output_dest[0] != '/':
             options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
@@ -55,17 +63,19 @@ def main(args):
             except (IOError, OSError), e:
                 print >> sys.stderr, ""Could not make dir %s: %s"" % (options.output_dest, e)
                 sys.exit(1)
-        
         if not os.access(options.output_dest, os.W_OK):
             print >> sys.stderr, ""Cannot write to path %s"" % options.output_dest
             sys.exit(1)
 
+    # if no arguments are specified, error out
+
     if len(args) == 0:
        print >> sys.stderr, ""Missing argument.  What should be executed?""
        sys.exit(1)
 
+    # make the actual ansible API call
+
     mycmd = ' '.join(args)
-   
     runner = ansible.runner.Runner(
                 module_name='command',
                 module_path=options.module_path,
@@ -77,9 +87,10 @@ def main(args):
                 pattern=options.pattern,
                 verbose=True,
             )
-
     results = runner.run()
 
+    # walk through results and summarize them neatly
+
     for hostname in sorted(results['contacted']):
 
         result    = results['contacted'][hostname]
@@ -90,9 +101,10 @@ def main(args):
         traceback = result.get('traceback', '')
         error     = result.get('error', '')
 
+        # detect and show failures, if any
+
         if rc != 0 or failed:
-            msg = 'Error: %s: ' % hostname
-            # too bad stdout/stderr is not interleaved :(
+            msg = ""Error: %s: \n"" % hostname
             msg += stdout
             msg += stderr
             msg += traceback
@@ -101,6 +113,8 @@ def main(args):
             continue
 
         if options.one_line:
+            # try to print everything on one line, but don't strip newlines
+            # if the command output happend to be too long
             msg = ""(stdout) %s"" % stdout
             if stderr.rstrip() != '':
                 msg = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
@@ -108,6 +122,7 @@ def main(args):
                 hostname, rc, msg
             )
         else:
+            # summarize response from command in multiple lines
             buf = ''
             buf += ""%s | rc=%s >>\n"" % (hostname, rc)
             buf += stdout
@@ -120,11 +135,13 @@ def main(args):
                 fd.write(buf)
                 fd.close()
 
+    # print errors for hosts we could not reach
     if results['dark']:
+        print ''
         error_print('Hosts which could not be contacted or did not respond:')
         failed_hosts = results['dark'].keys()
-        for hostname in keys:
-            error_print(""%s:%s"" % (hostname, results['dark'][hostname]))
+        for hostname in failed_hosts:
+            error_print(""%s:\n%s\n"" % (hostname, results['dark'][hostname]))
         print ''
 
     
",code-fix,code-fix: Modify ans-command: +29/-12 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9995123744010924,0.7291405011658756,Minor,Major,NO
de1d0011bc7072b2176abff463b1bf1c062b0be0,"Take darkened hosts out of the playbook rotation, fix error handling in template
module so that if a directory path is specified we get valid output",lib/ansible/playbook.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _run_task(self, pattern=None, task=None, host_list=None, 
        remote_user=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
        host_list = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        new_hosts = []
        for x in host_list:
            if not self.failures.has_key(x):
                new_hosts.append(x)
        host_list = new_hosts

        # load the module name and parameters from the task
        # entry
        name    = task['name']
        action  = task['action']
        comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (name)
            else:
                print ""\nNOTIFIED [%s]"" % (name)

        # load up an appropriate ansible runner to
        # run the task in parallel

        runner = ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        )
        results = runner.run()
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern group

        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                # flag the handler with the list of hosts
","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _run_task(self, pattern=None, task=None, host_list=None, 
        remote_user=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
        host_list = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        new_hosts = []
        for x in host_list:
            if not self.failures.has_key(x) and not self.dark.has_key(x):
                new_hosts.append(x)
        host_list = new_hosts

        # load the module name and parameters from the task
        # entry
        name    = task['name']
        action  = task['action']
        comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            if not conditional:
                print ""\nTASK [%s]"" % (name)
            else:
                print ""\nNOTIFIED [%s]"" % (name)

        # load up an appropriate ansible runner to
        # run the task in parallel

        runner = ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        )
        results = runner.run()
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern group

        for x in handlers:
            attribs = x[""do""]
            name = attribs[0]
            if match_name == name:
                # flag the ha","@@ -111,7 +111,7 @@ class PlayBook(object):
         # do not continue to run tasks on hosts that have had failures
         new_hosts = []
         for x in host_list:
-            if not self.failures.has_key(x):
+            if not self.failures.has_key(x) and not self.dark.has_key(x):
                 new_hosts.append(x)
         host_list = new_hosts
 
",logic-fix,logic-fix: Modify playbook.py: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998807907104,0.9903122086017668,Minor,Minor,YES
de1d0011bc7072b2176abff463b1bf1c062b0be0,"Take darkened hosts out of the playbook rotation, fix error handling in template
module so that if a directory path is specified we get valid output",library/template,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import jinja2
import shlex
try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form a=b c=d
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

source  = params['src']
dest    = params['dest']
metadata = params.get('metadata', '/etc/ansible/setup') 

 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import jinja2
import shlex
try:
    import json
except ImportError:
    import simplejson as json

# ===========================================
# convert arguments of form a=b c=d
# to a dictionary
# FIXME: make more idiomatic

args = "" "".join(sys.argv[1:])
items = shlex.split(args)
params = {}
for x in items:
    (k, v) = x.split(""="")
    params[k] = v

source  = params['src']
dest    = params['dest']
metadata = params.get('metadata', '/etc/ansible/setup') 

 
# raise an error if there is no template metadata
if not os.path.exists(metadata):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Missing %s, did you run the setup module yet?"" % metadata
    })
    sys.exit(1)

# raise an error if we can't parse the template metadata
try:
   f = open(metadata)
   data = json.loads(f.read())
   f.close()
except:
   print json.dumps({
       ""failed"" : 1,
       ""msg""    : ""Failed to parse/load %s, rerun the setup module?"" % metadata
   })
   sys.exit(1)

if not os.path.exists(source):
    print json.dumps({
        ""failed"" : 1,
        ""msg""    : ""Source template could not be read: %s"" % source
    })
    sys.exit(1)

source = file(source).read()

if os.path.isdir(dest):
    print json.dumps({
         ""failed"" : 1,
         ""msg""    : ""Destination is a directory""
    })
    sys.exit(1)

# record md5sum of original source file so we can report if it changed
changed = False
md5sum = None
if os.path.exists(dest):
    md5sum = os.popen(""md5sum %s"" % dest).read().split()[0]

# call Jinja2 here and save the new template file
template = jinja2.Template(source)
data_out = template.render(data)
f = open(dest, ""w+"")
f.write(data_out)
f.close()

# TODO: catch templating errors and do not clobber the file on the
# other end unless things were successful

# record m5sum and return success and whether things have changed
md5sum2 = os.popen(""md5sum %s"" % dest).read().split()[0]

if md5sum != md5sum2:
    changed = True

# mission accomplished
print json.dumps({
   ""md5sum""   : md5sum2,
   ""changed""  : changed 
})


","@@ -72,6 +72,13 @@ if not os.path.exists(source):
 
 source = file(source).read()
 
+if os.path.isdir(dest):
+    print json.dumps({
+         ""failed"" : 1,
+         ""msg""    : ""Destination is a directory""
+    })
+    sys.exit(1)
+
 # record md5sum of original source file so we can report if it changed
 changed = False
 md5sum = None
",code-fix,code-fix: Modify template: +7/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9592972915457458,Minor,Minor,YES
d0906e187f05192c39694a188fd61d8f7dfc6788,Correct file location error in example,docs/man/man5/ansible-playbook.5.asciidoc,"ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.
Playbooks can represent frequent tasks, desired system configurations,
or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may
be supported in the future.


EXAMPLE
-------

see https://github.com/mpdehaan/ansible/blob/master/examples/playbook.yml

WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named
'webserver-anything', first write a JSON file into /etc/ansible/setup
on each remote system with the values max_clients and http_port.

Next, use a Jinja2 template locally residing at
/srv/templates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd/conf, using the previous values.

We'll ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart
apache at the end of the run, otherwise, don't bother because we
already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to
patterns.  For instance, a playbook could do something to all
webservers, then do something to all database servers, then do
something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order
for all hosts in the host file matching the pattern.

For each task, a name/action pair describes what the task is and what
ansible module to use to accomplish the task, along with any
arguments.   Additional fields like 'comment:' can be added and will
be ignored, so feel free to take notes in the file.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module
reports a 'change', it can notify one or more handler by name.  If
notified, it will run only for hosts that changed.


ERROR HANDLING
--------------

If a host has a failure, the host will be ignored for the remainder
of the playbook execution.


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","ansible-modules(5)
=================
:doctype:manpage
:man source: Ansible-playbook
:man version: 0.0.1
:man manual: System administration commands


NAME
----
ansible-playbook - format and function of an ansible playbook file


DESCRIPTION
-----------

Ansible ships with a ansible-playbook tool for running playbooks.
Playbooks can represent frequent tasks, desired system configurations,
or deployment processes.


FORMAT
------

Playbooks are currently writeable in YAML.  Other formats (JSON?) may
be supported in the future.


EXAMPLE
-------

see https://github.com/mpdehaan/ansible/blob/master/examples/playbook.yml

WHAT THE EXAMPLE MEANS
-----------------------

Here's what the above example will do.

For all hosts in /etc/ansible/hosts (one host per line) that are named
'webserver-anything', first write a JSON file into /etc/ansible/setup
on each remote system with the values max_clients and http_port.

Next, use a Jinja2 template locally residing at
/srv/templates/httpd.j2 to write the Apache config file on each host
to the path /etc/httpd.conf, using the previous values.

We'll ensure that apache is running if stopped.

If and only if the config file changed, note that we need to restart
apache at the end of the run, otherwise, don't bother because we
already know it is running.


HIGH LEVEL EXPLANATION
----------------------

Playbooks are executed top down and can contain multiple references to
patterns.  For instance, a playbook could do something to all
webservers, then do something to all database servers, then do
something different to all webservers again.

For each pattern, the tasks in the 'tasks' list are executed in order
for all hosts in the host file matching the pattern.

For each task, a name/action pair describes what the task is and what
ansible module to use to accomplish the task, along with any
arguments.   Additional fields like 'comment:' can be added and will
be ignored, so feel free to take notes in the file.

Most modules accept key=value format arguments.

Handlers are like tasks, but are conditionally executed.  If a module
reports a 'change', it can notify one or more handler by name.  If
notified, it will run only for hosts that changed.


ERROR HANDLING
--------------

If a host has a failure, the host will be ignored for the remainder
of the playbook execution.


AUTHOR
------

Ansible was originally written by Michael DeHaan. See the AUTHORS file
for a complete list of contributors.


SEE ALSO
--------

*ansible*(1)

*ansible-playbook*(5) - pending

Ansible home page: <https://github.com/mpdehaan/ansible/>
","@@ -42,7 +42,7 @@ on each remote system with the values max_clients and http_port.
 
 Next, use a Jinja2 template locally residing at
 /srv/templates/httpd.j2 to write the Apache config file on each host
-to the path /etc/httpd/conf, using the previous values.
+to the path /etc/httpd.conf, using the previous values.
 
 We'll ensure that apache is running if stopped.
 
",code-fix,Correct file location error in example,0.0,0.0,0,0,0,0,0.0,0,0,0.999996542930603,0.9932929677678928,Minor,Minor,YES
19fdb7305ddcf7655b50fe2eb88b7bffea9fac89,have command module raise an error if no arguments are supplied,library/command,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""error"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

if out is None:
   out = ''
if err is None:
   err = ''

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

if len(sys.argv) == 1:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""at least a command name is required""
    })
    sys.exit(1)

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""error"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""traceback"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

if out is None:
   out = ''
if err is None:
   err = ''

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","@@ -28,6 +28,13 @@ import sys
 import datetime
 import traceback
 
+if len(sys.argv) == 1:
+    print json.dumps({
+        ""failed"" : True,
+        ""msg""    : ""at least a command name is required""
+    })
+    sys.exit(1)
+
 args = sys.argv[1:]
 startd = datetime.datetime.now()
 
",code-fix,have command module raise an error if no arguments are supplied,0.0,0.0,0,0,0,0,0.0,0,0,0.9995708465576172,0.9134458092570492,Minor,Minor,YES
ab266472be140884a937572a9700730b23ead51d,Trim errors on connection refused messages,lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import fnmatch
import multiprocessing
import signal
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 
import Queue

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self._tmp_paths = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except paramiko.AuthenticationException, e:
            return [ False, str(e) ]
        except:
            # it failed somehow, return the failure string
            return [ False, traceback.format_exc() ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn) + tempname
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import fnmatch
import multiprocessing
import signal
import os
import json
import traceback
import paramiko # non-core dependency
import ansible.constants as C 
import Queue

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
        self.host_list   = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self._tmp_paths = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' parse the host inventory file if not sent as an array '''

        # if the host list is given as a string load the host list
        # from a file, one host per line
        if type(host_list) != list:
            host_list = os.path.expanduser(host_list)
            return file(host_list).read().split(""\n"")

        return host_list


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com
        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            if fnmatch.fnmatch(host_name, subpattern):
                return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template operations '''

        # load up options
        options  = self._parse_kv(self.module_args)
        source   = options['src']
        dest     = options['dest']
        metadata = options.get('metadata', '/etc/ansible/setup')

        # first copy the source template over
        tempname = os.path.split(source)[-1]
        temppath = self._get_tmp_path(conn) + tempname
        self._transfer_file(conn, source, temppath)

        # install the template module
        self.module_name = 'template'
        module = self._transfer_module(conn)

        # run the template module
        self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn","@@ -115,11 +115,9 @@ class Runner(object):
             ssh.connect(host, username=self.remote_user, allow_agent=True, 
               look_for_keys=True, password=self.remote_pass)
             return [ True, ssh ]
-        except paramiko.AuthenticationException, e:
-            return [ False, str(e) ]
-        except:
+        except Exception, e:
             # it failed somehow, return the failure string
-            return [ False, traceback.format_exc() ]
+            return [ False, str(e) ]
 
     def _return_from_module(self, conn, host, result):
         ''' helper function to handle JSON parsing of results '''
",logic-fix,Trim errors on connection refused messages,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9885677992938016,Minor,Minor,YES
c8b1bbc7eabb66134d44ff7a05d2ab2b27c80f86,"make command module error when no -a more obvious as command is the default module and someone
may forget about -a.  The CLI already warns about no host pattern by pulling up usage.",library/command,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

if len(sys.argv) == 1:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""at least a command name is required""
    })
    sys.exit(1)

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""msg"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""msg"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

if out is None:
   out = ''
if err is None:
   err = ''

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import subprocess
import sys
import datetime
import traceback

if len(sys.argv) == 1:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""the command module requires arguments (-a)""
    })
    sys.exit(1)

args = sys.argv[1:]
startd = datetime.datetime.now()

try:
    cmd = subprocess.Popen(args, shell=False, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmd.communicate()
except (OSError, IOError), e:
    print json.dumps({
        ""failed"": 1,
        ""msg"": str(e),
        })
    sys.exit(1)
except:
    print json.dumps({
        ""failed"" : 1,
        ""msg"" : traceback.format_exc()
    })   
    sys.exit(1)

endd = datetime.datetime.now()
delta = endd - startd

if out is None:
   out = ''
if err is None:
   err = ''

result = {
   ""stdout"" : out,
   ""stderr"" : err,
   ""rc""     : cmd.returncode,
   ""start""  : str(startd),
   ""end""    : str(endd),
   ""delta""  : str(delta),
}

print json.dumps(result)
","@@ -31,7 +31,7 @@ import traceback
 if len(sys.argv) == 1:
     print json.dumps({
         ""failed"" : True,
-        ""msg""    : ""at least a command name is required""
+        ""msg""    : ""the command module requires arguments (-a)""
     })
     sys.exit(1)
 
",code-fix,"make command module error when no -a more obvious as command is the default module and someone
may forget about -a.  The CLI already warns about no host pattern by pulling up usage.",0.0,0.0,0,0,0,0,0.0,0,0,0.9999647736549376,0.9667704164315064,Minor,Minor,YES
e6a1acf756dcee1e23b6f0642563e2773fe7805d,"Let ""all"" be an alias for ""*"" in patterns, fix output bug on non-command execution, make clean now removes the build dir",Makefile,"#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 lib/

clean:
	rm -rf build
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","@@ -24,6 +24,7 @@ pep8:
 	pep8 lib/
 
 clean:
+	rm -rf build
 	find . -type f -name ""*.pyc"" -delete
 	find . -type f -name ""*.pyo"" -delete
 	find . -type f -name ""*~"" -delete
",code-fix,code-fix: Modify Makefile: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9996383190155028,0.961883028223314,Minor,Minor,YES
e6a1acf756dcee1e23b6f0642563e2773fe7805d,"Let ""all"" be an alias for ""*"" in patterns, fix output bug on non-command execution, make clean now removes the build dir",bin/ansible,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

try:
    import json
except ImportError:
    import simplejson as json

from optparse import OptionParser
import sys
import os
import getpass
import shlex
import ansible.runner
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser(usage = 'ansible <host-pattern> [options]')
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
            help='number of parallel processes to use')
        parser.add_option(""-i"", ""--inventory-file"", dest=""inventory"",
           help=""inventory host file"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-k"", ""--ask-pass"", default=False, action=""store_true"",
            help=""ask for SSH password"")
        parser.add_option(""-M"", ""--module-path"", dest=""module_path"",
           help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-m"", ""--module-name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',
            help=""condense output"")
        parser.add_option('-t', '--tree', dest='tree', default=None,
            help=""log output to this directory"")
        parser.add_option('-T', '--timeout', default=C.DEFAULT_TIMEOUT, type='int',
            dest='timeout', help=""set the SSH timeout in seconds"")
        parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER,
            dest='remote_user', help='connect as this user')
        options, args = parser.parse_args()

        if len(args) == 0 or len(args) > 1:
            parser.print_help()
            sys.exit(1)
        pattern = args[0]

        sshpass = None
        if options.ask_pass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        self.options = options

        runner = ansible.runner.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=shlex.split(options.module_args),
            remote_user=options.remote_user,
            remote_pass=sshpass,
            host_list=options.inventory,
            timeout=options.timeout,
            forks=options.forks,
            pattern=pattern,
            verbose=True,
        )
        return runner

    def output(self, results):

        # if specifying output destination (aka tree output saves), create the
        # directory to output to

        if results is None:
           print >> sys.stderr, ""No hosts matched""
           sys.exit(1)

        options = self.options

        # TODO: split into function 
        if options.tree:
            if options.tree[0] != '/':
                options.tree = os.path.realpath(os.path.expanduser(options.tree))
            if not os.path.exists(options.tree):
                try:
                    os.makedirs(options.tree)
                except (IOError, OSError), e:
                    print >> sys.stderr, ""Could not make dir %s: %s"" % (options.tree, e)
                    sys.exit(1)
            if not os.access(options.tree, os.W_OK):
                print >> sys.stderr, ""Cannot write to path %s"" % options.tree
                sys.exit(1)

        # now walk results and print output

        module_name = self.options.module_name
        
        for hostname in sorted(results['contacted']):
            result    = results['contacted'][hostname]
            
            # TODO: refactor
            rc        = 0
            msg       = ''
            failed    = False
            stdout    = None
            stderr    = None
            traceback = None
            if type(result) == dict:
                failed    = result.get('failed', 0)
                msg       = result.get('msg', '')
                if module_name == 'command':
                    # TODO: refactor
                    rc        = result.get('rc',0)
                    stdout    = result.get('stdout', '')
                    stderr    = result.get('stderr', '')
                    traceback = result.get('traceback', '')

            if options.one_line:
                # try to print everything on one line, but don't strip newlines
                # if the command output happend to be too long
                if module_name == 'command':
                    if not failed:
                        buf = ""(stdout) %s"" % stdout
                        if stderr.rstrip() != '':
                            buf = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
                        print ""%s | rc=%s | %s"" % (
                            hostname, rc, buf
                        )
                    else:
                        print ""%s | (error) %s"" % (hostname, msg)
                else:
                    print ""%s | %s"" % (hostname, result)
            else:
                # summarize response from command in multiple lines
                buf = ''
                if module_name == 'command':
                    if not failed:
                        buf += ""%s | rc=%s >>\n"" % (hostname, rc)
                    else:
                        buf += ""%s | rc=%s | FAILED >>\n"" % (hostname, rc)
                    buf += stdout
                    if stderr:
                        buf += stderr
                    if msg:
                        buf += msg
                    print buf
                else:
                    if not failed:
                        buf += ""%s >>"" % hostname
                    else:
                        buf += ""%s | FAILED >>"" % hostname
                    buf += json.dumps(result, indent=4, sort_keys=True)
                if options.tree:
                    path = os.path.join(options.tree, hostname)
                    fd = open(path, ""w+"")
                    fd.write(buf)
                    fd.close()

        if len(results['dark'].keys()) > 0:
            print >> sys.stderr, ""*** Hosts which could not be contacted or did not respond: ***""
            failed_hosts = results['dark'].keys()
            for hostname in failed_hosts:
                print >> sys.stderr, ""%s:\n%s\n"" % (hostname, results['dark'][hostname])
            print """"

if __name__ == '__main__':
    cli = Cli()
    cli.output(cli.runner().run())
    
","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

try:
    import json
except ImportError:
    import simplejson as json

from optparse import OptionParser
import sys
import os
import getpass
import shlex
import ansible.runner
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser

class Cli(object):

    def __init__(self):
        pass

    def runner(self):
        parser = OptionParser(usage = 'ansible <host-pattern> [options]')
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
            help='number of parallel processes to use')
        parser.add_option(""-i"", ""--inventory-file"", dest=""inventory"",
           help=""inventory host file"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-k"", ""--ask-pass"", default=False, action=""store_true"",
            help=""ask for SSH password"")
        parser.add_option(""-M"", ""--module-path"", dest=""module_path"",
           help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-m"", ""--module-name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',
            help=""condense output"")
        parser.add_option('-t', '--tree', dest='tree', default=None,
            help=""log output to this directory"")
        parser.add_option('-T', '--timeout', default=C.DEFAULT_TIMEOUT, type='int',
            dest='timeout', help=""set the SSH timeout in seconds"")
        parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER,
            dest='remote_user', help='connect as this user')
        options, args = parser.parse_args()

        if len(args) == 0 or len(args) > 1:
            parser.print_help()
            sys.exit(1)
        pattern = args[0]

        sshpass = None
        if options.ask_pass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        self.options = options

        runner = ansible.runner.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=shlex.split(options.module_args),
            remote_user=options.remote_user,
            remote_pass=sshpass,
            host_list=options.inventory,
            timeout=options.timeout,
            forks=options.forks,
            pattern=pattern,
            verbose=True,
        )
        return runner

    def output(self, results):

        # if specifying output destination (aka tree output saves), create the
        # directory to output to

        if results is None:
           print >> sys.stderr, ""No hosts matched""
           sys.exit(1)

        options = self.options

        # TODO: split into function 
        if options.tree:
            if options.tree[0] != '/':
                options.tree = os.path.realpath(os.path.expanduser(options.tree))
            if not os.path.exists(options.tree):
                try:
                    os.makedirs(options.tree)
                except (IOError, OSError), e:
                    print >> sys.stderr, ""Could not make dir %s: %s"" % (options.tree, e)
                    sys.exit(1)
            if not os.access(options.tree, os.W_OK):
                print >> sys.stderr, ""Cannot write to path %s"" % options.tree
                sys.exit(1)

        # now walk results and print output

        module_name = self.options.module_name
        
        for hostname in sorted(results['contacted']):
            result    = results['contacted'][hostname]
            
            # TODO: refactor
            rc        = 0
            msg       = ''
            failed    = False
            stdout    = None
            stderr    = None
            traceback = None
            if type(result) == dict:
                failed    = result.get('failed', 0)
                msg       = result.get('msg', '')
                if module_name == 'command':
                    # TODO: refactor
                    rc        = result.get('rc',0)
                    stdout    = result.get('stdout', '')
                    stderr    = result.get('stderr', '')
                    traceback = result.get('traceback', '')

            if options.one_line:
                # try to print everything on one line, but don't strip newlines
                # if the command output happend to be too long
                if module_name == 'command':
                    if not failed:
                        buf = ""(stdout) %s"" % stdout
                        if stderr.rstrip() != '':
                            buf = ""(stdout) %s (stderr) %s"" % (stdout,stderr)
                        print ""%s | rc=%s | %s"" % (
                            hostname, rc, buf
                        )
                    else:
                        print ""%s | (error) %s"" % (hostname, msg)
                else:
                    print ""%s | %s"" % (hostname, result)
            else:
                # summarize response from command in multiple lines
                buf = ''
                if module_name == 'command':
                    if not failed:
                        buf += ""%s | rc=%s >>\n"" % (hostname, rc)
                    else:
                        buf += ""%s | rc=%s | FAILED >>\n"" % (hostname, rc)
                    buf += stdout
                    if stderr:
                        buf += stderr
                    if msg:
                        buf += msg
                    print buf
                else:
                    if not failed:
                        buf += ""%s >>"" % hostname
                    else:
                        buf += ""%s | FAILED >>"" % hostname
                    buf += json.dumps(result, indent=4, sort_keys=True)
                    print buf
                if options.tree:
                    path = os.path.join(options.tree, hostname)
                    fd = open(path, ""w+"")
                    fd.write(buf)
                    fd.close()

        if len(results['dark'].keys()) > 0:
            print >> sys.stderr, ""*** Hosts which could not be contacted or did not respond: ***""
            failed_hosts = results['dark'].keys()
            for hostname in failed_hosts:
                print >> sys.stderr, ""%s:\n%s\n"" % (hostname, results['dark'][hostname])
            print """"

if __name__ == '__main__':
    cli = Cli()
    cli.output(cli.runner().run())
    
","@@ -170,6 +170,7 @@ class Cli(object):
                     else:
                         buf += ""%s | FAILED >>"" % hostname
                     buf += json.dumps(result, indent=4, sort_keys=True)
+                    print buf
                 if options.tree:
                     path = os.path.join(options.tree, hostname)
                     fd = open(path, ""w+"")
",code-fix,code-fix: Modify ansible: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9947444291734236,Minor,Minor,YES
e6a1acf756dcee1e23b6f0642563e2773fe7805d,"Let ""all"" be an alias for ""*"" in patterns, fix output bug on non-command execution, make clean now removes the build dir",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import traceback
import paramiko # non-core dependency
import ansible.constants as C 
import Queue

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if self.groups.has_key(subpattern):
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _execute_template(self, conn, host):
        ''' handler for template","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import traceback
import paramiko # non-core dependency
import ansible.constants as C 
import Queue

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if self.groups.has_key(subpattern):
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
               k, v = x.split(""="")
               options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return self._return_from_module(conn, host, result)

    def _exec","@@ -121,6 +121,8 @@ class Runner(object):
         subpatterns = pattern.split("";"")
         for subpattern in subpatterns:
             # the pattern could be a real glob
+            if subpattern == 'all':
+                return True
             if fnmatch.fnmatch(host_name, subpattern):
                 return True
             # or it could be a literal group name instead
",logic-fix,logic-fix: Modify runner.py: +2/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998211860656,0.9907112173887036,Minor,Minor,YES
e6a1acf756dcee1e23b6f0642563e2773fe7805d,"Let ""all"" be an alias for ""*"" in patterns, fix output bug on non-command execution, make clean now removes the build dir",library/facter,,,,unknown,unknown: Modify facter: +0/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.0,Minor,Major,NO
c57df6220bc71446349e20d527d77f1a386e8439,"Add pydoc to playbook binary, fix default types for playbook '.get()' call",bin/ansible-playbook,"#!/usr/bin/python -tt
# (C) 2012, Michael DeHaan, <michael.dehaan@gmail.com>

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser

def main(args):
    parser = OptionParser()
    parser.usage = ""ans-playbook playbook.yml ...""
    parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
        help='set the number of forks to start up')
    parser.add_option(""-m"", ""--module-path"", dest=""module_path"",
        help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
    options, args = parser.parse_args(args)

    if len(args) == 0:
       print >> sys.stderr, ""playbook path is a required argument""
       return 1

    for playbook in args:
        pb = ansible.playbook.PlayBook(
            playbook=playbook,
            module_path=options.module_path,
            forks=options.forks,
            verbose=True
        )
        pb.run()

    return 0


if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","#!/usr/bin/python -tt
# (C) 2012, Michael DeHaan, <michael.dehaan@gmail.com>

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

#######################################################

import sys
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser

#######################################################

def main(args):
    ''' run ansible-playbook operations '''

    # create parser for CLI options
    parser = OptionParser()
    parser.usage = ""ans-playbook playbook.yml ...""
    parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
        help='set the number of forks to start up')
    parser.add_option(""-m"", ""--module-path"", dest=""module_path"",
        help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
    options, args = parser.parse_args(args)

    if len(args) == 0:
       print >> sys.stderr, ""playbook path is a required argument""
       return 1

    # run all playbooks specified on the command line
    for playbook in args:
        pb = ansible.playbook.PlayBook(
            playbook=playbook,
            module_path=options.module_path,
            forks=options.forks,
            verbose=True
        )
        pb.run()

    return 0


if __name__ == ""__main__"":
    sys.exit(main(sys.argv[1:]))





","@@ -15,14 +15,20 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
+
+#######################################################
 
 import sys
 import ansible.playbook
 import ansible.constants as C
 from optparse import OptionParser
 
+#######################################################
+
 def main(args):
+    ''' run ansible-playbook operations '''
+
+    # create parser for CLI options
     parser = OptionParser()
     parser.usage = ""ans-playbook playbook.yml ...""
     parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
@@ -35,6 +41,7 @@ def main(args):
        print >> sys.stderr, ""playbook path is a required argument""
        return 1
 
+    # run all playbooks specified on the command line
     for playbook in args:
         pb = ansible.playbook.PlayBook(
             playbook=playbook,
",code-fix,code-fix: Modify ansible-playbook: +8/-1 lines,90.1385804127871,88.95237124466327,3,3,56,63,-1.1862091681238385,0,7,0.999314785003662,0.8777080680027387,Minor,Minor,YES
c57df6220bc71446349e20d527d77f1a386e8439,"Add pydoc to playbook binary, fix default types for playbook '.get()' call",lib/ansible/playbook.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _run_task(self, pattern=None, task=None, host_list=None, 
        remote_user=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        new_hosts = []
        for x in host_list:
            if not self.failures.has_key(x) and not self.dark.has_key(x):
                new_hosts.append(x)
        host_list = new_hosts

        # load the module name and parameters from the task
        # entry
        name    = task['name']
        action  = task['action']
        comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            if not conditional:
                print ""\nTASK: %s"" % (name)
            else:
                print ""\nNOTIFIED: %s"" % (name)

        # load up an appropriate ansible runner to
        # run the task in parallel

        runner = ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        )
        results = runner.run()

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark = results.get(""dark"", [])
        contacted = results.get(""contacted"", [])
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this part","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):
    ''' 
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self, 
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            } 
        return results

    def _run_task(self, pattern=None, task=None, host_list=None, 
        remote_user=None, handlers=None, conditional=False):
        ''' 
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        new_hosts = []
        for x in host_list:
            if not self.failures.has_key(x) and not self.dark.has_key(x):
                new_hosts.append(x)
        host_list = new_hosts

        # load the module name and parameters from the task
        # entry
        name    = task['name']
        action  = task['action']
        comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            if not conditional:
                print ""\nTASK: %s"" % (name)
            else:
                print ""\nNOTIFIED: %s"" % (name)

        # load up an appropriate ansible runner to
        # run the task in parallel

        runner = ansible.runner.Runner(
            pattern=pattern,
            module_name=module_name,
            module_args=module_args,
            host_list=host_list,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        )
        results = runner.run()

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark = results.get(""dark"", {})
        contacted = results.get(""contacted"", {})
        ok_hosts = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not self.dark.has_key(host):
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
            failed = False
            if module_name == ""command"":
                if results.get(""rc"", 0) != 0:
                    failed=True
            elif results.get(""failed"", 0) == 1:
                    failed=True
   
            if failed:
                if self.verbose:
                    print ""failure: [%s] => %s"" % (host, results)
                if not self.failures.has_key(host):
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]"" % host
                if not self.invocations.has_key(host):
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not self.changed.has_key(host):
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                         self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this part","@@ -161,8 +161,8 @@ class PlayBook(object):
         # summary information about successes and
         # failures.  TODO: split into subfunction
 
-        dark = results.get(""dark"", [])
-        contacted = results.get(""contacted"", [])
+        dark = results.get(""dark"", {})
+        contacted = results.get(""contacted"", {})
         ok_hosts = contacted.keys()
 
         for host, msg in dark.items():
",logic-fix,logic-fix: Modify playbook.py: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998807907104,0.9943149129305996,Minor,Minor,YES
6541f338dff3805881002c3f45a6dc0d27396505,"add pyflakes target & associated fixes.  Also decided to save JSON to --tree file so it can
be better used programatically.  May have to come up with another system of tree logging for
playbook if playbook decides to have tree logging.  Presumably not the highest priority.",Makefile,"#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

loc:
	sloccount lib library bin

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 -r --ignore=E501,E221,W291,W391,E302,E251,E203,W293,E231,E303,E201,E225 lib/ bin/

clean:
	rm -rf build
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

loc:
	sloccount lib library bin

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 -r --ignore=E501,E221,W291,W391,E302,E251,E203,W293,E231,E303,E201,E225 lib/ bin/

pyflakes:
	pyflakes lib/ansible/*.py

clean:
	rm -rf build
	find . -type f -name ""*.pyc"" -delete
	find . -type f -name ""*.pyo"" -delete
	find . -type f -name ""*~"" -delete
	find ./docs/ -type f -name ""*.xml"" -delete
	find . -type f -name ""#*"" -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","@@ -26,6 +26,9 @@ pep8:
 	@echo ""#############################################""
 	pep8 -r --ignore=E501,E221,W291,W391,E302,E251,E203,W293,E231,E303,E201,E225 lib/ bin/
 
+pyflakes:
+	pyflakes lib/ansible/*.py
+
 clean:
 	rm -rf build
 	find . -type f -name ""*.pyc"" -delete
",code-fix,code-fix: Modify Makefile: +3/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9998699426651,0.965132467366048,Minor,Minor,YES
6541f338dff3805881002c3f45a6dc0d27396505,"add pyflakes target & associated fixes.  Also decided to save JSON to --tree file so it can
be better used programatically.  May have to come up with another system of tree logging for
playbook if playbook decides to have tree logging.  Presumably not the highest priority.",bin/ansible,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

########################################################

try:
    import json
except ImportError:
    import simplejson as json
from optparse import OptionParser
import sys
import os
import getpass
import shlex
import ansible.runner
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser
from ansible.utils import *

########################################################

class Cli(object):
    ''' code behind bin/ansible '''
    
    # ----------------------------------------------     

    def __init__(self):
        pass

    # ----------------------------------------------     

    def parse(self):
        ''' create an options parser for bin/ansible '''

        parser = OptionParser(usage = 'ansible <host-pattern> [options]')
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
            help='number of parallel processes to use')
        parser.add_option(""-i"", ""--inventory-file"", dest=""inventory"",
           help=""inventory host file"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-k"", ""--ask-pass"", default=False, action=""store_true"",
            help=""ask for SSH password"")
        parser.add_option(""-M"", ""--module-path"", dest=""module_path"",
           help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-m"", ""--module-name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',
            help=""condense output"")
        parser.add_option('-t', '--tree', dest='tree', default=None,
            help=""log output to this directory"")
        parser.add_option('-T', '--timeout', default=C.DEFAULT_TIMEOUT, type='int',
            dest='timeout', help=""set the SSH timeout in seconds"")
        parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER,
            dest='remote_user', help='connect as this user')
        options, args = parser.parse_args()
        
        if len(args) == 0 or len(args) > 1:
            parser.print_help()
            sys.exit(1)
        return (options, args)   
    
    # ----------------------------------------------     
 
    def run(self, options, args):
        ''' use Runner lib to do SSH things '''

        pattern = args[0]
        sshpass = None
        if options.ask_pass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        return ansible.runner.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=shlex.split(options.module_args),
            remote_user=options.remote_user,
            remote_pass=sshpass,
            host_list=options.inventory,
            timeout=options.timeout,
            forks=options.forks,
            pattern=pattern,
            verbose=True,
        ).run()

    # ----------------------------------------------     

    def output(self, results, options, args):
        ''' summarize results from Runner '''

        if results is None:
           exit(""No hosts matched"")
        if options.tree:
            prepare_writeable_dir(options.tree)

        buf = '' 
        for hostname in contacted_hosts(results):
            msg = host_report_msg(
                hostname, 
                options.module_name, 
                contacted_host_result(results, hostname),
                options.one_line
            )
            if options.tree:
                write_tree_file(hostname, msg)
            buf += msg
            
        if has_dark_hosts(results):
            buf += dark_hosts_msg(results)

        print buf

########################################################

if __name__ == '__main__':
    cli = Cli()
    (options, args) = cli.parse()
    results = cli.run(options, args)
    cli.output(results, options, args)
    

","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

########################################################

try:
    import json
except ImportError:
    import simplejson as json
from optparse import OptionParser
import sys
import os
import getpass
import shlex
import ansible.runner
import ansible.playbook
import ansible.constants as C
from optparse import OptionParser
from ansible.utils import *

########################################################

class Cli(object):
    ''' code behind bin/ansible '''
    
    # ----------------------------------------------     

    def __init__(self):
        pass

    # ----------------------------------------------     

    def parse(self):
        ''' create an options parser for bin/ansible '''

        parser = OptionParser(usage = 'ansible <host-pattern> [options]')
        parser.add_option(""-a"", ""--args"", dest=""module_args"",
            help=""module arguments"", default=C.DEFAULT_MODULE_ARGS)
        parser.add_option('-f','--forks', dest='forks', default=C.DEFAULT_FORKS, type='int',
            help='number of parallel processes to use')
        parser.add_option(""-i"", ""--inventory-file"", dest=""inventory"",
           help=""inventory host file"", default=C.DEFAULT_HOST_LIST)
        parser.add_option(""-k"", ""--ask-pass"", default=False, action=""store_true"",
            help=""ask for SSH password"")
        parser.add_option(""-M"", ""--module-path"", dest=""module_path"",
           help=""path to module library"", default=C.DEFAULT_MODULE_PATH)
        parser.add_option(""-m"", ""--module-name"", dest=""module_name"",
            help=""module name to execute"", default=C.DEFAULT_MODULE_NAME)
        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',
            help=""condense output"")
        parser.add_option('-t', '--tree', dest='tree', default=None,
            help=""log output to this directory"")
        parser.add_option('-T', '--timeout', default=C.DEFAULT_TIMEOUT, type='int',
            dest='timeout', help=""set the SSH timeout in seconds"")
        parser.add_option('-u', '--user', default=C.DEFAULT_REMOTE_USER,
            dest='remote_user', help='connect as this user')
        options, args = parser.parse_args()
        
        if len(args) == 0 or len(args) > 1:
            parser.print_help()
            sys.exit(1)
        return (options, args)   
    
    # ----------------------------------------------     
 
    def run(self, options, args):
        ''' use Runner lib to do SSH things '''

        pattern = args[0]
        sshpass = None
        if options.ask_pass:
            sshpass = getpass.getpass(prompt=""SSH password: "")

        return ansible.runner.Runner(
            module_name=options.module_name,
            module_path=options.module_path,
            module_args=shlex.split(options.module_args),
            remote_user=options.remote_user,
            remote_pass=sshpass,
            host_list=options.inventory,
            timeout=options.timeout,
            forks=options.forks,
            pattern=pattern,
            verbose=True,
        ).run()

    # ----------------------------------------------     

    def output(self, results, options, args):
        ''' summarize results from Runner '''

        if results is None:
           exit(""No hosts matched"")
        if options.tree:
            prepare_writeable_dir(options.tree)

        buf = '' 
        for hostname in contacted_hosts(results):
            msg = host_report_msg(
                hostname, 
                options.module_name, 
                contacted_host_result(results, hostname),
                options.one_line
            )
            if options.tree:
                write_tree_file(options.tree, hostname, bigjson(results))
            buf += msg
            
        if has_dark_hosts(results):
            buf += dark_hosts_msg(results)

        print buf

########################################################

if __name__ == '__main__':
    cli = Cli()
    (options, args) = cli.parse()
    results = cli.run(options, args)
    cli.output(results, options, args)
    

","@@ -119,7 +119,7 @@ class Cli(object):
                 options.one_line
             )
             if options.tree:
-                write_tree_file(hostname, msg)
+                write_tree_file(options.tree, hostname, bigjson(results))
             buf += msg
             
         if has_dark_hosts(results):
",code-fix,code-fix: Modify ansible: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999999403953552,0.9888634803597528,Minor,Minor,YES
6541f338dff3805881002c3f45a6dc0d27396505,"add pyflakes target & associated fixes.  Also decided to save JSON to --tree file so it can
be better used programatically.  May have to come up with another system of tree logging for
playbook if playbook decides to have tree logging.  Presumably not the highest priority.",lib/ansible/playbook.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
from ansible.utils import *
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):

    '''
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self,
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            }
        return results

    def _prune_failed_hosts(self, host_list):
        new_hosts = []
        for x in host_list:
            if not x in self.failures and not x in self.dark:
                new_hosts.append(x)
        return new_hosts

    def _run_module(self, pattern, module, args, hosts, remote_user):
        ''' run a particular module step in a playbook '''
        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module,
            module_args=args,
            host_list=hosts,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        ).run()

    def _run_task(self, pattern=None, task=None, host_list=None,
        remote_user=None, handlers=None, conditional=False):
        '''
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        host_list = self._prune_failed_hosts(host_list)

        # load the module name and parameters from the task entry
        name    = task['name']
        action  = task['action']
        comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            print task_start_msg(name, conditional)

        # load up an appropriate ansible runner to
        # run the task in parallel
        results = self._run_module(pattern, module_name, 
            module_args, host_list, remote_user)

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark      = results.get(""dark"", {})
        contacted = results.get(""contacted"", {})
        ok_hosts  = contacted.keys()

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not host in self.dark:
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
   
            if is_failed(results):
                if self.verbose:
                    print ""failed: [%s] => %s\n"" % (host, smjson(results))
                if not host in self.failures:
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]\n"" % host
                if not host in self.invocations:
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not host in self.changed:
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                        self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern grou","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
from ansible.utils import *
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):

    '''
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self,
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            }
        return results

    def _prune_failed_hosts(self, host_list):
        new_hosts = []
        for x in host_list:
            if not x in self.failures and not x in self.dark:
                new_hosts.append(x)
        return new_hosts

    def _run_module(self, pattern, module, args, hosts, remote_user):
        ''' run a particular module step in a playbook '''
        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module,
            module_args=args,
            host_list=hosts,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        ).run()

    def _run_task(self, pattern=None, task=None, host_list=None,
        remote_user=None, handlers=None, conditional=False):
        '''
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        host_list = self._prune_failed_hosts(host_list)

        # load the module name and parameters from the task entry
        name    = task['name']
        action  = task['action']
        # comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            print task_start_msg(name, conditional)

        # load up an appropriate ansible runner to
        # run the task in parallel
        results = self._run_module(pattern, module_name, 
            module_args, host_list, remote_user)

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark      = results.get(""dark"", {})
        contacted = results.get(""contacted"", {})

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not host in self.dark:
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
   
            if is_failed(results):
                if self.verbose:
                    print ""failed: [%s] => %s\n"" % (host, smjson(results))
                if not host in self.failures:
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]\n"" % host
                if not host in self.invocations:
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not host in self.changed:
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                        self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern group

        for x in handlers:
     ","@@ -137,7 +137,7 @@ class PlayBook(object):
         # load the module name and parameters from the task entry
         name    = task['name']
         action  = task['action']
-        comment = task.get('comment', '')
+        # comment = task.get('comment', '')
 
         tokens = shlex.split(action)
         module_name = tokens[0]
@@ -167,7 +167,6 @@ class PlayBook(object):
 
         dark      = results.get(""dark"", {})
         contacted = results.get(""contacted"", {})
-        ok_hosts  = contacted.keys()
 
         for host, msg in dark.items():
             self.processed[host] = 1
",logic-fix,logic-fix: Modify playbook.py: +1/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.000000238418579,0.989932184779424,Minor,Minor,YES
6541f338dff3805881002c3f45a6dc0d27396505,"add pyflakes target & associated fixes.  Also decided to save JSON to --tree file so it can
be better used programatically.  May have to come up with another system of tree logging for
playbook if playbook decides to have tree logging.  Presumably not the highest priority.",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import traceback
import ansible.constants as C 
import Queue
import paramiko

################################################

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
                k, v = x.split(""="")
                options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko

################################################

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
                k, v = x.split(""="")
                options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return se","@@ -27,7 +27,6 @@ import fnmatch
 import multiprocessing
 import signal
 import os
-import traceback
 import ansible.constants as C 
 import Queue
 import paramiko
",code-fix,code-fix: Modify runner.py: +0/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999221563339232,0.9966829655008342,Minor,Minor,YES
6541f338dff3805881002c3f45a6dc0d27396505,"add pyflakes target & associated fixes.  Also decided to save JSON to --tree file so it can
be better used programatically.  May have to come up with another system of tree logging for
playbook if playbook decides to have tree logging.  Presumably not the highest priority.",lib/ansible/utils.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

###############################################################

import sys
try:
    import json
except ImportError:
    import simplejson as json

###############################################################
# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS
###############################################################

def err(msg):
    ''' print an error message to stderr '''
    print >> sys.stderr, msg

def exit(msg, rc=1):
    ''' quit with an error to stdout and a failure code '''
    err(msg)
    sys.exit(rc)

def bigjson(result):
    ''' format JSON output (uncompressed) '''
    return json.dumps(result, sort_keys=True, indent=4)

def smjson(result):
    ''' format JSON output (compressed) '''
    return json.dumps(result, sort_keys=True)

def task_start_msg(name, conditional):
    if conditional:
        return ""NOTIFIED: [%s] **********\n"" % name
    else:
        return ""TASK: [%s] *********\n"" % name

def regular_generic_msg(hostname, result, oneline, caption):
    ''' output on the result of a module run that is not command '''
    if not oneline:
        return ""%s | %s >>\n%s"" % (hostname, caption, bigjson(result))
    else:
        return ""%s | %s >> %s"" % (hostname, caption, smjson(result))

def regular_success_msg(hostname, result, oneline):
    ''' output the result of a successful module run '''
    return regular_generic_msg(hostname, result, oneline, 'success')

def regular_failure_msg(hostname, result, oneline):
    ''' output the result of a failed module run '''
    return regular_generic_msg(hostname, result, oneline, 'FAILED')

def command_generic_msg(hostname, result, oneline, caption):
    ''' output the result of a command run '''
    rc     = result.get('rc', '0')
    stdout = result.get('stdout','')
    stderr = result.get('stderr', '')
    msg    = result.get('msg', '')
    if not oneline:
        buf = ""%s | %s | rc=%s >>\n"" % (hostname, caption, result.get('rc',0))
        if stdout:
            buf += stdout
        if stderr:
            buf += stderr
        if msg:
            buf += msg
        return buf
    else:
        if stderr:
            return ""%s | %s | rc=%s | (stdout) %s (stderr) %s"" % (hostname, caption, rc, stdout, stderr)
        else:
            return ""%s | %s | rc=%s | (stdout) %s"" % (hostname, caption, rc, stdout)

def command_success_msg(hostname, result, oneline):
    ''' output from a successful command run '''
    return command_generic_msg(hostname, result, oneline, 'success')

def command_failure_msg(hostname, result, oneline):
    ''' output from a failed command run '''
    return command_generic_msg(hostname, result, oneline, 'FAILED')

def write_tree_file(hostname,buf):
    ''' write something into treedir/hostname '''
    # TODO: might be nice to append playbook runs per host in a similar way
    # in which case, we'd want append mode.
    path = os.path.join(options.tree, hostname)
    fd = open(path, ""w+"")
    fd.write(buf)
    fd.close()

def is_failed(result):
    ''' is a given JSON result a failed result? '''
    failed = False
    rc = 0
    if type(result) == dict:
        failed = result.get('failed', 0)
        rc     = result.get('rc', 0)
    if rc != 0:
        return True    
    return failed

def host_report_msg(hostname, module_name, result, oneline):
    ''' summarize the JSON results for a particular host '''
    buf = ''
    failed = is_failed(result)
    if module_name == 'command':
        if not failed:
            buf = command_success_msg(hostname, result, oneline)
        else:
            buf = command_failure_msg(hostname, result, oneline)
    else:
        if not failed:
            buf = regular_success_msg(hostname, result, oneline)
        else:
            buf = regular_failure_msg(hostname, result, oneline)
    return buf

def dark_hosts_msg(results):
    ''' summarize the results of all uncontactable hosts '''
    buf = ''
    if len(results['dark'].keys()) > 0:
        buf += ""*** Hosts which could not be contacted or did not respond: ***""
        for hostname in results['dark'].keys():
            buf += ""%s:\n%s\n"" % (hostname, results['dark'][hostname])
    buf += ""\n""
    return buf

def has_dark_hosts(results):
    ''' are there any uncontactable hosts? '''
    return len(results['dark'].keys()) > 0

def contacted_hosts(results):
    ''' what are the contactable hosts? '''
    return sorted(results['contacted'])

def contacted_host_result(results, hostname):
    ''' what are the results for a given host? '''
    return results['contacted'][hostname]

def prepare_writeable_dir(tree):
    ''' make sure a directory exists and is writeable '''
    if tree != '/':
        tree = os.path.realpath(os.path.expanduser(options.tree))
    if not os.path.exists(tree):
        try:
            os.makedirs(tree)
        except (IOError, OSError), e:
            exit(""Could not make dir %s: %s"" % (tree, e))
    if not os.access(tree, os.W_OK):
        exit(""Cannot write to path %s"" % tree)


","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

###############################################################

import sys
import os
try:
    import json
except ImportError:
    import simplejson as json

###############################################################
# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS
###############################################################

def err(msg):
    ''' print an error message to stderr '''
    print >> sys.stderr, msg

def exit(msg, rc=1):
    ''' quit with an error to stdout and a failure code '''
    err(msg)
    sys.exit(rc)

def bigjson(result):
    ''' format JSON output (uncompressed) '''
    return json.dumps(result, sort_keys=True, indent=4)

def smjson(result):
    ''' format JSON output (compressed) '''
    return json.dumps(result, sort_keys=True)

def task_start_msg(name, conditional):
    if conditional:
        return ""NOTIFIED: [%s] **********\n"" % name
    else:
        return ""TASK: [%s] *********\n"" % name

def regular_generic_msg(hostname, result, oneline, caption):
    ''' output on the result of a module run that is not command '''
    if not oneline:
        return ""%s | %s >>\n%s"" % (hostname, caption, bigjson(result))
    else:
        return ""%s | %s >> %s"" % (hostname, caption, smjson(result))

def regular_success_msg(hostname, result, oneline):
    ''' output the result of a successful module run '''
    return regular_generic_msg(hostname, result, oneline, 'success')

def regular_failure_msg(hostname, result, oneline):
    ''' output the result of a failed module run '''
    return regular_generic_msg(hostname, result, oneline, 'FAILED')

def command_generic_msg(hostname, result, oneline, caption):
    ''' output the result of a command run '''
    rc     = result.get('rc', '0')
    stdout = result.get('stdout','')
    stderr = result.get('stderr', '')
    msg    = result.get('msg', '')
    if not oneline:
        buf = ""%s | %s | rc=%s >>\n"" % (hostname, caption, result.get('rc',0))
        if stdout:
            buf += stdout
        if stderr:
            buf += stderr
        if msg:
            buf += msg
        return buf
    else:
        if stderr:
            return ""%s | %s | rc=%s | (stdout) %s (stderr) %s"" % (hostname, caption, rc, stdout, stderr)
        else:
            return ""%s | %s | rc=%s | (stdout) %s"" % (hostname, caption, rc, stdout)

def command_success_msg(hostname, result, oneline):
    ''' output from a successful command run '''
    return command_generic_msg(hostname, result, oneline, 'success')

def command_failure_msg(hostname, result, oneline):
    ''' output from a failed command run '''
    return command_generic_msg(hostname, result, oneline, 'FAILED')

def write_tree_file(tree, hostname, buf):
    ''' write something into treedir/hostname '''
    # TODO: might be nice to append playbook runs per host in a similar way
    # in which case, we'd want append mode.
    path = os.path.join(tree, hostname)
    fd = open(path, ""w+"")
    fd.write(buf)
    fd.close()

def is_failed(result):
    ''' is a given JSON result a failed result? '''
    failed = False
    rc = 0
    if type(result) == dict:
        failed = result.get('failed', 0)
        rc     = result.get('rc', 0)
    if rc != 0:
        return True    
    return failed

def host_report_msg(hostname, module_name, result, oneline):
    ''' summarize the JSON results for a particular host '''
    buf = ''
    failed = is_failed(result)
    if module_name == 'command':
        if not failed:
            buf = command_success_msg(hostname, result, oneline)
        else:
            buf = command_failure_msg(hostname, result, oneline)
    else:
        if not failed:
            buf = regular_success_msg(hostname, result, oneline)
        else:
            buf = regular_failure_msg(hostname, result, oneline)
    return buf

def dark_hosts_msg(results):
    ''' summarize the results of all uncontactable hosts '''
    buf = ''
    if len(results['dark'].keys()) > 0:
        buf += ""*** Hosts which could not be contacted or did not respond: ***""
        for hostname in results['dark'].keys():
            buf += ""%s:\n%s\n"" % (hostname, results['dark'][hostname])
    buf += ""\n""
    return buf

def has_dark_hosts(results):
    ''' are there any uncontactable hosts? '''
    return len(results['dark'].keys()) > 0

def contacted_hosts(results):
    ''' what are the contactable hosts? '''
    return sorted(results['contacted'])

def contacted_host_result(results, hostname):
    ''' what are the results for a given host? '''
    return results['contacted'][hostname]

def prepare_writeable_dir(tree):
    ''' make sure a directory exists and is writeable '''
    if tree != '/':
        tree = os.path.realpath(os.path.expanduser(tree))
    if not os.path.exists(tree):
        try:
            os.makedirs(tree)
        except (IOError, OSError), e:
            exit(""Could not make dir %s: %s"" % (tree, e))
    if not os.access(tree, os.W_OK):
        exit(""Cannot write to path %s"" % tree)


","@@ -18,6 +18,7 @@
 ###############################################################
 
 import sys
+import os
 try:
     import json
 except ImportError:
@@ -94,11 +95,11 @@ def command_failure_msg(hostname, result, oneline):
     ''' output from a failed command run '''
     return command_generic_msg(hostname, result, oneline, 'FAILED')
 
-def write_tree_file(hostname,buf):
+def write_tree_file(tree, hostname, buf):
     ''' write something into treedir/hostname '''
     # TODO: might be nice to append playbook runs per host in a similar way
     # in which case, we'd want append mode.
-    path = os.path.join(options.tree, hostname)
+    path = os.path.join(tree, hostname)
     fd = open(path, ""w+"")
     fd.write(buf)
     fd.close()
@@ -155,7 +156,7 @@ def contacted_host_result(results, hostname):
 def prepare_writeable_dir(tree):
     ''' make sure a directory exists and is writeable '''
     if tree != '/':
-        tree = os.path.realpath(os.path.expanduser(options.tree))
+        tree = os.path.realpath(os.path.expanduser(tree))
     if not os.path.exists(tree):
         try:
             os.makedirs(tree)
",logic-fix,logic-fix: Modify utils.py: +4/-3 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999576807022096,0.981330539900964,Minor,Minor,YES
e4304a0ac5ef777832a2f4db8899507d0d0dfacc,"Make sure tempdirs are cleaned up after execution steps, fix notifiers, make sure
service module is installed by setup.py",examples/playbook.yml,"---
- hosts: '*'
  tasks:
  - name: configure template & module variables for future template calls
    action: setup http_port=80 max_clients=200
  - name: write the apache config file
    action: template src=/srv/httpd.j2 dest=/etc/httpd/conf
    notify:
    - restart apache
  - name: ensure apache is running
    action: service name=httpd state=started
  handlers:
    - name: restart apache
    - action: service name=httpd state=restarted
","---
- hosts: '*'
  tasks:
  - name: configure template & module variables for future template calls
    action: setup http_port=80 max_clients=200
  - name: write the apache config file
    action: template src=/srv/httpd.j2 dest=/etc/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running
    action: service name=httpd state=started
  handlers:
    - name: restart apache
    - action: service name=httpd state=restarted
","@@ -4,7 +4,7 @@
   - name: configure template & module variables for future template calls
     action: setup http_port=80 max_clients=200
   - name: write the apache config file
-    action: template src=/srv/httpd.j2 dest=/etc/httpd/conf
+    action: template src=/srv/httpd.j2 dest=/etc/httpd.conf
     notify:
     - restart apache
   - name: ensure apache is running
",config-fix,config-fix: Modify playbook.yml: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999669194221495,0.9525618205602056,Minor,Minor,YES
e4304a0ac5ef777832a2f4db8899507d0d0dfacc,"Make sure tempdirs are cleaned up after execution steps, fix notifiers, make sure
service module is installed by setup.py",lib/ansible/playbook.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
from ansible.utils import *
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):

    '''
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self,
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            }
        return results

    def _prune_failed_hosts(self, host_list):
        new_hosts = []
        for x in host_list:
            if not x in self.failures and not x in self.dark:
                new_hosts.append(x)
        return new_hosts

    def _run_module(self, pattern, module, args, hosts, remote_user):
        ''' run a particular module step in a playbook '''
        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module,
            module_args=args,
            host_list=hosts,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        ).run()

    def _run_task(self, pattern=None, task=None, host_list=None,
        remote_user=None, handlers=None, conditional=False):
        '''
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        host_list = self._prune_failed_hosts(host_list)

        # load the module name and parameters from the task entry
        name    = task['name']
        action  = task['action']
        # comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            print task_start_msg(name, conditional)

        # load up an appropriate ansible runner to
        # run the task in parallel
        results = self._run_module(pattern, module_name, 
            module_args, host_list, remote_user)

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark      = results.get(""dark"", {})
        contacted = results.get(""contacted"", {})

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not host in self.dark:
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
   
            if is_failed(results):
                if self.verbose:
                    print ""failed: [%s] => %s\n"" % (host, smjson(results))
                if not host in self.failures:
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]\n"" % host
                if not host in self.invocations:
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not host in self.changed:
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                        self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern group

        for x in handlers:
     ","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

import ansible.runner
import ansible.constants as C
from ansible.utils import *
import yaml
import shlex

# TODO: make a constants file rather than
# duplicating these

class PlayBook(object):

    '''
    runs an ansible playbook, given as a datastructure
    or YAML filename.  a playbook is a deployment, config
    management, or automation based set of commands to
    run in series.

    multiple patterns do not execute simultaneously,
    but tasks in each pattern do execute in parallel
    according to the number of forks requested.
    '''

    def __init__(self,
        playbook     =None,
        host_list    =C.DEFAULT_HOST_LIST,
        module_path  =C.DEFAULT_MODULE_PATH,
        forks        =C.DEFAULT_FORKS,
        timeout      =C.DEFAULT_TIMEOUT,
        remote_user  =C.DEFAULT_REMOTE_USER,
        remote_pass  =C.DEFAULT_REMOTE_PASS,
        verbose=False):

        # TODO, once ansible-playbook is it's own script this will
        # have much LESS parameters to the constructor and will
        # read most everything per pattern from the playbook
        # and this will be greatly simplified

        self.host_list   = host_list
        self.module_path = module_path
        self.forks       = forks
        self.timeout     = timeout
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.verbose     = verbose

        # store the list of changes/invocations/failure counts
        # as a dictionary of integers keyed off the hostname

        self.processed    = {}
        self.dark         = {}
        self.changed      = {}
        self.invocations  = {}
        self.failures     = {}

        # playbook file can be passed in as a path or
        # as file contents (to support API usage)

        if type(playbook) == str:
            playbook = yaml.load(file(playbook).read())
        self.playbook = playbook
        
    def run(self):
        ''' run all patterns in the playbook '''

        # loop through all patterns and run them
        for pattern in self.playbook:
            self._run_pattern(pattern)
        if self.verbose:
            print ""\n""

        # summarize the results
        results = {}
        for host in self.processed.keys():
            results[host]  = {
                'resources'   : self.invocations.get(host, 0),
                'changed'     : self.changed.get(host, 0),
                'dark'        : self.dark.get(host, 0),
                'failed'      : self.failures.get(host, 0)
            }
        return results

    def _prune_failed_hosts(self, host_list):
        new_hosts = []
        for x in host_list:
            if not x in self.failures and not x in self.dark:
                new_hosts.append(x)
        return new_hosts

    def _run_module(self, pattern, module, args, hosts, remote_user):
        ''' run a particular module step in a playbook '''
        return ansible.runner.Runner(
            pattern=pattern,
            module_name=module,
            module_args=args,
            host_list=hosts,
            forks=self.forks,
            remote_pass=self.remote_pass,
            module_path=self.module_path,
            timeout=self.timeout,
            remote_user=remote_user
        ).run()

    def _run_task(self, pattern=None, task=None, host_list=None,
        remote_user=None, handlers=None, conditional=False):
        '''
        run a single task in the playbook and
        recursively run any subtasks.
        '''

        if host_list is None:
            # pruned host lists occur when running triggered
            # actions where not all hosts have changed
            # though top-level tasks will pass in ""None"" here
            host_list = self.host_list
            (host_list, groups) = ansible.runner.Runner.parse_hosts(host_list)

        # do not continue to run tasks on hosts that have had failures
        host_list = self._prune_failed_hosts(host_list)

        # load the module name and parameters from the task entry
        name    = task['name']
        action  = task['action']
        # comment = task.get('comment', '')

        tokens = shlex.split(action)
        module_name = tokens[0]
        module_args = tokens[1:]

        # tasks can be direct (run on all nodes matching
        # the pattern) or conditional, where they ran
        # as the result of a change handler on a subset
        # of all of the hosts

        if self.verbose:
            print task_start_msg(name, conditional)

        # load up an appropriate ansible runner to
        # run the task in parallel
        results = self._run_module(pattern, module_name, 
            module_args, host_list, remote_user)

        # if no hosts are matched, carry on, unlike /bin/ansible
        # which would warn you about this
        if results is None:
            results = {}
 
        # walk through the results and build up
        # summary information about successes and
        # failures.  TODO: split into subfunction

        dark      = results.get(""dark"", {})
        contacted = results.get(""contacted"", {})

        for host, msg in dark.items():
            self.processed[host] = 1
            if self.verbose:
                print ""unreachable: [%s] => %s"" % (host, msg)
            if not host in self.dark:
                self.dark[host] = 1
            else:
                self.dark[host] = self.dark[host] + 1

        for host, results in contacted.items():
            self.processed[host] = 1
   
            if is_failed(results):
                if self.verbose:
                    print ""failed: [%s] => %s\n"" % (host, smjson(results))
                if not host in self.failures:
                    self.failures[host] = 1
                else:
                    self.failures[host] = self.failures[host] + 1
            else:
                if self.verbose:
                    print ""ok: [%s]\n"" % host
                if not host in self.invocations:
                    self.invocations[host] = 1
                else:
                    self.invocations[host] = self.invocations[host] + 1
                if results.get('changed', False):
                    if not host in self.changed:
                        self.changed[host] = 1
                    else:
                        self.changed[host] = self.changed[host] + 1

        # flag which notify handlers need to be run
        # this will be on a SUBSET of the actual host list.  For instance
        # a file might need to be written on only half of the nodes so
        # we would only trigger restarting Apache on half of the nodes

        subtasks = task.get('notify', [])
        if len(subtasks) > 0:
            for host, results in contacted.items():
                if results.get('changed', False):
                    for subtask in subtasks:
                        self._flag_handler(handlers, subtask, host)

    def _flag_handler(self, handlers, match_name, host):
        ''' 
        if a task has any notify elements, flag handlers for run
        at end of execution cycle for hosts that have indicated
        changes have been made
        '''

        # for all registered handlers in the ansible playbook
        # for this particular pattern group

        for x in handlers:
     ","@@ -223,8 +223,7 @@ class PlayBook(object):
         # for this particular pattern group
 
         for x in handlers:
-            attribs = x[""do""]
-            name = attribs[0]
+            name = x['name']
             if match_name == name:
                 # flag the handler with the list of hosts
                 # it needs to be run on, it will be run later
",logic-fix,logic-fix: Modify playbook.py: +1/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.000000238418579,1.0,Minor,Minor,YES
e4304a0ac5ef777832a2f4db8899507d0d0dfacc,"Make sure tempdirs are cleaned up after execution steps, fix notifiers, make sure
service module is installed by setup.py",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko

################################################

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        # disconnect from paramiko/SSH
        conn.close()
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -f %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ outpath ])
        return result

    def _execute_normal_module(self, conn, host):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn)
        result = self._execute_module(conn, module)
        return self._return_from_module(conn, host, result)

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
                k, v = x.split(""="")
                options[k]=v
        return options

    def _execute_copy(self, conn, host):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = self._get_tmp_path(conn)
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module)
        self._delete_remote_files(conn, tmp_src)
        return se","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko

################################################

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        subpatterns = pattern.split("";"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        for filename in files:
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, outpath, tmp):
        ''' 
        runs a module that has already been transferred
        '''
        cmd = self._command(outpath)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp)
        result = self._execute_module(conn, module, tmp)
        self._delete_remote_files(conn, tmp)
        result = self._return_from_module(conn, host, result)
        return result

    def _parse_kv(self, args):
        ''' helper function to convert a string of key/value items to a dict '''
        options = {}
        for x in args:
            if x.find(""="") != -1:
                k, v = x.split(""="")
                options[k]=v
        return options

    def _execute_copy(self, conn, host, tmp):
        ''' handler for file transfer operations '''

        # load up options
        options = self._parse_kv(self.module_args)
        source = options['src']
        dest   = options['dest']
        
        # transfer the file to a remote tmp location
        tmp_path = tmp
        tmp_src = tmp_path + source.split('/')[-1]
        self._transfer_file(conn, source, tmp_src)

        # install the copy  module
        self.module_name = 'copy'
        module = self._transfer_module(conn)

        # run the copy module
        self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
        result = self._execute_module(conn, module, tmp)
        self._delete_remote_files(conn, t","@@ -153,8 +153,6 @@ class Runner(object):
 
     def _return_from_module(self, conn, host, result):
         ''' helper function to handle JSON parsing of results '''
-        # disconnect from paramiko/SSH
-        conn.close()
         try:
             # try to parse the JSON response
             return [ host, True, json.loads(result) ]
@@ -165,7 +163,7 @@ class Runner(object):
     def _delete_remote_files(self, conn, files):
         ''' deletes one or more remote files '''
         for filename in files:
-            self._exec_command(conn, ""rm -f %s"" % filename)
+            self._exec_command(conn, ""rm -rf %s"" % filename)
 
     def _transfer_file(self, conn, source, dest):
         ''' transfers a remote file '''
@@ -174,32 +172,34 @@ class Runner(object):
         sftp.put(source, dest)
         sftp.close()
 
-    def _transfer_module(self, conn):
+    def _transfer_module(self, conn, tmp):
         ''' 
         transfers a module file to the remote side to execute it,
         but does not execute it yet
         '''
-        outpath = self._copy_module(conn)
+        outpath = self._copy_module(conn, tmp)
         self._exec_command(conn, ""chmod +x %s"" % outpath)
         return outpath
 
-    def _execute_module(self, conn, outpath):
+    def _execute_module(self, conn, outpath, tmp):
         ''' 
         runs a module that has already been transferred
         '''
         cmd = self._command(outpath)
         result = self._exec_command(conn, cmd)
-        self._delete_remote_files(conn, [ outpath ])
+        self._delete_remote_files(conn, [ tmp ])
         return result
 
-    def _execute_normal_module(self, conn, host):
+    def _execute_normal_module(self, conn, host, tmp):
         ''' 
         transfer & execute a module that is not 'copy' or 'template'
         because those require extra work.
         '''
-        module = self._transfer_module(conn)
-        result = self._execute_module(conn, module)
-        return self._return_from_module(conn, host, result)
+        module = self._transfer_module(conn, tmp)
+        result = self._execute_module(conn, module, tmp)
+        self._delete_remote_files(conn, tmp)
+        result = self._return_from_module(conn, host, result)
+        return result
 
     def _parse_kv(self, args):
         ''' helper function to convert a string of key/value items to a dict '''
@@ -210,7 +210,7 @@ class Runner(object):
                 options[k]=v
         return options
 
-    def _execute_copy(self, conn, host):
+    def _execute_copy(self, conn, host, tmp):
         ''' handler for file transfer operations '''
 
         # load up options
@@ -219,7 +219,7 @@ class Runner(object):
         dest   = options['dest']
         
         # transfer the file to a remote tmp location
-        tmp_path = self._get_tmp_path(conn)
+        tmp_path = tmp
         tmp_src = tmp_path + source.split('/')[-1]
         self._transfer_file(conn, source, tmp_src)
 
@@ -229,11 +229,11 @@ class Runner(object):
 
         # run the copy module
         self.module_args = [ ""src=%s"" % tmp_src, ""dest=%s"" % dest ]
-        result = self._execute_module(conn, module)
-        self._delete_remote_files(conn, tmp_src)
+        result = self._execute_module(conn, module, tmp)
+        self._delete_remote_files(conn, tmp_path)
         return self._return_from_module(conn, host, result)
 
-    def _execute_template(self, conn, host):
+    def _execute_template(self, conn, host, tmp):
         ''' handler for template operations '''
 
         # load up options
@@ -243,18 +243,19 @@ class Runner(object):
         metadata = options.get('metadata', '/etc/ansible/setup')
 
         # first copy the source template over
+        tpath = tmp
         tempname = os.path.split(source)[-1]
-        temppath = self._get_tmp_path(conn) + tempname
+        temppath = tpath + tempname
         self._transfer_file(conn, source, temppath)
 
         # install the template module
         self.module_name = 'template'
-        module = self._transfer_module(conn)
+        module = self._transfer_module(conn, tmp)
 
         # run the template module
         self.module_args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
-        result = self._execute_module(conn, module)
-        self._delete_remote_files(conn, [ temppath ])
+        result = self._execute_module(conn, module, tmp)
+        self._delete_remote_files(conn, [ tpath ])
         return self._return_from_module(conn, host, result)
 
 
@@ -271,18 +272,24 @@ class Runner(object):
         # module, call the appropriate executor function
 
         ok, conn = self._connect(host)
+        tmp = self._get_tmp_path(conn)
+        result = None
         if not ok:
-            return [ host, False, conn ]
+            result = [ host, False, conn ]
         if self.module_name not in [ 'copy', 'template' ]:
-            return self._execute_normal_module(conn, host)
+            result = self._execute_normal_module(conn, host, tmp)
         elif self.module_name == 'copy':
-            return self._execute_copy(conn, host)
+            result = self._execute_copy(conn, host, tmp)
         elif self.module_name == 'template':
-            return self._execute_template(conn, host)
+            result = self._execute_template(conn, host, tmp)
         else:
             # this would be a coding error in THIS module
             # shouldn't occur
             raise Exception(""???"")
+        self._delete_remote_files(conn, tmp)
+        conn.close()
+        return result
+
 
     def _command(self, outpath):
         ''' form up a command string for running over SSH '''
@@ -304,19 +311,15 @@ class Runner(object):
 
     def _get_tmp_path(self, conn):
         ''' gets a temporary path on a remote box '''
+        result = self._exec_command(conn, ""mktemp -d /tmp/ansible.XXXXXX"")
+        return result.split(""\n"")[0] + '/'
 
-        if conn not in self._tmp_paths:
-            output = self._exec_command(conn, ""mktemp -d /tmp/ansible.XXXXXX"")
-            self._tmp_paths[conn] = output.split(""\n"")[0] + '/'
-            
-        return self._tmp_paths[conn]
-
-    def _copy_module(self, conn):
+    def _copy_module(self, conn, tmp):
         ''' transfer a module over SFTP, does not run it '''
         in_path = os.path.expanduser(
             os.path.join(self.module_path, self.module_name)
         )
-        out_path = self._get_tmp_path(conn) + self.module_name
+        out_path = tmp + self.module_name
         sftp = conn.open_sftp()
         sftp.put(in_path, out_path)
         sftp.close()
",logic-fix,logic-fix: Modify runner.py: +35/-32 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.946564325240285,Minor,Minor,YES
e4304a0ac5ef777832a2f4db8899507d0d0dfacc,"Make sure tempdirs are cleaned up after execution steps, fix notifiers, make sure
service module is installed by setup.py",setup.py,"#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/ohai',
             'library/copy',
             'library/setup',
             'library/template',
             'library/git',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
         'bin/ansible-playbook'
      ]
)
","#!/usr/bin/env python

from distutils.core import setup

setup(name='ansible',
      version='1.0',
      description='Minimal SSH command and control',
      author='Michael DeHaan',
      author_email='michael.dehaan@gmail.com',
      url='http://github.com/mpdehaan/ansible/',
      license='MIT',
      package_dir = { 'ansible' : 'lib/ansible' },
      packages=[
         'ansible',
      ],
      data_files=[ 
         ('/usr/share/ansible', [ 
             'library/ping',
             'library/command',
             'library/facter',
             'library/ohai',
             'library/copy',
             'library/setup',
             'library/service',
             'library/template',
             'library/git',
         ]),
         ('man/man1', [
                'docs/man/man1/ansible.1'
         ]),
         ('man/man5', [
                'docs/man/man5/ansible-modules.5',
                'docs/man/man5/ansible-playbook.5'
         ])
      ],
      scripts=[
         'bin/ansible',
         'bin/ansible-playbook'
      ]
)
","@@ -21,6 +21,7 @@ setup(name='ansible',
              'library/ohai',
              'library/copy',
              'library/setup',
+             'library/service',
              'library/template',
              'library/git',
          ]),
",build-fix,build-fix: Modify setup.py: +1/-0 lines,100.0,100.0,0,0,39,40,0.0,0,1,0.9995800852775574,0.9534460356445504,Minor,Minor,YES
8e07d83ad1869407617d50d2c92e4de18b8450db,"Async module, mostly operational, daemonizing/watch code may have bugs",library/async_wrapper,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

print sys.argv

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        subprocess.call(""/usr/bin/logger %s"" % wrapped_cmd, shell=True)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# TODO: daemonize this with time limits
# TODO: might be nice to keep timing data, eventually...


pid = os.fork()
if pid == 0:
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:

   # FIXME: need to implement time limits
   # probably something easy like:
   #
   #   sub_pid = os.fork()
   #   if sub_pid == 0:
   #      run command
   #   else
   #      check status
   #      sleep 1 second
   #      kill if greater than timelimit

   _run_command(cmd, jid, log_path)
   sys.exit(0)


","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback
import signal
import time

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

print sys.argv

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# immediately exit this process, leaving an orphaned process
# running which immediately forks a supervisory timing process

pid = os.fork()
if pid == 0:
   print ""RETURNING SUCCESS IN UNO""
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:
   print ""DAEMONIZED DOS""
   sub_pid = os.fork()
   if sub_pid == 0:
       print ""RUNNING IN KID A""
       _run_command(cmd, jid, log_path)
       sys.exit(0)
   else:
       print ""WATCHING IN KID B""
       remaining = int(time_limit)
       if os.path.exists(""/proc/%s"" % sub_pid):
           print ""STILL RUNNING""
           time.sleep(1)
           remaining = remaining - 1
       else:
           print ""DONE IN KID B""
           sys.exit(0)
       if remaining == 0:
           print ""SLAYING IN KID B""
           os.kill(sub_pid, signals.SIGKILL)
           sys.exit(1)

   sys.exit(0)


","@@ -28,6 +28,8 @@ import subprocess
 import sys
 import datetime
 import traceback
+import signal
+import time
 
 if len(sys.argv) < 3:
     print json.dumps({
@@ -66,7 +68,6 @@ def _run_command(wrapped_cmd, jid, log_path):
 
     try:
         cmd = shlex.split(wrapped_cmd)
-        subprocess.call(""/usr/bin/logger %s"" % wrapped_cmd, shell=True)
         script = subprocess.Popen(cmd, shell=False, 
             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         out, err = script.communicate()
@@ -90,28 +91,36 @@ def _run_command(wrapped_cmd, jid, log_path):
     logfile.write(json.dumps(result))
     logfile.close()
 
-# TODO: daemonize this with time limits
-# TODO: might be nice to keep timing data, eventually...
-
+# immediately exit this process, leaving an orphaned process
+# running which immediately forks a supervisory timing process
 
 pid = os.fork()
 if pid == 0:
+   print ""RETURNING SUCCESS IN UNO""
    print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
    sys.exit(0)
 else:
+   print ""DAEMONIZED DOS""
+   sub_pid = os.fork()
+   if sub_pid == 0:
+       print ""RUNNING IN KID A""
+       _run_command(cmd, jid, log_path)
+       sys.exit(0)
+   else:
+       print ""WATCHING IN KID B""
+       remaining = int(time_limit)
+       if os.path.exists(""/proc/%s"" % sub_pid):
+           print ""STILL RUNNING""
+           time.sleep(1)
+           remaining = remaining - 1
+       else:
+           print ""DONE IN KID B""
+           sys.exit(0)
+       if remaining == 0:
+           print ""SLAYING IN KID B""
+           os.kill(sub_pid, signals.SIGKILL)
+           sys.exit(1)
 
-   # FIXME: need to implement time limits
-   # probably something easy like:
-   #
-   #   sub_pid = os.fork()
-   #   if sub_pid == 0:
-   #      run command
-   #   else
-   #      check status
-   #      sleep 1 second
-   #      kill if greater than timelimit
-
-   _run_command(cmd, jid, log_path)
    sys.exit(0)
 
 
",code-fix,code-fix: Modify async_wrapper: +25/-16 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.99955815076828,0.7913519630541752,Minor,Minor,YES
6a0b79357897e88fe1acddd657cb6641eb1d86cd,Remove debug comments,library/async_wrapper,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback
import signal
import time

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

print sys.argv

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# immediately exit this process, leaving an orphaned process
# running which immediately forks a supervisory timing process

pid = os.fork()
if pid == 0:
   print ""RETURNING SUCCESS IN UNO""
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:
   print ""DAEMONIZED DOS""
   sub_pid = os.fork()
   if sub_pid == 0:
       print ""RUNNING IN KID A""
       _run_command(cmd, jid, log_path)
       sys.exit(0)
   else:
       print ""WATCHING IN KID B""
       remaining = int(time_limit)
       if os.path.exists(""/proc/%s"" % sub_pid):
           print ""STILL RUNNING""
           time.sleep(1)
           remaining = remaining - 1
       else:
           print ""DONE IN KID B""
           sys.exit(0)
       if remaining == 0:
           print ""SLAYING IN KID B""
           os.kill(sub_pid, signals.SIGKILL)
           sys.exit(1)

   sys.exit(0)


","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback
import signal
import time

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

print sys.argv

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# immediately exit this process, leaving an orphaned process
# running which immediately forks a supervisory timing process

pid = os.fork()
if pid == 0:
   # ""RETURNING SUCCESS IN UNO""
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:
   # ""DAEMONIZED DOS""
   sub_pid = os.fork()
   if sub_pid == 0:
       # ""RUNNING IN KID A""
       _run_command(cmd, jid, log_path)
       sys.exit(0)
   else:
       # ""WATCHING IN KID B""
       remaining = int(time_limit)
       if os.path.exists(""/proc/%s"" % sub_pid):
           # ""STILL RUNNING""
           time.sleep(1)
           remaining = remaining - 1
       else:
           # ""DONE IN KID B""
           sys.exit(0)
       if remaining == 0:
           # ""SLAYING IN KID B""
           os.kill(sub_pid, signals.SIGKILL)
           sys.exit(1)

   sys.exit(0)


","@@ -96,28 +96,28 @@ def _run_command(wrapped_cmd, jid, log_path):
 
 pid = os.fork()
 if pid == 0:
-   print ""RETURNING SUCCESS IN UNO""
+   # ""RETURNING SUCCESS IN UNO""
    print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
    sys.exit(0)
 else:
-   print ""DAEMONIZED DOS""
+   # ""DAEMONIZED DOS""
    sub_pid = os.fork()
    if sub_pid == 0:
-       print ""RUNNING IN KID A""
+       # ""RUNNING IN KID A""
        _run_command(cmd, jid, log_path)
        sys.exit(0)
    else:
-       print ""WATCHING IN KID B""
+       # ""WATCHING IN KID B""
        remaining = int(time_limit)
        if os.path.exists(""/proc/%s"" % sub_pid):
-           print ""STILL RUNNING""
+           # ""STILL RUNNING""
            time.sleep(1)
            remaining = remaining - 1
        else:
-           print ""DONE IN KID B""
+           # ""DONE IN KID B""
            sys.exit(0)
        if remaining == 0:
-           print ""SLAYING IN KID B""
+           # ""SLAYING IN KID B""
            os.kill(sub_pid, signals.SIGKILL)
            sys.exit(1)
 
",code-fix,code-fix: Modify async_wrapper: +7/-7 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0000001192092896,0.9563762644520368,Minor,Minor,YES
c839229f54ab17df059eef3044d4ff593993a87a,Fix code formatting in README.md,README.md,"Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

   * Dead simple setup
   * Super fast & parallel by default
   * No server or client daemons; use existing SSHd
   * No additional software required on client boxes
   * Modules can be written in ANY language
   * Awesome API for creating very powerful distributed scripts
   * Be usable as non-root
   * Create the easiest config management system to use, ever.

Requirements
============

Requirements are extremely minimal.

If you are running python 2.6 on the 'overlord' machine, you will need:

   * paramiko
   * PyYAML (if using playbooks)

If you are running less than Python 2.6, you will also need

   * the Python 2.4 or 2.5 backport of the multiprocessing module
   * simplejson

On the managed nodes, to use templating, you will need:

   * python-jinja2 (you can install this with ansible)

Patterns and Groups
===================

Ansible works off an inventory file (/etc/ansible/hosts or overrideable with -i).  Hosts can
be listed by IP or hostname, and groups are denoted with square brackets:

Example:

    abc.example.com
    def.example.com

    [atlanta]
    192.168.10.50
    192.168.10.51
   
    [raleigh]
    192.168.10.52

When running ansible commands, hosts are addressed by name, wildcard, or group name. 
This specifier is used in all ansible commands.  'all' is a built-in group name that matches all
hosts.  Group names and host wildcards can be mixed as needed:

    all
    'web*.example.com'
    'appservers;dbservers'
    'atlanta;raleigh'
    '192.168.10.50'

Example: Massive Parallelism and Running Shell Commands
=======================================================

Reboot all web servers in Atlanta, 10 at a time:
 
    > ssh-agent bash
    > ssh-add ~/.ssh/id_rsa.pub

    > ansible atlanta -a ""/sbin/reboot"" -f 10

The -f 10 specifies the usage of 10 simultaneous processes.

Note that other than the command module, ansible modules do not work like simple scripts.  They make
the remote system look like you state, and run the commands neccessary to get it there.

Example: Time-limited Background Operations
===========================================

Long running operations can be backgrounded, and their status can be checked on later.  The same
job ID is given to the same task on all hosts, so you won't lose track.  Polling support
is pending in the command line.

   > ansible all -B 3600 -a ""/usr/bin/long_running_operation --do-stuff""
   > ansible all -n job_status -a jid=123456789

Any module other than 'copy' or 'template' can be backgrounded.

Example: File Transfer and Templating
=====================================

Ansible can SCP lots of files to multiple machines in parallel, and optionally use
them as template sources.

To just transfer a file directly to many different servers:

    > ansible atlanta copy -a ""/etc/hosts /tmp/hosts""

To use templating, first run the setup module to put the template variables you would
like to use on the remote host.  Then use the template module to write the
files using the templates.  Templates are written in Jinja2 format.

    > ansible webservers -m setup    -a ""favcolor=red ntp_server=192.168.1.1""
    > ansible webservers -m template -a ""src=/srv/motd.j2 dest=/etc/motd""
    > ansible webservers -m template -a ""src=/srv/ntp.j2 dest=/etc/ntp.conf""

Need something like the fqdn in a template?  If facter or ohai are installed, data from these projects
will also be made available to the template engine, using 'facter_' and 'ohai_' prefixes for each.

Example: Software Deployment From Source Control
================================================

Deploy your webapp straight from git

    > ansible webservers -m git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Since ansible modules can notify change handlers (see 'Playbooks') it is possible
to tell ansible to run specific tasks when the code is updated, such as deploying
Perl/Python/PHP/Ruby directly from git and then restarting apache.


Other Modules
=============

Ansible has lots of other modules and they are growing.

See the library directory in the source checkout or the manpage:
[ansible-modules(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc) that covers what's there and all the options they take.

Playbooks
=========

Playbooks are a completely different way to use ansible and are particularly awesome.

They are the basis for a really simple configuration management system, unlike
any that already exist, and one that is very well suited to deploying complex
multi-machine applications.  

An example showing a small playbook:

    ---
    - hosts: all
      user: root
      tasks:
      - include: base.yml
      - name: configure template & module variables for future template calls
        action: setup http_port=80 max_clients=200
      - name: write the apache config file
        action: template src=/srv/httpd.j2 dest=/etc/httpd.conf
        notify:
        - restart apache
      - name: ensure apache is running
        action: service name=httpd state=started
      handlers:
        - include: handlers.yml

Some key concepts here include:

   * Everything is expressed in simple YAML
   * Steps can be run as non-root
   * Modules can notify 'handlers' when changes occur.
   * Tasks and handlers can be 'included' to faciliate sharing and 'class' like behavior

To run a playbook:

    ansible-playbook playbook.yml

See the playbook format manpage -- [ansible-playbook(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc) for more details.


API
===

The Python API is very powerful, and is how the ansible CLI and ansible-playbook
are implemented.

    import ansible.runner

    runner = ansible.runner.Runner(
       module_name='ping',
       module_args='',
       pattern='web*',
       forks=10
    )
    datastructure = runner.run()

The run method returns results per host, grouped by whether they 
could be contacted or not.  Return types are module specific, as
expressed in the 'ansible-modules' manpage.

    {
        ""dark"" : {
           ""web1.example.com"" : ""failure message""
        }
        ""contacted"" : {
           ""web2.example.com"" : 1
        }
    }

A module can return any type of JSON data it wants, so Ansible can
be used as a framework to rapidly build powerful applications and scripts.

License
=======

GPLv3

Communicate
===========

   * [ansible-project mailing list](http://groups.google.com/group/ansible-project)
   * irc.freenode.net: #ansible

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","Ansible
=======

Ansible is a extra-simple tool/API for doing 'parallel remote things' over SSH -- whether
executing commands, running ""modules"", or executing larger 'playbooks' that 
can serve as a configuration management or deployment system.

While [Func](http://fedorahosted.org/func), which I co-wrote, 
aspired to avoid using SSH and have it's own daemon infrastructure, 
Ansible aspires to be quite different and more minimal, but still able 
to grow more modularly over time.  This is based on talking to a lot of 
users of various tools and wishing to eliminate problems with connectivity 
and long running daemons, or not picking tool X because they preferred to 
code in Y. Further, playbooks take things a whole step further, building the config
and deployment system I always wanted to build.

Why use Ansible versus something else?  (Fabric, Capistrano, mCollective, 
Func, SaltStack, etc?) It will have far less code, it will be more correct, 
and it will be the easiest thing to hack on and use you'll ever see -- 
regardless of your favorite language of choice.  Want to only code plugins 
in bash or clojure?  Ansible doesn't care.  The docs will fit on one page 
and the source will be blindingly obvious.

Design Principles
=================

   * Dead simple setup
   * Super fast & parallel by default
   * No server or client daemons; use existing SSHd
   * No additional software required on client boxes
   * Modules can be written in ANY language
   * Awesome API for creating very powerful distributed scripts
   * Be usable as non-root
   * Create the easiest config management system to use, ever.

Requirements
============

Requirements are extremely minimal.

If you are running python 2.6 on the 'overlord' machine, you will need:

   * paramiko
   * PyYAML (if using playbooks)

If you are running less than Python 2.6, you will also need

   * the Python 2.4 or 2.5 backport of the multiprocessing module
   * simplejson

On the managed nodes, to use templating, you will need:

   * python-jinja2 (you can install this with ansible)

Patterns and Groups
===================

Ansible works off an inventory file (/etc/ansible/hosts or overrideable with -i).  Hosts can
be listed by IP or hostname, and groups are denoted with square brackets:

Example:

    abc.example.com
    def.example.com

    [atlanta]
    192.168.10.50
    192.168.10.51
   
    [raleigh]
    192.168.10.52

When running ansible commands, hosts are addressed by name, wildcard, or group name. 
This specifier is used in all ansible commands.  'all' is a built-in group name that matches all
hosts.  Group names and host wildcards can be mixed as needed:

    all
    'web*.example.com'
    'appservers;dbservers'
    'atlanta;raleigh'
    '192.168.10.50'

Example: Massive Parallelism and Running Shell Commands
=======================================================

Reboot all web servers in Atlanta, 10 at a time:
 
    > ssh-agent bash
    > ssh-add ~/.ssh/id_rsa.pub

    > ansible atlanta -a ""/sbin/reboot"" -f 10

The -f 10 specifies the usage of 10 simultaneous processes.

Note that other than the command module, ansible modules do not work like simple scripts.  They make
the remote system look like you state, and run the commands neccessary to get it there.

Example: Time-limited Background Operations
===========================================

Long running operations can be backgrounded, and their status can be checked on later.  The same
job ID is given to the same task on all hosts, so you won't lose track.  Polling support
is pending in the command line.

    > ansible all -B 3600 -a ""/usr/bin/long_running_operation --do-stuff""
    > ansible all -n job_status -a jid=123456789

Any module other than 'copy' or 'template' can be backgrounded.

Example: File Transfer and Templating
=====================================

Ansible can SCP lots of files to multiple machines in parallel, and optionally use
them as template sources.

To just transfer a file directly to many different servers:

    > ansible atlanta copy -a ""/etc/hosts /tmp/hosts""

To use templating, first run the setup module to put the template variables you would
like to use on the remote host.  Then use the template module to write the
files using the templates.  Templates are written in Jinja2 format.

    > ansible webservers -m setup    -a ""favcolor=red ntp_server=192.168.1.1""
    > ansible webservers -m template -a ""src=/srv/motd.j2 dest=/etc/motd""
    > ansible webservers -m template -a ""src=/srv/ntp.j2 dest=/etc/ntp.conf""

Need something like the fqdn in a template?  If facter or ohai are installed, data from these projects
will also be made available to the template engine, using 'facter_' and 'ohai_' prefixes for each.

Example: Software Deployment From Source Control
================================================

Deploy your webapp straight from git

    > ansible webservers -m git -a ""repo=git://foo dest=/srv/myapp version=HEAD""

Since ansible modules can notify change handlers (see 'Playbooks') it is possible
to tell ansible to run specific tasks when the code is updated, such as deploying
Perl/Python/PHP/Ruby directly from git and then restarting apache.


Other Modules
=============

Ansible has lots of other modules and they are growing.

See the library directory in the source checkout or the manpage:
[ansible-modules(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-modules.5.asciidoc) that covers what's there and all the options they take.

Playbooks
=========

Playbooks are a completely different way to use ansible and are particularly awesome.

They are the basis for a really simple configuration management system, unlike
any that already exist, and one that is very well suited to deploying complex
multi-machine applications.  

An example showing a small playbook:

    ---
    - hosts: all
      user: root
      tasks:
      - include: base.yml
      - name: configure template & module variables for future template calls
        action: setup http_port=80 max_clients=200
      - name: write the apache config file
        action: template src=/srv/httpd.j2 dest=/etc/httpd.conf
        notify:
        - restart apache
      - name: ensure apache is running
        action: service name=httpd state=started
      handlers:
        - include: handlers.yml

Some key concepts here include:

   * Everything is expressed in simple YAML
   * Steps can be run as non-root
   * Modules can notify 'handlers' when changes occur.
   * Tasks and handlers can be 'included' to faciliate sharing and 'class' like behavior

To run a playbook:

    ansible-playbook playbook.yml

See the playbook format manpage -- [ansible-playbook(5)](https://github.com/mpdehaan/ansible/blob/master/docs/man/man5/ansible-playbook.5.asciidoc) for more details.


API
===

The Python API is very powerful, and is how the ansible CLI and ansible-playbook
are implemented.

    import ansible.runner

    runner = ansible.runner.Runner(
       module_name='ping',
       module_args='',
       pattern='web*',
       forks=10
    )
    datastructure = runner.run()

The run method returns results per host, grouped by whether they 
could be contacted or not.  Return types are module specific, as
expressed in the 'ansible-modules' manpage.

    {
        ""dark"" : {
           ""web1.example.com"" : ""failure message""
        }
        ""contacted"" : {
           ""web2.example.com"" : 1
        }
    }

A module can return any type of JSON data it wants, so Ansible can
be used as a framework to rapidly build powerful applications and scripts.

License
=======

GPLv3

Communicate
===========

   * [ansible-project mailing list](http://groups.google.com/group/ansible-project)
   * irc.freenode.net: #ansible

Author
======

Michael DeHaan -- michael.dehaan@gmail.com

[http://michaeldehaan.net](http://michaeldehaan.net/)


","@@ -102,8 +102,8 @@ Long running operations can be backgrounded, and their status can be checked on
 job ID is given to the same task on all hosts, so you won't lose track.  Polling support
 is pending in the command line.
 
-   > ansible all -B 3600 -a ""/usr/bin/long_running_operation --do-stuff""
-   > ansible all -n job_status -a jid=123456789
+    > ansible all -B 3600 -a ""/usr/bin/long_running_operation --do-stuff""
+    > ansible all -n job_status -a jid=123456789
 
 Any module other than 'copy' or 'template' can be backgrounded.
 
",doc-fix,doc-fix: Modify README.md: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999998807907104,1.0,Minor,Minor,YES
8d06c074b1f6b35aca7a3969481c88229a9078e6,"* Added uptime.py as an example of somewhat minimal API usage & reporting
* Pattern in API now has a default
* Fixed bug in template module operation detected from running playbook (tests for that pending)
* Workaround for multiprocessing lib being harmlessly squeaky (feeder thread got sentinel)",examples/uptime.py,,"#!/usr/bin/python
# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
# example of getting the uptime of all hosts, 10 at a time

import ansible.runner
import sys

# construct the ansible runner and execute on all hosts
results = ansible.runner.Runner(
    pattern='*', forks=10,
    module_name='command', module_args=['/usr/bin/uptime'],
).run()

if results is None:
   print ""No hosts found""
   sys.exit(1)

print ""UP ***********""
for (hostname, result) in results['contacted'].items():
    if not 'failed' in result:
        print ""%s >>> %s"" % (hostname, result['stdout'])

print ""FAILED *******""
for (hostname, result) in results['contacted'].items():
    if 'failed' in result:
        print ""%s >>> %s"" % (hostname, result['msg'])

print ""DOWN *********""
for (hostname, result) in results['dark'].items():
    print ""%s >>> %s"" % (hostname, result)

","@@ -0,0 +1,31 @@
+#!/usr/bin/python
+# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
+# example of getting the uptime of all hosts, 10 at a time
+
+import ansible.runner
+import sys
+
+# construct the ansible runner and execute on all hosts
+results = ansible.runner.Runner(
+    pattern='*', forks=10,
+    module_name='command', module_args=['/usr/bin/uptime'],
+).run()
+
+if results is None:
+   print ""No hosts found""
+   sys.exit(1)
+
+print ""UP ***********""
+for (hostname, result) in results['contacted'].items():
+    if not 'failed' in result:
+        print ""%s >>> %s"" % (hostname, result['stdout'])
+
+print ""FAILED *******""
+for (hostname, result) in results['contacted'].items():
+    if 'failed' in result:
+        print ""%s >>> %s"" % (hostname, result['msg'])
+
+print ""DOWN *********""
+for (hostname, result) in results['dark'].items():
+    print ""%s >>> %s"" % (hostname, result)
+
",logic-fix,logic-fix: Modify uptime.py: +31/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.6001628041267395,0.0,Major,Major,YES
8d06c074b1f6b35aca7a3969481c88229a9078e6,"* Added uptime.py as an example of somewhat minimal API usage & reporting
* Pattern in API now has a default
* Fixed bug in template module operation detected from running playbook (tests for that pending)
* Workaround for multiprocessing lib being harmlessly squeaky (feeder thread got sentinel)",lib/ansible/constants.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

# control side (aka 'overlord')
DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'command'
DEFAULT_PATTERN        = None
DEFAULT_FORKS          = 5
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 10
DEFAULT_REMOTE_USER    = 'root'
DEFAULT_REMOTE_PASS    = None

","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

# control side (aka 'overlord')
DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
DEFAULT_MODULE_PATH    = '/usr/share/ansible'
DEFAULT_MODULE_NAME    = 'command'
DEFAULT_PATTERN        = '*'
DEFAULT_FORKS          = 5
DEFAULT_MODULE_ARGS    = ''
DEFAULT_TIMEOUT        = 10
DEFAULT_REMOTE_USER    = 'root'
DEFAULT_REMOTE_PASS    = None

","@@ -20,7 +20,7 @@
 DEFAULT_HOST_LIST      = '/etc/ansible/hosts'
 DEFAULT_MODULE_PATH    = '/usr/share/ansible'
 DEFAULT_MODULE_NAME    = 'command'
-DEFAULT_PATTERN        = None
+DEFAULT_PATTERN        = '*'
 DEFAULT_FORKS          = 5
 DEFAULT_MODULE_ARGS    = ''
 DEFAULT_TIMEOUT        = 10
",code-fix,code-fix: Modify constants.py: +1/-1 lines,100.0,100.0,0,0,29,29,0.0,0,0,0.9999698400497437,0.9837380598312618,Minor,Minor,YES
8d06c074b1f6b35aca7a3969481c88229a9078e6,"* Added uptime.py as an example of somewhat minimal API usage & reporting
* Pattern in API now has a default
* Fixed bug in template module operation detected from running playbook (tests for that pending)
* Workaround for multiprocessing lib being harmlessly squeaky (feeder thread got sentinel)",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = forks
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = "" "".join(module_args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._transfer_module(conn, tmp, self.module_name)
        new_args = [] 
        new_args = [ self.generated_jid, module, self.background ]
        new_args.extend(self.mo","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def noop(*args, **kwargs):
    pass

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = int(forks)
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = "" "".join(module_args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._transfer_module(conn, tmp, self.module_name)
        new_args = [] 
        new_args = [ self.generated_jid, module, self.b","@@ -34,8 +34,12 @@ import random
 
 ################################################
 
+def noop(*args, **kwargs):
+    pass
+
 def _executor_hook(job_queue, result_queue):
     ''' callback used by multiprocessing pool '''
+
     signal.signal(signal.SIGINT, signal.SIG_IGN)
     while not job_queue.empty():
         try:
@@ -78,7 +82,7 @@ class Runner(object):
         self.host_list, self.groups = self.parse_hosts(host_list)
         self.module_path = module_path
         self.module_name = module_name
-        self.forks       = forks
+        self.forks       = int(forks)
         self.pattern     = pattern
         self.module_args = module_args
         self.timeout     = timeout
@@ -275,8 +279,7 @@ class Runner(object):
         self._transfer_file(conn, source, temppath)
 
         # install the template module
-        self.module_name = 'template'
-        module = self._transfer_module(conn, tmp)
+        module = self._transfer_module(conn, tmp, 'template')
 
         # run the template module
         args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
@@ -318,6 +321,7 @@ class Runner(object):
             raise Exception(""???"")
         self._delete_remote_files(conn, tmp)
         conn.close()
+        
         return result
 
     def remote_log(self, conn, msg):
@@ -355,18 +359,19 @@ class Runner(object):
 
     def run(self):
         ''' xfer & run module on all matched hosts '''
-        
+       
         # find hosts that match the pattern
         hosts = self.match_hosts(self.pattern)
         if len(hosts) == 0:
             return None       
- 
+
         # attack pool of hosts in N forks
         # _executor_hook does all of the work
         hosts = [ (self,x) for x in hosts ]
+
         if self.forks > 1:
-            job_queue = multiprocessing.Queue()
-            result_queue = multiprocessing.Queue()
+            job_queue = multiprocessing.Manager().Queue()
+            result_queue = multiprocessing.Manager().Queue()
  
             for i in hosts:
                 job_queue.put(i)
",logic-fix,logic-fix: Modify runner.py: +12/-7 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.999596357345581,0.9900122588316862,Minor,Minor,YES
369b9cde1cc131c3d69f63a1d91467a77208bf3a,"Add test for template module and make 'dark' errors clearer if we get output back and the JSON
is not parseable",lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def noop(*args, **kwargs):
    pass

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = int(forks)
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except:
            # it failed, say so, but return the string anyway
            return [ host, False, result ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = "" "".join(module_args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._transfer_module(conn, tmp, self.module_name)
        new_args = [] 
        new_args = [ self.generated_jid, module, self.b","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def noop(*args, **kwargs):
    pass

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = int(forks)
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, ""FAILED: %s"" % str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except Exception, e:
            # it failed, say so, but return the string anyway
            return [ host, False, ""%s/%s"" % (str(e), result) ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = "" "".join(module_args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._transfer_module(conn, tmp, self.module_name)
        new_args = [] 
       ","@@ -162,16 +162,16 @@ class Runner(object):
             return [ True, ssh ]
         except Exception, e:
             # it failed somehow, return the failure string
-            return [ False, str(e) ]
+            return [ False, ""FAILED: %s"" % str(e) ]
 
     def _return_from_module(self, conn, host, result):
         ''' helper function to handle JSON parsing of results '''
         try:
             # try to parse the JSON response
             return [ host, True, json.loads(result) ]
-        except:
+        except Exception, e:
             # it failed, say so, but return the string anyway
-            return [ host, False, result ]
+            return [ host, False, ""%s/%s"" % (str(e), result) ]
 
     def _delete_remote_files(self, conn, files):
         ''' deletes one or more remote files '''
@@ -279,11 +279,11 @@ class Runner(object):
         self._transfer_file(conn, source, temppath)
 
         # install the template module
-        module = self._transfer_module(conn, tmp, 'template')
+        template_module = self._transfer_module(conn, tmp, 'template')
 
         # run the template module
         args = [ ""src=%s"" % temppath, ""dest=%s"" % dest, ""metadata=%s"" % metadata ]
-        result = self._execute_module(conn, tmp, module, args)
+        result = self._execute_module(conn, tmp, template_module, args)
         self._delete_remote_files(conn, [ tpath ])
         return self._return_from_module(conn, host, result)
 
",logic-fix,"Add test for template module and make 'dark' errors clearer if we get output back and the JSON
is not parseable",0.0,0.0,0,0,0,0,0.0,0,0,1.000000238418579,0.98248455756098,Minor,Minor,YES
c71afe35d649a8f3aa4db5a122a6723a84760ff3,Async tests complete.  Fixed bug in async_wrapper,library/async_wrapper,"#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback
import signal
import time

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

print sys.argv

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# immediately exit this process, leaving an orphaned process
# running which immediately forks a supervisory timing process

pid = os.fork()
if pid == 0:
   # ""RETURNING SUCCESS IN UNO""
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:
   # ""DAEMONIZED DOS""
   sub_pid = os.fork()
   if sub_pid == 0:
       # ""RUNNING IN KID A""
       _run_command(cmd, jid, log_path)
       sys.exit(0)
   else:
       # ""WATCHING IN KID B""
       remaining = int(time_limit)
       if os.path.exists(""/proc/%s"" % sub_pid):
           # ""STILL RUNNING""
           time.sleep(1)
           remaining = remaining - 1
       else:
           # ""DONE IN KID B""
           sys.exit(0)
       if remaining == 0:
           # ""SLAYING IN KID B""
           os.kill(sub_pid, signals.SIGKILL)
           sys.exit(1)

   sys.exit(0)


","#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    import json
except ImportError:
    import simplejson as json
import shlex
import os
import subprocess
import sys
import datetime
import traceback
import signal
import time

if len(sys.argv) < 3:
    print json.dumps({
        ""failed"" : True,
        ""msg""    : ""usage: async_wrapper <jid> <module_script> <time_limit> <args>.  Humans, do not call directly!""
    })
    sys.exit(1)

jid = sys.argv[1]
time_limit = sys.argv[2]
wrapped_module = sys.argv[3]
args = sys.argv[4:]

cmd = ""%s %s"" % (wrapped_module, "" "".join(args))

# setup logging directory
logdir = os.path.expanduser(""~/.ansible_async"")
log_path = os.path.join(logdir, jid)

if not os.path.exists(logdir):
    try:
        os.makedirs(logdir)
    except:
        print json.dumps({
            ""failed"" : 1,
            ""msg"" : ""could not create: %s"" % logdir
        })

def _run_command(wrapped_cmd, jid, log_path):

    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid }))
    result = {}

    try:
        cmd = shlex.split(wrapped_cmd)
        script = subprocess.Popen(cmd, shell=False, 
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = script.communicate()
        result = json.loads(out)
    
    except (OSError, IOError), e:
        result = {
            ""failed"": 1,
            ""cmd"" : wrapped_cmd,
            ""msg"": str(e),
        }
    except:
        result = {
            ""failed"" : 1,
            ""cmd"" : wrapped_cmd,
            ""msg"" : traceback.format_exc()
        }   

    result['ansible_job_id'] = jid
    logfile = open(log_path, ""w+"")
    logfile.write(json.dumps(result))
    logfile.close()

# immediately exit this process, leaving an orphaned process
# running which immediately forks a supervisory timing process

pid = os.fork()
if pid == 0:
   # ""RETURNING SUCCESS IN UNO""
   print json.dumps({ ""started"" : 1, ""ansible_job_id"" : jid })
   sys.exit(0)
else:
   # ""DAEMONIZED DOS""
   sub_pid = os.fork()
   if sub_pid == 0:
       # ""RUNNING IN KID A""
       _run_command(cmd, jid, log_path)
       sys.exit(0)
   else:
       # ""WATCHING IN KID B""
       remaining = int(time_limit)
       if os.path.exists(""/proc/%s"" % sub_pid):
           # ""STILL RUNNING""
           time.sleep(1)
           remaining = remaining - 1
       else:
           # ""DONE IN KID B""
           sys.exit(0)
       if remaining == 0:
           # ""SLAYING IN KID B""
           os.kill(sub_pid, signals.SIGKILL)
           sys.exit(1)

   sys.exit(0)


","@@ -38,8 +38,6 @@ if len(sys.argv) < 3:
     })
     sys.exit(1)
 
-print sys.argv
-
 jid = sys.argv[1]
 time_limit = sys.argv[2]
 wrapped_module = sys.argv[3]
",code-fix,code-fix: Modify async_wrapper: +0/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999304413795472,0.9913203736542616,Minor,Minor,YES
c71afe35d649a8f3aa4db5a122a6723a84760ff3,Async tests complete.  Fixed bug in async_wrapper,test/TestRunner.py,"
# tests are fairly 'live' (but safe to run)
# setup authorized_keys for logged in user such
# that the user can log in as themselves before running tests

import unittest
import getpass
import ansible.runner
import os
import shutil
import time

class TestRunner(unittest.TestCase):

   def setUp(self):
       self.user = getpass.getuser()
       self.runner = ansible.runner.Runner(
           module_name='ping',
           module_path='library/',
           module_args=[],
           remote_user='root',
           remote_pass=None,
           host_list='test/ansible_hosts',
           timeout=5,
           forks=1,
           background=0,
           pattern='all',
           verbose=True,
       )
       self.cwd = os.getcwd()
       self.test_dir = os.path.join(self.cwd, 'test')
       self.stage_dir = self._prepare_stage_dir()

   def _prepare_stage_dir(self):
       stage_path = os.path.join(self.test_dir, 'test_data')
       if os.path.exists(stage_path):
           shutil.rmtree(stage_path, ignore_errors=False)
           assert not os.path.exists(stage_path)
       os.makedirs(stage_path)
       assert os.path.exists(stage_path)
       return stage_path

   def _get_test_file(self, filename):
       # get a file inside the test input directory
       filename = os.path.join(self.test_dir, filename)
       assert os.path.exists(filename)
       return filename
 
   def _get_stage_file(self, filename):
       # get a file inside the test output directory
       filename = os.path.join(self.stage_dir, filename)
       return filename

   def _run(self, module_name, module_args, background=0):
       ''' run a module and get the localhost results '''
       self.runner.module_name = module_name
       self.runner.module_args = module_args
       self.runner.background  = background
       results = self.runner.run()
       print ""RESULTS=%s"" % results
       assert ""127.0.0.1"" in results['contacted']
       return results['contacted']['127.0.0.1'] 

   def test_ping(self):
       result = self._run('ping',[])
       assert ""ping"" in result

   def test_facter(self):
       result = self._run('facter',[])
       assert ""hostname"" in result

   def test_ohai(self):
       result = self._run('ohai',[])
       assert ""hostname"" in result

   def test_copy(self):
       # test copy module, change trigger, etc
       pass

   def test_copy(self):
       input = self._get_test_file('sample.j2')
       output = self._get_stage_file('sample.out')
       assert not os.path.exists(output)
       result = self._run('copy', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
       ])
       assert os.path.exists(output)
       data_in = file(input).read()
       data_out = file(output).read()
       assert data_in == data_out
       assert 'failed' not in result
       assert result['changed'] == True
       assert 'md5sum' in result
       result = self._run('copy', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
       ])
       assert result['changed'] == False

   def test_template(self):
       input = self._get_test_file('sample.j2')
       metadata = self._get_test_file('metadata.json')
       output = self._get_stage_file('sample.out')
       result = self._run('template', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
           ""metadata=%s"" % metadata
       ])
       assert os.path.exists(output)
       out = file(output).read()
       assert out.find(""duck"") != -1
       assert result['changed'] == True
       assert 'md5sum' in result
       assert 'failed' not in result
       result = self._run('template', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
           ""metadata=%s"" % metadata
       ])
       assert result['changed'] == False

   def test_command(self):
       # test command module, change trigger, etc
       result = self._run('command', [ ""/bin/echo"", ""hi"" ])
       assert ""failed"" not in result
       assert ""msg"" not in result
       assert result['rc'] == 0
       assert result['stdout'] == 'hi'
       assert result['stderr'] == ''
       result = self._run('command', [ ""/bin/false"" ])
       assert result['rc'] == 1
       assert 'failed' not in result
       result = self._run('command', [ ""/usr/bin/this_does_not_exist"", ""splat"" ]) 
       assert 'msg' in result
       assert 'failed' in result
       assert 'rc' not in result

   def test_async(self):
       # test async launch and job status
       # of any particular module
       result = self._run('command', [ ""/bin/sleep"", ""10"" ], background=20)
       print ""RESULT1=%s"" % result
       assert 'ansible_job_id' in result
       assert 'started' in result
       jid = result['ansible_job_id']
       # no real chance of this op taking a while, but whatever
       time.sleep(1)
       # TODO: verify we are still running
       time.sleep(12)
       # CLI will abstract this, but this is how it works internally
       result = self._run('async_status', [ ""jid=%s"" % ansible_job_id ])
       # TODO: would be nice to have tests for supervisory process
       # killing job after X seconds
       assert 'finished' in result
       assert 'failed' not in result
       assert 'rc' in result
       assert 'stdout' in result
       assert result['ansible_job_id'] == jid

","
# tests are fairly 'live' (but safe to run)
# setup authorized_keys for logged in user such
# that the user can log in as themselves before running tests

import unittest
import getpass
import ansible.runner
import os
import shutil
import time

class TestRunner(unittest.TestCase):

   def setUp(self):
       self.user = getpass.getuser()
       self.runner = ansible.runner.Runner(
           module_name='ping',
           module_path='library/',
           module_args=[],
           remote_user='root',
           remote_pass=None,
           host_list='test/ansible_hosts',
           timeout=5,
           forks=1,
           background=0,
           pattern='all',
           verbose=True,
       )
       self.cwd = os.getcwd()
       self.test_dir = os.path.join(self.cwd, 'test')
       self.stage_dir = self._prepare_stage_dir()

   def _prepare_stage_dir(self):
       stage_path = os.path.join(self.test_dir, 'test_data')
       if os.path.exists(stage_path):
           shutil.rmtree(stage_path, ignore_errors=False)
           assert not os.path.exists(stage_path)
       os.makedirs(stage_path)
       assert os.path.exists(stage_path)
       return stage_path

   def _get_test_file(self, filename):
       # get a file inside the test input directory
       filename = os.path.join(self.test_dir, filename)
       assert os.path.exists(filename)
       return filename
 
   def _get_stage_file(self, filename):
       # get a file inside the test output directory
       filename = os.path.join(self.stage_dir, filename)
       return filename

   def _run(self, module_name, module_args, background=0):
       ''' run a module and get the localhost results '''
       self.runner.module_name = module_name
       self.runner.module_args = module_args
       self.runner.background  = background
       results = self.runner.run()
       # when using nosetests this will only show up on failure
       # which is pretty useful
       print ""RESULTS=%s"" % results
       assert ""127.0.0.1"" in results['contacted']
       return results['contacted']['127.0.0.1'] 

   def test_ping(self):
       result = self._run('ping',[])
       assert ""ping"" in result

   def test_facter(self):
       result = self._run('facter',[])
       assert ""hostname"" in result

   def test_ohai(self):
       result = self._run('ohai',[])
       assert ""hostname"" in result

   def test_copy(self):
       # test copy module, change trigger, etc
       pass

   def test_copy(self):
       input = self._get_test_file('sample.j2')
       output = self._get_stage_file('sample.out')
       assert not os.path.exists(output)
       result = self._run('copy', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
       ])
       assert os.path.exists(output)
       data_in = file(input).read()
       data_out = file(output).read()
       assert data_in == data_out
       assert 'failed' not in result
       assert result['changed'] == True
       assert 'md5sum' in result
       result = self._run('copy', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
       ])
       assert result['changed'] == False

   def test_template(self):
       input = self._get_test_file('sample.j2')
       metadata = self._get_test_file('metadata.json')
       output = self._get_stage_file('sample.out')
       result = self._run('template', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
           ""metadata=%s"" % metadata
       ])
       assert os.path.exists(output)
       out = file(output).read()
       assert out.find(""duck"") != -1
       assert result['changed'] == True
       assert 'md5sum' in result
       assert 'failed' not in result
       result = self._run('template', [
           ""src=%s"" % input,
           ""dest=%s"" % output,
           ""metadata=%s"" % metadata
       ])
       assert result['changed'] == False

   def test_command(self):
       # test command module, change trigger, etc
       result = self._run('command', [ ""/bin/echo"", ""hi"" ])
       assert ""failed"" not in result
       assert ""msg"" not in result
       assert result['rc'] == 0
       assert result['stdout'] == 'hi'
       assert result['stderr'] == ''
       result = self._run('command', [ ""/bin/false"" ])
       assert result['rc'] == 1
       assert 'failed' not in result
       result = self._run('command', [ ""/usr/bin/this_does_not_exist"", ""splat"" ]) 
       assert 'msg' in result
       assert 'failed' in result
       assert 'rc' not in result

   def test_async(self):
       # test async launch and job status
       # of any particular module
       result = self._run('command', [ ""/bin/sleep"", ""3"" ], background=20)
       assert 'ansible_job_id' in result
       assert 'started' in result
       jid = result['ansible_job_id']
       # no real chance of this op taking a while, but whatever
       time.sleep(5)
       # CLI will abstract this, but this is how it works internally
       result = self._run('async_status', [ ""jid=%s"" % jid ])
       # TODO: would be nice to have tests for supervisory process
       # killing job after X seconds
       assert 'finished' in result
       assert 'failed' not in result
       assert 'rc' in result
       assert 'stdout' in result
       assert result['ansible_job_id'] == jid

","@@ -57,6 +57,8 @@ class TestRunner(unittest.TestCase):
        self.runner.module_args = module_args
        self.runner.background  = background
        results = self.runner.run()
+       # when using nosetests this will only show up on failure
+       # which is pretty useful
        print ""RESULTS=%s"" % results
        assert ""127.0.0.1"" in results['contacted']
        return results['contacted']['127.0.0.1'] 
@@ -139,17 +141,14 @@ class TestRunner(unittest.TestCase):
    def test_async(self):
        # test async launch and job status
        # of any particular module
-       result = self._run('command', [ ""/bin/sleep"", ""10"" ], background=20)
-       print ""RESULT1=%s"" % result
+       result = self._run('command', [ ""/bin/sleep"", ""3"" ], background=20)
        assert 'ansible_job_id' in result
        assert 'started' in result
        jid = result['ansible_job_id']
        # no real chance of this op taking a while, but whatever
-       time.sleep(1)
-       # TODO: verify we are still running
-       time.sleep(12)
+       time.sleep(5)
        # CLI will abstract this, but this is how it works internally
-       result = self._run('async_status', [ ""jid=%s"" % ansible_job_id ])
+       result = self._run('async_status', [ ""jid=%s"" % jid ])
        # TODO: would be nice to have tests for supervisory process
        # killing job after X seconds
        assert 'finished' in result
",test-fix,test-fix: Modify TestRunner.py: +5/-6 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.0,0.9500585736159648,Minor,Minor,YES
b190ea4b62ad8cae5e4a54a094ba9d55e51b75ad,Fix parse_hosts to not blow up on ungrouped hosts.,lib/ansible/runner.py,"# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def noop(*args, **kwargs):
    pass

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = int(forks)
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, ""FAILED: %s"" % str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except Exception, e:
            # it failed, say so, but return the string anyway
            return [ host, False, ""%s/%s"" % (str(e), result) ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = [ str(x) for x in module_args ]
        args = "" "".join(args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._transfer_module(conn, tmp, self.mod","# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

################################################

try:
    import json
except ImportError:
    import simplejson as json

import fnmatch
import multiprocessing
import signal
import os
import ansible.constants as C 
import Queue
import paramiko
import random

################################################

def noop(*args, **kwargs):
    pass

def _executor_hook(job_queue, result_queue):
    ''' callback used by multiprocessing pool '''

    signal.signal(signal.SIGINT, signal.SIG_IGN)
    while not job_queue.empty():
        try:
            job = job_queue.get(block=False)
            runner, host = job
            result_queue.put(runner._executor(host))
        except Queue.Empty:
            pass

class Runner(object):

    def __init__(self, 
        host_list=C.DEFAULT_HOST_LIST, 
        module_path=C.DEFAULT_MODULE_PATH,
        module_name=C.DEFAULT_MODULE_NAME, 
        module_args=C.DEFAULT_MODULE_ARGS, 
        forks=C.DEFAULT_FORKS, 
        timeout=C.DEFAULT_TIMEOUT, 
        pattern=C.DEFAULT_PATTERN,
        remote_user=C.DEFAULT_REMOTE_USER,
        remote_pass=C.DEFAULT_REMOTE_PASS,
        background=0,
        verbose=False):
    
        ''' 
        Constructor
        host_list   -- file on disk listing hosts to manage, or an array of hostnames
        pattern ------ a fnmatch pattern selecting some of the hosts in host_list
        module_path -- location of ansible library on disk
        module_name -- which module to run
        module_args -- arguments to pass to module
        forks -------- how parallel should we be? 1 is extra debuggable.
        remote_user -- who to login as (default root)
        remote_pass -- provide only if you don't want to use keys or ssh-agent
        background --- if non 0, run async, failing after X seconds, -1 == infinite
        '''

        # save input values
       
        self.host_list, self.groups = self.parse_hosts(host_list)
        self.module_path = module_path
        self.module_name = module_name
        self.forks       = int(forks)
        self.pattern     = pattern
        self.module_args = module_args
        self.timeout     = timeout
        self.verbose     = verbose
        self.remote_user = remote_user
        self.remote_pass = remote_pass
        self.background  = background

        # hosts in each group name in the inventory file
        self._tmp_paths  = {}

        random.seed()
        self.generated_jid = str(random.randint(0, 999999999999))

    @classmethod
    def parse_hosts(cls, host_list):
        ''' 
        parse the host inventory file, returns (hosts, groups) 
        [groupname]
        host1
        host2
        '''

        if type(host_list) == list:
            return (host_list, {})

        host_list = os.path.expanduser(host_list)
        lines = file(host_list).read().split(""\n"")
        groups     = {}
        groups['ungrouped'] = []
        group_name = 'ungrouped'
        results    = []
        for item in lines:
            if item.startswith(""[""):
                group_name = item.replace(""["","""").replace(""]"","""").lstrip().rstrip()
                groups[group_name] = []
            else:
                groups[group_name].append(item)
                results.append(item)

        return (results, groups)


    def _matches(self, host_name, pattern=None):
        ''' returns if a hostname is matched by the pattern '''
        # a pattern is in fnmatch format but more than one pattern
        # can be strung together with semicolons. ex:
        #   atlanta-web*.example.com;dc-web*.example.com

        if host_name == '':
            return False
        pattern = pattern.replace("";"","":"")
        subpatterns = pattern.split("":"")
        for subpattern in subpatterns:
            # the pattern could be a real glob
            if subpattern == 'all':
                return True
            if fnmatch.fnmatch(host_name, subpattern):
                return True
            # or it could be a literal group name instead
            if subpattern in self.groups:
                if host_name in self.groups[subpattern]:
                    return True
        return False

    def _connect(self, host):
        ''' 
        obtains a paramiko connection to the host.
        on success, returns (True, connection) 
        on failure, returns (False, traceback str)
        '''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # try paramiko
            ssh.connect(host, username=self.remote_user, allow_agent=True, 
              look_for_keys=True, password=self.remote_pass, timeout=self.timeout)
            return [ True, ssh ]
        except Exception, e:
            # it failed somehow, return the failure string
            return [ False, ""FAILED: %s"" % str(e) ]

    def _return_from_module(self, conn, host, result):
        ''' helper function to handle JSON parsing of results '''
        try:
            # try to parse the JSON response
            return [ host, True, json.loads(result) ]
        except Exception, e:
            # it failed, say so, but return the string anyway
            return [ host, False, ""%s/%s"" % (str(e), result) ]

    def _delete_remote_files(self, conn, files):
        ''' deletes one or more remote files '''
        if type(files) == str:
            files = [ files ]
        for filename in files:
            if not filename.startswith('/tmp/'):
                raise Exception(""not going to happen"")
            self._exec_command(conn, ""rm -rf %s"" % filename)

    def _transfer_file(self, conn, source, dest):
        ''' transfers a remote file '''
        self.remote_log(conn, 'COPY remote:%s local:%s' % (source, dest))
        sftp = conn.open_sftp()
        sftp.put(source, dest)
        sftp.close()

    def _transfer_module(self, conn, tmp, module):
        ''' 
        transfers a module file to the remote side to execute it,
        but does not execute it yet
        '''
        outpath = self._copy_module(conn, tmp, module)
        self._exec_command(conn, ""chmod +x %s"" % outpath)
        return outpath

    def _execute_module(self, conn, tmp, remote_module_path, module_args):
        ''' 
        runs a module that has already been transferred
        '''
        args = [ str(x) for x in module_args ]
        args = "" "".join(args)
        cmd = ""%s %s"" % (remote_module_path, args)
        result = self._exec_command(conn, cmd)
        self._delete_remote_files(conn, [ tmp ])
        return result

    def _execute_normal_module(self, conn, host, tmp):
        ''' 
        transfer & execute a module that is not 'copy' or 'template'
        because those require extra work.
        '''
        module = self._transfer_module(conn, tmp, self.module_name)
        result = self._execute_module(conn, tmp, module, self.module_args)
        self._delete_remote_files(conn, tmp)
        return self._return_from_module(conn, host, result)

    def _execute_async_module(self, conn, host, tmp):
        ''' 
        transfer the given module name, plus the async module
        and then run the async module wrapping the other module
        '''
        async  = self._transfer_module(conn, tmp, 'async_wrapper')
        module = self._tr","@@ -112,6 +112,7 @@ class Runner(object):
         host_list = os.path.expanduser(host_list)
         lines = file(host_list).read().split(""\n"")
         groups     = {}
+        groups['ungrouped'] = []
         group_name = 'ungrouped'
         results    = []
         for item in lines:
",logic-fix,logic-fix: Modify runner.py: +1/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,1.000000238418579,0.9934143998429324,Minor,Minor,YES
2b22f546a2ab0d0dfeacbdfc27d2d750a725215e,Fix the py[co] part of the clean target in the make file,Makefile,"#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

tests: 
	PYTHONPATH=./lib nosetests

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

loc:
	sloccount lib library bin

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 -r --ignore=E501,E221,W291,W391,E302,E251,E203,W293,E231,E303,E201,E225 lib/ bin/

pyflakes:
	pyflakes lib/ansible/*.py

clean:
	@echo ""Cleaning up distutils stuff""
	rm -rf build
	@echo ""Cleaning up byte compiled python stuff""
	find . -regex "".*\.py[co]$$""
	@echo ""Cleaning up editor backup files""
	find . -type f \( -name ""*~"" -or -name ""#*"" \) -delete
	@echo ""Cleaning up asciidoc to man transformations and results""
	find ./docs/man -type f \( -name ""*.xml"" -or -regex "".*\.[0-9]$$"" \) -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","#!/usr/bin/make

ASCII2MAN = a2x -D $(dir $@) -d manpage -f manpage $<
ASCII2HTMLMAN = a2x -D docs/html/man/ -d manpage -f xhtml
MANPAGES := docs/man/man1/ansible.1 docs/man/man5/ansible-modules.5 docs/man/man5/ansible-playbook.5
SITELIB = $(shell python -c ""from distutils.sysconfig import get_python_lib; print get_python_lib()"")

all: clean python

tests: 
	PYTHONPATH=./lib nosetests

docs: manuals

manuals: $(MANPAGES)

%.1: %.1.asciidoc
	$(ASCII2MAN)

%.5: %.5.asciidoc
	$(ASCII2MAN)

loc:
	sloccount lib library bin

pep8:
	@echo ""#############################################""
	@echo ""# Running PEP8 Compliance Tests""
	@echo ""#############################################""
	pep8 -r --ignore=E501,E221,W291,W391,E302,E251,E203,W293,E231,E303,E201,E225 lib/ bin/

pyflakes:
	pyflakes lib/ansible/*.py

clean:
	@echo ""Cleaning up distutils stuff""
	rm -rf build
	@echo ""Cleaning up byte compiled python stuff""
	find . -regex "".*\.py[co]$$"" -delete
	@echo ""Cleaning up editor backup files""
	find . -type f \( -name ""*~"" -or -name ""#*"" \) -delete
	@echo ""Cleaning up asciidoc to man transformations and results""
	find ./docs/man -type f \( -name ""*.xml"" -or -regex "".*\.[0-9]$$"" \) -delete

python: docs
	python setup.py build

install: docs
	python setup.py install

.PHONEY: docs manual clean pep8
vpath %.asciidoc docs/man/man1


","@@ -36,7 +36,7 @@ clean:
 	@echo ""Cleaning up distutils stuff""
 	rm -rf build
 	@echo ""Cleaning up byte compiled python stuff""
-	find . -regex "".*\.py[co]$$""
+	find . -regex "".*\.py[co]$$"" -delete
 	@echo ""Cleaning up editor backup files""
 	find . -type f \( -name ""*~"" -or -name ""#*"" \) -delete
 	@echo ""Cleaning up asciidoc to man transformations and results""
",code-fix,code-fix: Modify Makefile: +1/-1 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999794960021972,0.983631575077218,Minor,Minor,YES
eadd5644b0e40137dd7e4b8726382695681117f3,Fix project name from where I copied it from :),_layouts/default.html,"<!DOCTYPE html>
<html xmlns=""http://www.w3.org/1999/xhtml"" xml:lang=""en"" lang=""en-us"">
<head>
   <meta http-equiv=""content-type"" content=""text/html; charset=utf-8"" />
   <title>{{ page.title }}</title>
   <meta name=""author"" content=""Cobbler development team"" />

   <!-- syntax highlighting CSS -->
   <link rel=""stylesheet"" href=""/css/syntax.css"" type=""text/css"" />

   <!-- Homepage CSS -->
   <link rel=""stylesheet"" href=""/css/screen.css"" type=""text/css"" media=""screen, projection"" />

   <!-- Typekit -->
   <script type=""text/javascript"" src=""http://use.typekit.com/jpd0pfm.js""></script>
   <script type=""text/javascript"">try{Typekit.load();}catch(e){}</script>
</head>
<body>

<!-- ClickTale Top part -->
<script type=""text/javascript"">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class=""site"">
  <div class=""title"">
    <a href=""/"">Cobbler -- the Linux install and update server</a></A>
  </div>
  
  {{ content }}
  
  <div class=""footer"">
    <div class=""contact"">
    </div>
  </div>
</div>

<a href=""http://github.com/ansible/ansible""><img style=""position: absolute; top: 0; right: 0; border: 0;"" src=""http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"" alt=""Fork me on GitHub"" /></a>

<!-- Google Analytics -->
<script type=""text/javascript"">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27319020-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<!-- Google Analytics end -->

</body>
</html>
","<!DOCTYPE html>
<html xmlns=""http://www.w3.org/1999/xhtml"" xml:lang=""en"" lang=""en-us"">
<head>
   <meta http-equiv=""content-type"" content=""text/html; charset=utf-8"" />
   <title>{{ page.title }}</title>
   <meta name=""author"" content=""Michael DeHaan"" />

   <!-- syntax highlighting CSS -->
   <link rel=""stylesheet"" href=""/css/syntax.css"" type=""text/css"" />

   <!-- Homepage CSS -->
   <link rel=""stylesheet"" href=""/css/screen.css"" type=""text/css"" media=""screen, projection"" />

   <!-- Typekit -->
   <script type=""text/javascript"" src=""http://use.typekit.com/jpd0pfm.js""></script>
   <script type=""text/javascript"">try{Typekit.load();}catch(e){}</script>
</head>
<body>

<!-- ClickTale Top part -->
<script type=""text/javascript"">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class=""site"">
  <div class=""title"">
    <a href=""/"">Ansible -- Multi-node SSH Command and Control</a></A>
  </div>
  
  {{ content }}
  
  <div class=""footer"">
    <div class=""contact"">
    </div>
  </div>
</div>

<a href=""http://github.com/ansible/ansible""><img style=""position: absolute; top: 0; right: 0; border: 0;"" src=""http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"" alt=""Fork me on GitHub"" /></a>

<!-- Google Analytics -->
<script type=""text/javascript"">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27319020-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<!-- Google Analytics end -->

</body>
</html>
","@@ -3,7 +3,7 @@
 <head>
    <meta http-equiv=""content-type"" content=""text/html; charset=utf-8"" />
    <title>{{ page.title }}</title>
-   <meta name=""author"" content=""Cobbler development team"" />
+   <meta name=""author"" content=""Michael DeHaan"" />
 
    <!-- syntax highlighting CSS -->
    <link rel=""stylesheet"" href=""/css/syntax.css"" type=""text/css"" />
@@ -25,7 +25,7 @@ var WRInitTime=(new Date()).getTime();
 
 <div class=""site"">
   <div class=""title"">
-    <a href=""/"">Cobbler -- the Linux install and update server</a></A>
+    <a href=""/"">Ansible -- Multi-node SSH Command and Control</a></A>
   </div>
   
   {{ content }}
",code-fix,code-fix: Modify default.html: +2/-2 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.9999325275421144,0.9161234304072556,Minor,Minor,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/globaltoc.html,,"<li class=""dropdown"" data-dropdown=""dropdown"">
  <a href=""{{ pathto(master_doc) }}""
     class=""dropdown-toggle"">{{ _('Site') }}</a>
  <span class=""globaltoc"">{{ toctree(maxdepth=1) }}</span>
</li>
","@@ -0,0 +1,5 @@
+<li class=""dropdown"" data-dropdown=""dropdown"">
+  <a href=""{{ pathto(master_doc) }}""
+     class=""dropdown-toggle"">{{ _('Site') }}</a>
+  <span class=""globaltoc"">{{ toctree(maxdepth=1) }}</span>
+</li>
",code-fix,code-fix: Modify globaltoc.html: +5/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.6114034056663513,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/layout.html,,"{% extends ""basic/layout.html"" %}
{% set script_files = script_files + ['_static/bootstrap-dropdown.js', '_static/bootstrap-scrollspy.js'] %}
{% set css_files = ['_static/bootstrap.css', '_static/bootstrap-sphinx.css'] + css_files %}

{# Sidebar: Rework into our Boostrap nav section. #}
{% macro navBar() %}
  <div class=""topbar"" data-scrollspy=""scrollspy"" >
    <div class=""topbar-inner"">
      <div class=""container"">
        <a class=""brand"" href=""{{ pathto(master_doc) }}"">{{ shorttitle|e }}</a>
        <ul class=""nav"">
          {% block sidebartoc %}
            {% include ""globaltoc.html"" %}
            {% include ""localtoc.html"" %}
          {% endblock %}
          {% block sidebarrel %}
            {% include ""relations.html"" %}
          {% endblock %}
          {% block sidebarsourcelink %}
            {% include ""sourcelink.html"" %}
          {% endblock %}
        </ul>
        <ul class=""nav secondary-nav"">
          {% block sidebarsearch %}
            {% include ""searchbox.html"" %}
          {% endblock %}
        </ul>
      </div>
    </div>
  </div>
{% endmacro %}

{%- block extrahead %}
<script type=""text/javascript"">
(function () {
  /**
   * Patch TOC list.
   *
   * Will mutate the underlying span to have a correct ul for nav.
   *
   * @param $span: Span containing nested UL's to mutate.
   * @param minLevel: Starting level for nested lists. (1: global, 2: local).
   */
  var patchToc = function ($span, minLevel) {
    var $tocList = $(""<ul/>"").attr('class', ""dropdown-menu""),
      findA;

    // Find all a ""internal"" tags, traversing recursively.
    findA = function ($elem, level) {
      var level = level || 0,
        $items = $elem.find(""> li > a.internal, > ul, > li > ul"");

      // Iterate everything in order.
      $items.each(function (index, item) {
        var $item = $(item),
          tag = item.tagName.toLowerCase(),
          pad = 10 + ((level - minLevel) * 10);

        if (tag === 'a' && level >= minLevel) {
          // Add to existing padding.
          $item.css('padding-left', pad + ""px"");
          // Add list element.
          $tocList.append($(""<li/>"").append($item));
        } else if (tag === 'ul') {
          // Recurse.
          findA($item, level + 1);
        }
      });
    };

    // Start construction and return.
    findA($span);

    // Wipe out old list and patch in new one.
    return $span.empty(""ul"").append($tocList);
  };

  $(document).ready(function () {
    // Patch the global and local TOC's to be bootstrap-compliant.
    patchToc($(""span.globaltoc""), 1);
    patchToc($(""span.localtoc""), 2);

    // Activate.
    $('#topbar').dropdown();
  });
}());
</script>
{% endblock %}

{% block header %}{{ navBar() }}{% endblock %}

{# Silence the sidebar's, relbar's #}
{% block sidebar1 %}{% endblock %}
{% block sidebar2 %}{% endblock %}
{% block relbar1 %}{% endblock %}
{% block relbar2 %}{% endblock %}

{%- block content %}
<div class=""container"">
   {% block body %} {% endblock %}
</div>
{%- endblock %}

{%- block footer %}
<footer class=""footer"">
  <div class=""container"">
    <p class=""pull-right""><a href=""#"">Back to top</a></p>
    <p>
    {%- if show_copyright %}
      {%- if hasdoc('copyright') %}
        {% trans path=pathto('copyright'), copyright=copyright|e %}&copy; <a href=""{{ path }}"">Copyright</a> {{ copyright }}.{% endtrans %}<br/>
      {%- else %}
        {% trans copyright=copyright|e %}&copy; Copyright {{ copyright }}.{% endtrans %}<br/>
      {%- endif %}
    {%- endif %}
    {%- if last_updated %}
      {% trans last_updated=last_updated|e %}Last updated on {{ last_updated }}.{% endtrans %}<br/>
    {%- endif %}
    {%- if show_sphinx %}
      {% trans sphinx_version=sphinx_version|e %}Created using <a href=""http://sphinx.pocoo.org/"">Sphinx</a> {{ sphinx_version }}.{% endtrans %}<br/>
    {%- endif %}
    </p>
  </div>
</footer>
{%- endblock %}

","@@ -0,0 +1,126 @@
+{% extends ""basic/layout.html"" %}
+{% set script_files = script_files + ['_static/bootstrap-dropdown.js', '_static/bootstrap-scrollspy.js'] %}
+{% set css_files = ['_static/bootstrap.css', '_static/bootstrap-sphinx.css'] + css_files %}
+
+{# Sidebar: Rework into our Boostrap nav section. #}
+{% macro navBar() %}
+  <div class=""topbar"" data-scrollspy=""scrollspy"" >
+    <div class=""topbar-inner"">
+      <div class=""container"">
+        <a class=""brand"" href=""{{ pathto(master_doc) }}"">{{ shorttitle|e }}</a>
+        <ul class=""nav"">
+          {% block sidebartoc %}
+            {% include ""globaltoc.html"" %}
+            {% include ""localtoc.html"" %}
+          {% endblock %}
+          {% block sidebarrel %}
+            {% include ""relations.html"" %}
+          {% endblock %}
+          {% block sidebarsourcelink %}
+            {% include ""sourcelink.html"" %}
+          {% endblock %}
+        </ul>
+        <ul class=""nav secondary-nav"">
+          {% block sidebarsearch %}
+            {% include ""searchbox.html"" %}
+          {% endblock %}
+        </ul>
+      </div>
+    </div>
+  </div>
+{% endmacro %}
+
+{%- block extrahead %}
+<script type=""text/javascript"">
+(function () {
+  /**
+   * Patch TOC list.
+   *
+   * Will mutate the underlying span to have a correct ul for nav.
+   *
+   * @param $span: Span containing nested UL's to mutate.
+   * @param minLevel: Starting level for nested lists. (1: global, 2: local).
+   */
+  var patchToc = function ($span, minLevel) {
+    var $tocList = $(""<ul/>"").attr('class', ""dropdown-menu""),
+      findA;
+
+    // Find all a ""internal"" tags, traversing recursively.
+    findA = function ($elem, level) {
+      var level = level || 0,
+        $items = $elem.find(""> li > a.internal, > ul, > li > ul"");
+
+      // Iterate everything in order.
+      $items.each(function (index, item) {
+        var $item = $(item),
+          tag = item.tagName.toLowerCase(),
+          pad = 10 + ((level - minLevel) * 10);
+
+        if (tag === 'a' && level >= minLevel) {
+          // Add to existing padding.
+          $item.css('padding-left', pad + ""px"");
+          // Add list element.
+          $tocList.append($(""<li/>"").append($item));
+        } else if (tag === 'ul') {
+          // Recurse.
+          findA($item, level + 1);
+        }
+      });
+    };
+
+    // Start construction and return.
+    findA($span);
+
+    // Wipe out old list and patch in new one.
+    return $span.empty(""ul"").append($tocList);
+  };
+
+  $(document).ready(function () {
+    // Patch the global and local TOC's to be bootstrap-compliant.
+    patchToc($(""span.globaltoc""), 1);
+    patchToc($(""span.localtoc""), 2);
+
+    // Activate.
+    $('#topbar').dropdown();
+  });
+}());
+</script>
+{% endblock %}
+
+{% block header %}{{ navBar() }}{% endblock %}
+
+{# Silence the sidebar's, relbar's #}
+{% block sidebar1 %}{% endblock %}
+{% block sidebar2 %}{% endblock %}
+{% block relbar1 %}{% endblock %}
+{% block relbar2 %}{% endblock %}
+
+{%- block content %}
+<div class=""container"">
+   {% block body %} {% endblock %}
+</div>
+{%- endblock %}
+
+{%- block footer %}
+<footer class=""footer"">
+  <div class=""container"">
+    <p class=""pull-right""><a href=""#"">Back to top</a></p>
+    <p>
+    {%- if show_copyright %}
+      {%- if hasdoc('copyright') %}
+        {% trans path=pathto('copyright'), copyright=copyright|e %}&copy; <a href=""{{ path }}"">Copyright</a> {{ copyright }}.{% endtrans %}<br/>
+      {%- else %}
+        {% trans copyright=copyright|e %}&copy; Copyright {{ copyright }}.{% endtrans %}<br/>
+      {%- endif %}
+    {%- endif %}
+    {%- if last_updated %}
+      {% trans last_updated=last_updated|e %}Last updated on {{ last_updated }}.{% endtrans %}<br/>
+    {%- endif %}
+    {%- if show_sphinx %}
+      {% trans sphinx_version=sphinx_version|e %}Created using <a href=""http://sphinx.pocoo.org/"">Sphinx</a> {{ sphinx_version }}.{% endtrans %}<br/>
+    {%- endif %}
+    </p>
+  </div>
+</footer>
+{%- endblock %}
+
",code-fix,code-fix: Modify layout.html: +126/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5429370403289795,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/localtoc.html,,"<li class=""dropdown"" data-dropdown=""dropdown"">
  <a href=""#""
     class=""dropdown-toggle"">{{ _('Page') }}</a>
  <span class=""localtoc"">{{ toc }}</span>
</li>
","@@ -0,0 +1,5 @@
+<li class=""dropdown"" data-dropdown=""dropdown"">
+  <a href=""#""
+     class=""dropdown-toggle"">{{ _('Page') }}</a>
+  <span class=""localtoc"">{{ toc }}</span>
+</li>
",code-fix,code-fix: Modify localtoc.html: +5/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.588657021522522,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/relations.html,,"{%- if prev %}
  <li><a href=""{{ prev.link|e }}""
         title=""{{ _('previous chapter') }}"">{{ ""&laquo;""|safe }} {{ prev.title }}</a></li>
{%- endif %}
{%- if next %}
  <li><a href=""{{ next.link|e }}""
         title=""{{ _('next chapter') }}"">{{ next.title }} {{ ""&raquo;""|safe }}</a></li>
{%- endif %}
","@@ -0,0 +1,8 @@
+{%- if prev %}
+  <li><a href=""{{ prev.link|e }}""
+         title=""{{ _('previous chapter') }}"">{{ ""&laquo;""|safe }} {{ prev.title }}</a></li>
+{%- endif %}
+{%- if next %}
+  <li><a href=""{{ next.link|e }}""
+         title=""{{ _('next chapter') }}"">{{ next.title }} {{ ""&raquo;""|safe }}</a></li>
+{%- endif %}
",code-fix,code-fix: Modify relations.html: +8/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.562789797782898,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/searchbox.html,,"{%- if pagename != ""search"" %}
<form class=""pull-left"" action=""{{ pathto('search') }}"" method=""get"">
  <input type=""text"" name=""q"" placeholder=""Search"" />
  <input type=""hidden"" name=""check_keywords"" value=""yes"" />
  <input type=""hidden"" name=""area"" value=""default"" />
</form>
{%- endif %}
","@@ -0,0 +1,7 @@
+{%- if pagename != ""search"" %}
+<form class=""pull-left"" action=""{{ pathto('search') }}"" method=""get"">
+  <input type=""text"" name=""q"" placeholder=""Search"" />
+  <input type=""hidden"" name=""check_keywords"" value=""yes"" />
+  <input type=""hidden"" name=""area"" value=""default"" />
+</form>
+{%- endif %}
",code-fix,code-fix: Modify searchbox.html: +7/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5905677676200867,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/sourcelink.html,,"{%- if show_source and has_source and sourcename %}
  <li><a href=""{{ pathto('_sources/' + sourcename, true)|e }}""
         rel=""nofollow"">{{ _('Source') }}</a></li>
{%- endif %}
","@@ -0,0 +1,4 @@
+{%- if show_source and has_source and sourcename %}
+  <li><a href=""{{ pathto('_sources/' + sourcename, true)|e }}""
+         rel=""nofollow"">{{ _('Source') }}</a></li>
+{%- endif %}
",code-fix,code-fix: Modify sourcelink.html: +4/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.58768630027771,0.0,Major,Major,YES
f25b39b7ceea03cf2700a1bf5d4977da515b06db,"Switch to the 'Sphinx Bootstrap' Theme:
https://github.com/ryan-roemer/sphinx-bootstrap-theme

Fix some rst related formatting.",_themes/bootstrap/static/bootstrap-dropdown.js,,"/* ============================================================
 * bootstrap-dropdown.js v1.4.0
 * http://twitter.github.com/bootstrap/javascript.html#dropdown
 * ============================================================
 * Copyright 2011 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function( $ ){

  ""use strict""

  /* DROPDOWN PLUGIN DEFINITION
   * ========================== */

  $.fn.dropdown = function ( selector ) {
    return this.each(function () {
      $(this).delegate(selector || d, 'click', function (e) {
        var li = $(this).parent('li')
          , isActive = li.hasClass('open')

        clearMenus()
        !isActive && li.toggleClass('open')
        return false
      })
    })
  }

  /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */

  var d = 'a.menu, .dropdown-toggle'

  function clearMenus() {
    $(d).parent('li').removeClass('open')
  }

  $(function () {
    $('html').bind(""click"", clearMenus)
    $('body').dropdown( '[data-dropdown] a.menu, [data-dropdown] .dropdown-toggle' )
  })

}( window.jQuery || window.ender );
","@@ -0,0 +1,55 @@
+/* ============================================================
+ * bootstrap-dropdown.js v1.4.0
+ * http://twitter.github.com/bootstrap/javascript.html#dropdown
+ * ============================================================
+ * Copyright 2011 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ============================================================ */
+
+
+!function( $ ){
+
+  ""use strict""
+
+  /* DROPDOWN PLUGIN DEFINITION
+   * ========================== */
+
+  $.fn.dropdown = function ( selector ) {
+    return this.each(function () {
+      $(this).delegate(selector || d, 'click', function (e) {
+        var li = $(this).parent('li')
+          , isActive = li.hasClass('open')
+
+        clearMenus()
+        !isActive && li.toggleClass('open')
+        return false
+      })
+    })
+  }
+
+  /* APPLY TO STANDARD DROPDOWN ELEMENTS
+   * =================================== */
+
+  var d = 'a.menu, .dropdown-toggle'
+
+  function clearMenus() {
+    $(d).parent('li').removeClass('open')
+  }
+
+  $(function () {
+    $('html').bind(""click"", clearMenus)
+    $('body').dropdown( '[data-dropdown] a.menu, [data-dropdown] .dropdown-toggle' )
+  })
+
+}( window.jQuery || window.ender );
",code-fix,code-fix: Modify bootstrap-dropdown.js: +55/-0 lines,0.0,0.0,0,0,0,0,0.0,0,0,0.5816033482551575,0.0,Major,Major,YES
